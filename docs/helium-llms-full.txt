# Helius AirShip Guide: Get Started with ZK Compressed Airdrops
Source: https://www.helius.dev/docs/airship/getting-started

Complete guide to using Helius AirShip for Solana token airdrops. Learn ZK compression, cost savings, and distribution to NFT holders and token holders.

<Info>
  **Helius AirShip** is an open-source tool that makes token airdrops simple, affordable, and accessible. Whether you're distributing to Saga Chapter 2 holders, NFT/cNFT holders, SPL token holders, or using a CSV file, AirShip streamlines the process and dramatically reduces costs through ZK compression.
</Info>

## What is AirShip?

AirShip is a comprehensive airdrop solution that leverages ZK compression to make large-scale token distribution affordable on Solana. Instead of creating individual token accounts for each recipient (which costs \~0.002 SOL each), AirShip uses ZK compression to bundle recipient data into a single Merkle root, reducing costs by over 95%.

<Note>
  For a detailed explanation of airdrop costs and how ZK compression works, read our comprehensive guide: [The Cheapest Way to Airdrop Solana Tokens](https://www.helius.dev/blog/solana-airdrop)
</Note>

<CardGroup cols={2}>
  <Card title="Web Version" icon="globe" href="#using-the-web-version">
    Perfect for small airdrops, up to 200,000 recipients
  </Card>

  <Card title="CLI Version" icon="terminal" href="#using-the-cli-version">
    For advanced users needing larger-scale distribution
  </Card>
</CardGroup>

## Key Features

<CardGroup cols={2}>
  <Card title="Simplified Airdrops" icon="paper-plane">
    Easy token airdrops for all, no technical skills needed
  </Card>

  <Card title="ZK Compression" icon="compress">
    Cut costs on large airdrops by reducing account usage
  </Card>

  <Card title="Multiple Recipients" icon="users">
    Support for NFT holders, token holders, CSV files, and more
  </Card>

  <Card title="Cost Effective" icon="dollar-sign">
    Reduce airdrop costs by over 95% compared to traditional methods
  </Card>
</CardGroup>

## Cost Comparison

<Tip>
  The savings from ZK compression become even more significant as you scale to larger recipient lists.
</Tip>

<CardGroup cols={2}>
  <Card title="Traditional Airdrop" icon="x" color="#ef4444">
    **10,000 recipients**: 20 SOL (\$4,800)
  </Card>

  <Card title="ZK Compressed Airdrop" icon="check" color="#10b981">
    **10,000 recipients**: 0.01 SOL (\$2.40)
  </Card>
</CardGroup>

## Prerequisites

<CardGroup cols={2}>
  <Card title="Solana Wallet" icon="wallet">
    A wallet that holds the tokens you want to distribute
  </Card>

  <Card title="SOL for Fees" icon="coins">
    Enough SOL to cover minimal transaction fees
  </Card>

  <Card title="Recipient List" icon="list">
    CSV file, NFT holders, or token holders
  </Card>

  <Card title="RPC Endpoint" icon="server">
    Supports ZK compression and DAS API ([get one free](https://www.helius.dev))
  </Card>
</CardGroup>

## Using the Web Version

<Info>
  The web version is perfect for smaller airdrops and users who prefer a graphical interface.
</Info>

<Steps>
  <Step title="Access AirShip">
    Visit the [AirShip website](https://airship.helius.dev) and click "Create New Airdrop."
  </Step>

  <Step title="Configure Your Wallet">
    1. Enter your private key and RPC URL
    2. Use an RPC like `https://mainnet.helius-rpc.com/?api-key=YOUR_API_KEY`

    <Warning>
      Use a temporary wallet created specifically for this airdrop task. The private key is only used for signing transactions and isn't stored or shared anywhere.
    </Warning>
  </Step>

  <Step title="Select Recipients">
    Choose from several options:

    <CardGroup cols={2}>
      <Card title="NFT Holders" icon="image">
        Select specific NFT collections
      </Card>

      <Card title="Token Holders" icon="coins">
        Target holders of specific SPL tokens
      </Card>

      <Card title="Saga Holders" icon="mobile">
        Distribute to Saga Chapter 2 holders
      </Card>

      <Card title="CSV Upload" icon="file-csv">
        Upload your own list of recipients
      </Card>
    </CardGroup>
  </Step>

  <Step title="Set Token Amount">
    Specify either:

    * A fixed number of tokens per recipient
    * A percentage of your total token supply to distribute
  </Step>

  <Step title="Review and Confirm">
    Carefully review the airdrop summary:

    * Total recipients
    * Token amount per recipient
    * Estimated transaction fees
    * Total cost

    Once confirmed, AirShip will handle the batch sending and ZK proofs automatically.
  </Step>
</Steps>

## Using the CLI Version

<Info>
  The CLI version is better for larger airdrops and users who prefer command-line tools.
</Info>

### Installation

<Tabs>
  <Tab title="npm">
    ```bash
    npm install -g helius-airship
    ```
  </Tab>

  <Tab title="Build from Source">
    ```bash
    git clone https://github.com/helius-labs/airship.git
    cd airship
    pnpm install && pnpm build
    cd packages/cli
    pnpm link --global
    ```
  </Tab>
</Tabs>

### Usage

<CodeGroup>
  ```bash Basic Command
  helius-airship \
    --keypair /path/to/your/airdrop_wallet.json \
    --url "https://mainnet.helius-rpc.com/?api-key=YOUR_API_KEY"
  ```

  ```bash With Help
  helius-airship --help
  ```
</CodeGroup>

<Note>
  Replace `/path/to/your/airdrop_wallet.json` with the path to your Solana filesystem wallet and `YOUR_API_KEY` with your Helius API key.
</Note>

### Interactive Setup

<Steps>
  <Step title="Select Recipient Type">
    Choose from NFT holders, token holders, CSV, etc.
  </Step>

  <Step title="Specify Token Amounts">
    Set the amount to distribute per recipient
  </Step>

  <Step title="Confirm Details">
    Review the airdrop configuration
  </Step>

  <Step title="Execute Transactions">
    AirShip will handle the batch processing
  </Step>
</Steps>

## Requirements

<CardGroup cols={3}>
  <Card title="Node.js" icon="node-js">
    Node.js >= v20.9.0

    pnpm >= v9.13.2 (for building from source)
  </Card>

  <Card title="Solana Wallet" icon="wallet">
    A valid filesystem wallet that:

    * Holds the tokens to distribute
    * Has SOL for transaction fees
    * Owns the token being distributed
  </Card>

  <Card title="RPC Endpoint" icon="server">
    Must support:

    * ZK Compression
    * Digital Asset Standard (DAS) API

    [Get one free at Helius Dashboard](https://www.dashbord.helius.dev)
  </Card>
</CardGroup>

<Note>
  If you don't have a filesystem wallet, visit the [Solana documentation](https://docs.solana.com/cli/install-solana-cli-tools) for details on creating one.
</Note>

## Best Practices

<CardGroup cols={2}>
  <Card title="Test First" icon="flask">
    Always test with a small batch before running large airdrops
  </Card>

  <Card title="Use Dedicated Wallets" icon="shield">
    Create a separate wallet specifically for airdrops
  </Card>

  <Card title="Backup Data" icon="download">
    Save your recipient lists and transaction signatures
  </Card>

  <Card title="Verify Recipients" icon="check-double">
    Double-check your recipient addresses before executing
  </Card>
</CardGroup>

### Getting Help

<CardGroup cols={3}>
  <Card title="GitHub Issues" icon="github" href="https://github.com/helius-labs/airship">
    Check for issues and updates
  </Card>

  <Card title="Discord Support" icon="discord" href="https://discord.com/invite/6GXdee3gBj">
    Join the community
  </Card>

  <Card title="Documentation" icon="book" href="/zk-compression/introduction">
    Review ZK compression docs
  </Card>
</CardGroup>

## Next Steps

<Steps>
  <Step title="Verify Distribution">
    Check successful distribution using block explorers
  </Step>

  <Step title="Monitor Balances">
    Keep track of recipient token balances
  </Step>

  <Step title="Explore More Features">
    Check out other [compression features](/nfts/nft-compression)
  </Step>
</Steps>

<Tip>
  AirShip makes token distribution accessible and affordable, enabling you to reward your community without breaking the bank. The combination of ZK compression and an intuitive interface removes the technical barriers that previously made large-scale airdrops costly and complex.
</Tip>

## Additional Resources

<CardGroup cols={2}>
  <Card title="Blog: Cheapest Way to Airdrop" icon="newspaper" href="https://www.helius.dev/blog/solana-airdrop">
    Comprehensive guide to airdrop costs and ZK compression
  </Card>

  <Card title="AirShip Calculator" icon="calculator" href="https://airship.helius.dev">
    Calculate your airdrop costs before you start
  </Card>
</CardGroup>


# Helius AirShip: Solana Token Airdrop Tool with ZK Compression
Source: https://www.helius.dev/docs/airship/overview

Cost-effective Solana token airdrops using ZK compression. Reduce airdrop costs by 95% with Helius AirShip's open-source distribution tool.

<CardGroup cols={2}>
  <Card title="Getting Started" icon="rocket" href="/airship/getting-started">
    Learn how to use AirShip for your first airdrop
  </Card>

  <Card title="GitHub Repository" icon="github" href="https://github.com/helius-labs/airship">
    View the open-source code and contribute
  </Card>
</CardGroup>

## What is AirShip?

AirShip is Helius's open-source token airdrop tool that leverages ZK compression to make large-scale token distribution affordable on Solana. By bundling recipient data into a single Merkle root instead of creating individual token accounts, AirShip reduces airdrop costs by over 95%.

<CardGroup cols={2}>
  <Card title="Traditional Airdrop" icon="x" color="#ef4444">
    **10,000 recipients**

    20 SOL (\~\$4,800)
  </Card>

  <Card title="With AirShip" icon="check" color="#10b981">
    **Same 10,000 recipients**

    0.01 SOL (\~\$2.40)
  </Card>
</CardGroup>

<Tip>
  **Save over 95% on airdrop costs** - AirShip's ZK compression turns expensive token distribution into an affordable community-building tool.
</Tip>

## Features

<CardGroup cols={3}>
  <Card title="Web Interface" icon="browser">
    User-friendly web app for easy airdrops
  </Card>

  <Card title="CLI Tool" icon="terminal">
    Command-line interface for advanced users
  </Card>

  <Card title="Multiple Recipients" icon="users">
    NFT holders, token holders, CSV files, and more
  </Card>

  <Card title="ZK Compression" icon="compress">
    Massive cost savings through compression
  </Card>

  <Card title="Open Source" icon="code">
    Fully open-source and community-driven
  </Card>

  <Card title="Helius Integration" icon="plug">
    Built for Helius RPC endpoints
  </Card>
</CardGroup>

## Get Started

Ready to launch your first cost-effective airdrop? Check out our [getting started guide](/airship/getting-started) to learn how to use both the web interface and CLI tool.

<CardGroup cols={2}>
  <Card title="Web Version" icon="globe" href="https://airship.helius.dev">
    Launch the web application
  </Card>

  <Card title="Documentation" icon="book" href="/airship/getting-started">
    Read the complete guide
  </Card>
</CardGroup>

## Learn More

<CardGroup cols={2}>
  <Card title="Blog: Cheapest Way to Airdrop" icon="newspaper" href="https://www.helius.dev/blog/solana-airdrop">
    Deep dive into airdrop costs and ZK compression
  </Card>

  <Card title="ZK Compression Guide" icon="compress" href="/zk-compression/introduction">
    Technical details about compression
  </Card>
</CardGroup>


# Solana API Reference
Source: https://www.helius.dev/docs/api-reference

Comprehensive Solana blockchain APIs including RPC, DAS, webhooks, and data streaming. Complete reference for developers building on Solana with Helius.

### Solana RPC APIs

<CardGroup cols={2}>
  <Card title="HTTP Methods" icon="server" href="/api-reference/rpc/http-methods">
    Land transactions effectively, query blockchain data instantly, and benefit from enhanced reliability and performance.
  </Card>

  <Card title="WebSocket Methods" icon="signal-stream" href="/api-reference/rpc/websocket-methods">
    Create responsive applications by subscribing to real-time blockchain events. Eliminate polling and reduce latency in your user interfaces.
  </Card>
</CardGroup>

### Token & Transaction APIs

<CardGroup cols={2}>
  <Card title="Digital Asset Standard (DAS)" icon="hexagon-image" href="/api-reference/das">
    Access standardized token and NFT metadata with a single API call. Handles both regular and compressed NFTs automatically.
  </Card>

  <Card title="Priority Fee API" icon="star" href="/api-reference/priority-fee/getpriorityfeeestimate">
    Get recommended transaction fees based on current network conditions. Prevent timeouts and ensure timely confirmation of your transactions.
  </Card>

  <Card title="Enhanced Transactions" icon="receipt" href="/api-reference/enhanced-transactions">
    Retrieve pre-parsed transaction data in human-readable format. Save development time with structured information ready for display.
  </Card>

  <Card title="ZK Compression" icon="arrows-to-circle" href="/api-reference/zk-compression">
    Dramatically reduce account storage costs by up to 98% for on-chain data.
  </Card>
</CardGroup>

### Data Streaming APIs

<CardGroup cols={1}>
  <Card title="LaserStream gRPC" icon="bolt" href="/api-reference/laserstream/grpc">
    Stream blockchain data with ultra-low latency using lightweight clients. Apply custom filters to receive only the updates relevant to your application.
  </Card>
</CardGroup>

<CardGroup cols={1}>
  <Card title="Webhooks" icon="webhook" href="/api-reference/webhooks">
    Configure instant notifications for blockchain events sent directly to your application. Eliminate the need for constant polling while maintaining data currency.
  </Card>
</CardGroup>


# Authentication
Source: https://www.helius.dev/docs/api-reference/authentication

Learn how to authenticate your Helius API requests securely and efficiently

# Authentication

Helius API uses API keys to authenticate requests. Every API request must include your API key to verify your identity and permissions.

<Warning>
  Your API key is sensitive information that grants access to your Helius account. Never expose it in client-side code, public repositories, or browser-accessible areas.
</Warning>

## Getting Started

### 1. Create Your API Key

<Steps>
  <Step title="Sign up or log in">
    Create an account on the [Helius Dashboard](https://dashboard.helius.dev) or log in to your existing account.
  </Step>

  <Step title="Navigate to API Keys">
    Go to the **API Keys** section in your dashboard sidebar.
  </Step>

  <Step title="Generate a new key">
    Click **Create New API Key** and provide a descriptive name for your project (e.g., "Production App", "Development Environment").
  </Step>

  <Step title="Copy and secure your key">
    Copy your API key immediately and store it securely. You won't be able to see it again once you navigate away.
  </Step>
</Steps>

### 2. Using Your API Key

Include your API key as a query parameter in all requests:

<CodeGroup>
  ```bash cURL
  curl "https://mainnet.helius-rpc.com/?api-key=YOUR_API_KEY" \
    -X POST \
    -H "Content-Type: application/json" \
    -d '{"jsonrpc":"2.0","id":1,"method":"getAccountInfo","params":["ACCOUNT_ADDRESS"]}'
  ```

  ```javascript JavaScript
  const url = `https://mainnet.helius-rpc.com/?api-key=${YOUR_API_KEY}`;
  const response = await fetch(url, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      jsonrpc: '2.0',
      id: 1,
      method: 'getAccountInfo',
      params: ['ACCOUNT_ADDRESS']
    })
  });
  ```

  ```python Python
  import requests

  url = f"https://mainnet.helius-rpc.com/?api-key={YOUR_API_KEY}"
  payload = {
      "jsonrpc": "2.0",
      "id": 1,
      "method": "getAccountInfo",
      "params": ["ACCOUNT_ADDRESS"]
  }
  response = requests.post(url, json=payload)
  ```
</CodeGroup>

## Security Best Practices

<CardGroup cols={2}>
  <Card title="Environment Variables" icon="shield-check">
    Store your API key in environment variables, not in your source code.

    ```bash
    export HELIUS_API_KEY="your-api-key-here"
    ```
  </Card>

  <Card title="IP Restrictions" icon="globe">
    Set up IP restrictions for your API keys in the dashboard to limit access to specific IP addresses or ranges.
  </Card>

  <Card title="Separate Keys" icon="key">
    Use different API keys for development, staging, and production environments to isolate usage and improve security.
  </Card>

  <Card title="Monitor Usage" icon="chart-line">
    Regularly check your API usage in the dashboard to detect unusual patterns or potential security issues.
  </Card>
</CardGroup>

### Secret Management

<Tabs>
  <Tab title="Node.js">
    ```javascript
    // Use environment variables
    const apiKey = process.env.HELIUS_API_KEY;

    // Or use a secrets manager
    const { SecretManagerServiceClient } = require('@google-cloud/secret-manager');
    const client = new SecretManagerServiceClient();

    async function getApiKey() {
      const [version] = await client.accessSecretVersion({
        name: 'projects/PROJECT_ID/secrets/helius-api-key/versions/latest',
      });
      return version.payload.data.toString();
    }
    ```
  </Tab>

  <Tab title="Python">
    ```python
    import os
    from dotenv import load_dotenv

    # Load environment variables
    load_dotenv()
    api_key = os.getenv('HELIUS_API_KEY')

    # Or use AWS Secrets Manager
    import boto3

    def get_secret():
        client = boto3.client('secretsmanager')
        response = client.get_secret_value(SecretId='helius-api-key')
        return response['SecretString']
    ```
  </Tab>

  <Tab title="Docker">
    ```dockerfile
    # In your Dockerfile
    ENV HELIUS_API_KEY=""

    # Or use Docker secrets
    RUN --mount=type=secret,id=helius_key \
        cat /run/secrets/helius_key > /app/api_key.txt
    ```
  </Tab>
</Tabs>

## Rate Limits & Usage

<Note>
  Rate limits vary by subscription plan. Monitor your usage in the [Helius Dashboard](https://dashboard.helius.dev) to ensure you stay within your allocated limits.
</Note>

### Understanding Rate Limits

* **Requests per second**: Based on your subscription tier
* **Monthly request quota**: Total requests allowed per billing cycle
* **Burst allowance**: Short-term spikes above your base rate limit

### Rate Limit Headers

Helius includes rate limit information in response headers:

```http
X-RateLimit-Limit: 100
X-RateLimit-Remaining: 95
X-RateLimit-Reset: 1640995200
```

### Handling Rate Limits

<CodeGroup>
  ```javascript JavaScript
  async function makeRequest(url, data) {
    try {
      const response = await fetch(url, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data)
      });
      
      if (response.status === 429) {
        const retryAfter = response.headers.get('Retry-After');
        console.log(`Rate limited. Retry after ${retryAfter} seconds`);
        await new Promise(resolve => setTimeout(resolve, retryAfter * 1000));
        return makeRequest(url, data); // Retry
      }
      
      return response.json();
    } catch (error) {
      console.error('Request failed:', error);
      throw error;
    }
  }
  ```

  ```python Python
  import time
  import requests

  def make_request(url, data):
      try:
          response = requests.post(url, json=data)
          
          if response.status_code == 429:
              retry_after = int(response.headers.get('Retry-After', 60))
              print(f"Rate limited. Waiting {retry_after} seconds...")
              time.sleep(retry_after)
              return make_request(url, data)  # Retry
          
          response.raise_for_status()
          return response.json()
      except requests.exceptions.RequestException as e:
          print(f"Request failed: {e}")
          raise
  ```
</CodeGroup>

## Troubleshooting

<AccordionGroup>
  <Accordion title="Invalid API Key Error">
    **Symptoms**: 401 Unauthorized or "Invalid API Key" errors

    **Solutions**:

    * Verify your API key is correct and hasn't been regenerated
    * Check that you're including the API key as a query parameter: `?api-key=YOUR_KEY`
    * Ensure there are no extra spaces or characters in your API key
    * Confirm your API key hasn't expired or been revoked
  </Accordion>

  <Accordion title="Rate Limit Exceeded">
    **Symptoms**: 429 Too Many Requests errors

    **Solutions**:

    * Check your current usage in the dashboard
    * Implement exponential backoff in your retry logic
    * Consider upgrading your plan for higher limits
    * Optimize your requests to reduce unnecessary calls
  </Accordion>

  <Accordion title="Forbidden Access">
    **Symptoms**: 403 Forbidden errors

    **Solutions**:

    * Verify IP restrictions aren't blocking your requests
    * Check that your subscription includes access to the endpoint
    * Ensure your API key has the necessary permissions
  </Accordion>
</AccordionGroup>

## Next Steps

<CardGroup cols={2}>
  <Card title="Quickstart Guide" icon="rocket" href="/quickstart">
    Start making your first API calls with Helius
  </Card>

  <Card title="API Reference" icon="book" href="/api-reference">
    Explore all available endpoints and methods
  </Card>

  <Card title="Rate Limits & Billing" icon="credit-card" href="/billing/plans-and-rate-limits">
    Understand pricing and upgrade options
  </Card>

  <Card title="Dashboard" icon="chart-line" href="https://dashboard.helius.dev">
    Monitor your API usage and manage keys
  </Card>
</CardGroup>

## Support

Need help with authentication or have questions about API keys?

<CardGroup cols={2}>
  <Card title="Discord Community" icon="discord" href="https://discord.com/invite/6GXdee3gBj">
    Join our Discord for real-time help and community support
  </Card>

  <Card title="Email Support" icon="envelope" href="mailto:support@helius.xyz">
    Contact our support team directly
  </Card>
</CardGroup>


# Common Error Codes
Source: https://www.helius.dev/docs/api-reference/common-error-codes

Learn about common RPC error messages and potential solutions

When interacting with Helius RPC endpoints, you may encounter the following standard HTTP error codes that indicate the status of your requests:

<AccordionGroup>
  <Accordion title="401 - Unauthorized">
    <Warning>Invalid API key or restricted access due to Access Control Rules.</Warning>

    #### How to fix it

    1. Verify your API key is correctly formatted
    2. Check if your API key has the necessary permissions
    3. Ensure you're including the API key in the query params

    <Info>For more information on API authentication, see our [Authentication](/api-reference/authentication) page.</Info>
  </Accordion>

  <Accordion title="429 - Too Many Requests">
    <Warning>
      Exceeded Rate Limits.
    </Warning>

    #### How to fix it

    1. Check the `Rate Limited Requests` graph in your [RPC metrics dashboard](https://dashboard.helius.dev/usage)
    2. Optimize your code to reduce unnecessary API calls
    3. Implement rate limiting in your application
    4. Consider upgrading your plan for increased rate limits

    #### More information

    <Info>Review our [Plans & Rate Limits](/billing/plans-and-rate-limits) page for details on the limits for each plan.</Info>
  </Accordion>

  <Accordion title="500 - Internal Server Error">
    <Warning>
      A server-side error occurred while processing your request.
    </Warning>

    ### How to fix it

    1. Check if your request payload is properly formatted
    2. Check the [Helius Status Page](https://helius.statuspage.io/) for any ongoing issues
    3. If the error persists, contact Helius support with details of your request

    <Note>Server errors are typically temporary and not related to your implementation.</Note>
  </Accordion>

  <Accordion title="503 - Service Unavailable">
    <Warning>
      The server is temporarily overloaded or undergoing maintenance.
    </Warning>

    ### How to fix it

    1. Implement exponential backoff for retries in your application
    2. Wait for a few minutes before trying again
    3. Check the [Helius Status Page](https://helius.statuspage.io/) for any ongoing issues
    4. If the error persists, contact Helius support with details of your request

    <Tip>This error is usually temporary and resolves on its own as server load balances.</Tip>
  </Accordion>

  <Accordion title="504 - Gateway Timeout">
    <Warning>
      The server did not receive a timely response while acting as a gateway or proxy.
    </Warning>

    ### How to fix it

    1. Check your network connection
    2. Implement request timeouts in your client code
    3. Check the [Helius Status Page](https://helius.statuspage.io/) for any ongoing issues
    4. If the error persists, contact Helius support with details of your request

    <Note>This error often indicates network issues or that the server is processing a complex operation that exceeds the timeout limit.</Note>
  </Accordion>
</AccordionGroup>


# Digital Asset Standard (DAS)
Source: https://www.helius.dev/docs/api-reference/das

This page provides an overview of all available Digital Asset Standard (DAS) API endpoints for working with tokens, NFTs, and compressed NFTs on Solana.

<CardGroup cols={2}>
  <Card title="getAsset" href="/api-reference/das/getasset">
    Retrieves information about a specific asset by its ID.
  </Card>

  <Card title="getAssetBatch" href="/api-reference/das/getassetbatch">
    Retrieves information about multiple assets in a single request.
  </Card>

  <Card title="getAssetProof" href="/api-reference/das/getassetproof">
    Fetches a proof for a specific compressed asset.
  </Card>

  <Card title="getAssetProofBatch" href="/api-reference/das/getassetproofbatch">
    Fetches proofs for multiple compressed assets in a single request.
  </Card>

  <Card title="getAssetsByAuthority" href="/api-reference/das/getassetsbyauthority">
    Returns assets by the specified authority address.
  </Card>

  <Card title="getAssetsByCreator" href="/api-reference/das/getassetsbycreator">
    Retrieves assets created by a specific creator address.
  </Card>

  <Card title="getAssetsByGroup" href="/api-reference/das/getassetsbygroup">
    Returns assets that belong to a specific group.
  </Card>

  <Card title="getAssetsByOwner" href="/api-reference/das/getassetsbyowner">
    Lists all assets owned by a specific address.
  </Card>

  <Card title="getNftEditions" href="/api-reference/das/getnfteditions">
    Retrieves information about NFT editions.
  </Card>

  <Card title="getSignaturesForAsset" href="/api-reference/das/getsignaturesforasset">
    Returns transaction signatures involving a specific asset.
  </Card>

  <Card title="getTokenAccounts" href="/api-reference/das/gettokenaccounts">
    Retrieves token accounts based on specified parameters.
  </Card>

  <Card title="searchAssets" href="/api-reference/das/searchassets">
    Searches for assets based on various criteria.
  </Card>
</CardGroup>


# getAsset
Source: https://www.helius.dev/docs/api-reference/das/getasset

openapi/das-api/getAsset.yaml post /
Retrieve comprehensive data for any Solana NFT or digital asset by its unique identifier.
This endpoint provides complete on-chain and off-chain metadata, ownership details, royalty information,
collection data, and compression state for any Solana digital asset. The getAsset method supports all token standards 
including compressed NFTs (cNFTs), programmable NFTs (pNFTs), and traditional SPL tokens.

Use this endpoint to:
- Fetch complete metadata for NFT marketplace listings
- Retrieve asset ownership information for wallet integrations
- Access royalty and creator data for royalty enforcement
- Check compression status to identify cost-efficient compressed NFTs
- View collection grouping for NFT collection analytics




# getAssetBatch
Source: https://www.helius.dev/docs/api-reference/das/getassetbatch

openapi/das-api/getAssetBatch.yaml post /
Returns a batch of assets based on their IDs.



# getAssetProof
Source: https://www.helius.dev/docs/api-reference/das/getassetproof

openapi/das-api/getAssetProof.yaml post /
Retrieve the cryptographic merkle proof for a compressed Solana NFT or token.
This verification API returns the complete proof path required to validate a compressed
digital asset's existence and data integrity on the Solana blockchain without storing
the full asset data on-chain. Essential for marketplaces, wallets, and applications
that need to verify ownership and authenticity of compressed NFTs with the security
guarantees of traditional on-chain assets but at a fraction of the storage cost.




# getAssetProofBatch
Source: https://www.helius.dev/docs/api-reference/das/getassetproofbatch

openapi/das-api/getAssetProofBatch.yaml post /
Efficiently retrieve cryptographic merkle proofs for multiple compressed Solana NFTs in a single batch request.
This optimized verification API returns the complete proof paths required to validate multiple compressed
digital assets' existence and data integrity on the Solana blockchain without requiring separate API calls for each NFT.
Essential for high-performance applications like marketplaces, wallets, and gaming platforms that need to verify
ownership and authenticity of multiple compressed NFTs simultaneously with minimal latency and API usage.




# getAssetsByAuthority
Source: https://www.helius.dev/docs/api-reference/das/getassetsbyauthority

openapi/das-api/getAssetsByAuthority.yaml post /
Returns a list of assets owned by a given authority.



# getAssetsByCreator
Source: https://www.helius.dev/docs/api-reference/das/getassetsbycreator

openapi/das-api/getAssetsByCreator.yaml post /
Retrieve a comprehensive list of all Solana digital assets created by a specific wallet address.
This creator attribution API returns complete NFT collections, artwork, tokens, and other assets
where the specified address is listed as a creator, with verification status. Essential for artist
portfolios, creator royalty tracking, marketplace attribution, and collection discovery across 
the Solana ecosystem.




# getAssetsByGroup
Source: https://www.helius.dev/docs/api-reference/das/getassetsbygroup

openapi/das-api/getAssetsByGroup.yaml post /
Retrieve all Solana digital assets belonging to a specific collection or grouping.
This powerful collection browsing API returns a complete list of NFTs that share the same 
group designation (such as collection, community, or other grouping), with comprehensive 
metadata and ownership details for each asset. Essential for NFT marketplaces displaying 
collections, portfolio applications showing grouped assets, and analytics platforms tracking 
collection-wide metrics across the Solana ecosystem.




# getAssetsByOwner
Source: https://www.helius.dev/docs/api-reference/das/getassetsbyowner

openapi/das-api/getAssetsByOwner.yaml post /
Retrieve a comprehensive list of all digital assets owned by a specific Solana wallet address.
Access complete NFT collections, compressed assets, fungible tokens, and native SOL balances
with advanced filtering, sorting, and pagination options. Supports both traditional and compressed
NFTs with detailed metadata for complete wallet portfolio analysis.




# getNftEditions
Source: https://www.helius.dev/docs/api-reference/das/getnfteditions

openapi/das-api/getNftEditions.yaml post /
Retrieve all limited edition prints created from a master NFT on the Solana blockchain.
This specialized edition tracking API returns a complete list of all individual NFT editions
that have been minted from a specific master edition, along with their unique mint addresses, 
edition numbers, and current supply information. Essential for NFT platforms managing limited
edition artwork, collectors tracking edition rarity, and marketplaces verifying authentic prints
within the Solana NFT ecosystem.




# getSignaturesForAsset
Source: https://www.helius.dev/docs/api-reference/das/getsignaturesforasset

openapi/das-api/getSignaturesForAsset.yaml post /
Retrieve a complete chronological history of all transactions involving a specific Solana NFT or token.
This transaction history API returns an ordered list of transaction signatures and operation types
that affected a particular digital asset on the Solana blockchain, enabling applications to track
the full ownership history, creation events, transfers, listings, sales, and other operations.
Essential for marketplace provenance verification, wallet transaction history, and analytics 
platforms tracking the lifecycle of NFTs and tokens across the Solana ecosystem.




# getTokenAccounts
Source: https://www.helius.dev/docs/api-reference/das/gettokenaccounts

openapi/das-api/getTokenAccounts.yaml post /
Returns a list of token accounts for a given mint and owner.



# searchAssets
Source: https://www.helius.dev/docs/api-reference/das/searchassets

openapi/das-api/searchAssets.yaml post /
Search and discover Solana digital assets with comprehensive filtering options.
This powerful discovery API enables applications to find NFTs, compressed NFTs, fungible tokens,
and other digital assets using multiple criteria including ownership, creators, collections,
compression status, and metadata attributes. Perfect for marketplaces, portfolio
trackers, and analytics platforms needing advanced asset discovery capabilities
across the Solana ecosystem.

Key capabilities:
- Multi-criteria search across all Solana NFT standards (traditional, compressed, programmable)
- Collection-based filtering for NFT projects and communities
- Creator and ownership-based queries for attribution and portfolio analysis
- Compression status filtering to identify cost-efficient assets
- Metadata attribute search for trait-based discovery
- Complete pagination support for large result sets




# Solana RPC URLs and Endpoints
Source: https://www.helius.dev/docs/api-reference/endpoints

Helius provides multiple endpoint types to suit different application needs. This guide outlines all available connection options for interacting with the Helius API.

## Solana RPC endpoints

Standard, high-performance RPC endpoints providing full Solana API compatibility with enhanced reliability and throughput. These endpoints support all Solana JSON-RPC methods and now **use staked connections by default** for optimal transaction landing rates:

* **Mainnet**: `https://mainnet.helius-rpc.com/?api-key=YOUR_API_KEY`
* **Devnet**: `https://devnet.helius-rpc.com/?api-key=YOUR_API_KEY`

<Note>
  **Staked Transactions Are the New Default**

  Transactions sent through Helius will automatically use staked connections, providing you with the highest transaction landing rates and ensuring your transactions are optimized for speed and reliability. No code changes required.
</Note>

## Secure RPC endpoints

These URLs are specifically masked and IP rate-limited at 5 TPS, making them safe to use directly from frontend applications without exposing your API credits:

* **Mainnet**: `https://abc-456-fast-mainnet.helius-rpc.com`
* **Devnet**: `https://123-xyz-fast-devnet.helius-rpc.com`

## Staked Connection endpoints (Deprecated)

<Warning>
  **Deprecated**: The staked endpoint (`staked.helius-rpc.com`) has been deprecated. Use the regular endpoint instead (`mainnet.helius-rpc.com`) which now uses staked connections by default.
</Warning>

Staked connections are now the default for all transactions sent through Helius standard endpoints. This change provides:

* **Cost**: 10 credits per `sendTransaction` request (reduced from 50 credits)
* **Automatic optimization**: All transactions are sent over optimized network infrastructure (Asia, Europe, and North America)
* **Higher landing rates**: Guaranteed access to staked connections during market congestion
* **No code changes required**: Existing applications automatically benefit from staked connections

### Unstaked Connections

If you need to use unstaked connections (1 credit per call), you can use:

* **Mainnet**: `https://unstaked.helius-rpc.com/?api-key=YOUR_API_KEY`

<Warning>
  Unstaked connections will not be reliable during periods of network congestion. We recommend using the default staked connections for production applications.
</Warning>

## Solana Websocket Endpoints

Standard WebSocket endpoints that provide real-time data streaming according to the Solana WebSocket protocol. These endpoints support all standard Solana WebSocket subscription methods including account, program, signature, slot, and log subscriptions:

* **Mainnet**: `wss://mainnet.helius-rpc.com/?api-key=YOUR_API_KEY`
* **Devnet**: `wss://devnet.helius-rpc.com/?api-key=YOUR_API_KEY`

### Key Features

* **Supported subscriptions**: `accountSubscribe`, `programSubscribe`, `signatureSubscribe`, `slotSubscribe`, `logsSubscribe`, and more
* **Protocol compatibility**: Fully compatible with Solana's standard WebSocket API
* **Best for**: Applications that need to monitor account changes, track transaction confirmations, or receive real-time updates on blockchain activity
* **Connection management**: Implement periodic pings every 30-60 seconds to maintain active connections

## Geyser Enhanced Websocket Endpoints

Enhanced WebSockets offer faster response times than traditional RPC WebSockets and provide real-time transaction and account updates directly to your applications:

* **Mainnet**: `wss://atlas-mainnet.helius-rpc.com/?api-key=YOUR_API_KEY`
* **Devnet**: `wss://atlas-devnet.helius-rpc.com/?api-key=YOUR_API_KEY`

### Key Features

* **Available for**: Business and professional plans only (not the same as Yellowstone Geyser, which requires a Dedicated Node)
* **Subscription methods**: Supports `transactionSubscribe` and `accountSubscribe`
* **Connection management**: Websockets have a 10-minute inactivity timer; implement health checks and send pings every minute to keep connections alive
* **Current status**: In beta, occasionally may experience delayed data


# Enhanced Transactions API
Source: https://www.helius.dev/docs/api-reference/enhanced-transactions

This page provides an overview of all available Enhanced Transactions API endpoints for working with parsed and raw transaction data on Solana.

<CardGroup cols={2}>
  <Card title="Get Parsed Transactions" href="/api-reference/enhanced-transactions/gettransactions">
    Parses and returns enhanced, human-readable versions of the given transactions.
  </Card>

  <Card title="Get Parsed Transactions By Address" href="/api-reference/enhanced-transactions/gettransactionsbyaddress">
    Retrieves enhanced transaction history for a specific address.
  </Card>
</CardGroup>


# Get Enhanced Transactions
Source: https://www.helius.dev/docs/api-reference/enhanced-transactions/gettransactions

openapi/openapi-definition.yaml post /v0/transactions
Convert raw Solana transactions into enhanced, human-readable formats with
decoded instruction data and contextual information. Process multiple transactions
in a single request for efficient data analysis and display.




# Get Enhanced Transactions By Address
Source: https://www.helius.dev/docs/api-reference/enhanced-transactions/gettransactionsbyaddress

openapi/openapi-definition.yaml get /v0/addresses/{address}/transactions
Access comprehensive transaction history for any Solana address with human-readable 
decoded data. Filter by transaction types, sources, and time ranges to get detailed
insights into wallet activity with context and decoded instructions.




# LaserStream gRPC API
Source: https://www.helius.dev/docs/api-reference/laserstream-grpc

This page provides an overview of all available LaserStream gRPC API methods for working with real-time Solana blockchain data.

<CardGroup cols={2}>
  <Card title="Subscribe" href="/api-reference/laserstream/grpc/subscribe">
    Subscribe to accounts, transactions, blocks, and slot updates to receive real-time notifications.
  </Card>

  <Card title="Get Block Height" href="/api-reference/laserstream/grpc/getblockheight">
    Get the current block height of the Solana blockchain.
  </Card>

  <Card title="Get Latest Blockhash" href="/api-reference/laserstream/grpc/getlatestblockhash">
    Get the latest blockhash from the Solana blockchain.
  </Card>

  <Card title="Get Slot" href="/api-reference/laserstream/grpc/getslot">
    Get the current slot number from the Solana blockchain.
  </Card>

  <Card title="Get Version" href="/api-reference/laserstream/grpc/getversion">
    Get the version information of the LaserStream gRPC API and the Solana node it's connected to.
  </Card>

  <Card title="Is Blockhash Valid" href="/api-reference/laserstream/grpc/isblockhashvalid">
    Check if a blockhash is still valid on the Solana blockchain.
  </Card>

  <Card title="Ping" href="/api-reference/laserstream/grpc/ping">
    Check connectivity to the LaserStream gRPC API with a simple ping-pong mechanism.
  </Card>
</CardGroup>


# GetBlockHeight
Source: https://www.helius.dev/docs/api-reference/laserstream/grpc/getblockheight

Get the current block height of the Solana blockchain using the LaserStream gRPC API.

<hide>
  ## Endpoints

  gRPC services are available on mainnet and devnet with the following URLs:

  * **Mainnet** `https://laserstream-mainnet.helius-rpc.com:443`
  * **Devnet** `https://laserstream-devnet.helius-rpc.com:443`
</hide>

## Authorizations

<ParamField query="x-token" type="string" required>
  Your Helius API key. You can get one for free in the
  [dashboard](https://dashboard.helius.dev/api-keys).
</ParamField>

## Message

This method takes an empty request and returns the current block height.

<RequestExample>
  ```json Empty Request
  {}
  ```
</RequestExample>

## Response

<ResponseField name="blockHeight" type="integer">
  The current block height of the Solana blockchain.
</ResponseField>

<ResponseExample>
  ```json Block Height Response
  {
    "blockHeight": 189554321
  }
  ```
</ResponseExample>


# GetLatestBlockhash
Source: https://www.helius.dev/docs/api-reference/laserstream/grpc/getlatestblockhash

Get the latest blockhash from the Solana blockchain using the LaserStream gRPC API.

<hide>
  ## Endpoints

  gRPC services are available on mainnet and devnet with the following URLs:

  * **Mainnet** `https://laserstream-mainnet.helius-rpc.com:443`
  * **Devnet** `https://laserstream-devnet.helius-rpc.com:443`
</hide>

## Authorizations

<ParamField query="x-token" type="string" required>
  Your Helius API key. You can get one for free in the
  [dashboard](https://dashboard.helius.dev/api-keys).
</ParamField>

## Message

This method takes an empty request and returns the latest blockhash and its corresponding last valid block height.

<RequestExample>
  ```json Empty Request
  {}
  ```
</RequestExample>

## Response

<ResponseField name="slot" type="string">
  The current slot number.
</ResponseField>

<ResponseField name="blockhash" type="string">
  The latest blockhash as a base-58 encoded string.
</ResponseField>

<ResponseField name="last_valid_block_height" type="string">
  The last block height at which the returned blockhash will be valid.
</ResponseField>

<ResponseExample>
  ```json Latest Blockhash Response
  {
    "slot": "333390974",
    "blockhash": "CiqX6nU67eVCFqxh6TJ3LF8bDqjtnD2wULRMME917QSY",
    "last_valid_block_height": "311630163"
  }
  ```
</ResponseExample>


# GetSlot
Source: https://www.helius.dev/docs/api-reference/laserstream/grpc/getslot

Get the current slot number from the Solana blockchain using the LaserStream gRPC API.

<hide>
  ## Endpoints

  gRPC services are available on mainnet and devnet with the following URLs:

  * **Mainnet** `https://laserstream-mainnet.helius-rpc.com:443`
  * **Devnet** `https://laserstream-devnet.helius-rpc.com:443`
</hide>

## Authorizations

<ParamField query="x-token" type="string" required>
  Your Helius API key. You can get one for free in the
  [dashboard](https://dashboard.helius.dev/api-keys).
</ParamField>

## Message

This method takes an empty request and returns the current slot number.

<RequestExample>
  ```json Empty Request
  {}
  ```
</RequestExample>

## Response

<ResponseField name="slot" type="integer">
  The current slot number on the Solana blockchain.
</ResponseField>

<ResponseExample>
  ```json
  {
    "slot": "333391830"
  }
  ```
</ResponseExample>


# GetVersion
Source: https://www.helius.dev/docs/api-reference/laserstream/grpc/getversion

Get the version information of the LaserStream gRPC API and the Solana node it's connected to.

<hide>
  ## Endpoints

  gRPC services are available on mainnet and devnet with the following URLs:

  * **Mainnet** `https://laserstream-mainnet.helius-rpc.com:443`
  * **Devnet** `https://laserstream-devnet.helius-rpc.com:443`
</hide>

## Authorizations

<ParamField query="x-token" type="string" required>
  Your Helius API key. You can get one for free in the
  [dashboard](https://dashboard.helius.dev/api-keys).
</ParamField>

## Message

This method takes an empty request and returns version information.

## Response

<ResponseField name="version" type="string">
  A JSON string containing detailed version information with the following fields:
</ResponseField>

<ResponseField name="version.package" type="string">
  The package name.
</ResponseField>

<ResponseField name="version.version" type="string">
  The package version.
</ResponseField>

<ResponseField name="version.proto" type="string">
  The protocol version.
</ResponseField>

<ResponseField name="version.proto_richat" type="string">
  The Richat protocol version.
</ResponseField>

<ResponseField name="version.solana" type="string">
  The Solana version the service is using.
</ResponseField>

<ResponseField name="version.git" type="string">
  The Git commit hash of the build.
</ResponseField>

<ResponseField name="version.rustc" type="string">
  The Rust compiler version used to build the service.
</ResponseField>

<ResponseField name="version.buildts" type="string">
  The timestamp when the service was built.
</ResponseField>

<ResponseField name="extra.hostname" type="string">
  The hostname of the server handling the request.
</ResponseField>

<RequestExample>
  ```json Empty Request
  {}
  ```
</RequestExample>

<ResponseExample>
  ```json
  {
    "version": "{\"version\":{\"package\":\"richat\",\"version\":\"2.1.0\",\"proto\":\"4.2.1\",\"proto_richat\":\"2.0.0\",\"solana\":\"2.1.14\",\"git\":\"cf5f498fe\",\"rustc\":\"1.85.0\",\"buildts\":\"2025-04-11T17:12:50.779748607Z\"},\"extra\":{\"hostname\":\"laserstream-prod-mainnet-fra-worker-1\"}}"
  }
  ```
</ResponseExample>


# IsBlockhashValid
Source: https://www.helius.dev/docs/api-reference/laserstream/grpc/isblockhashvalid

Check if a blockhash is still valid on the Solana blockchain using the LaserStream gRPC API.

<hide>
  ## Endpoints

  gRPC services are available on mainnet and devnet with the following URLs:

  * **Mainnet** `https://laserstream-mainnet.helius-rpc.com:443`
  * **Devnet** `https://laserstream-devnet.helius-rpc.com:443`
</hide>

## Authorizations

<ParamField query="x-token" type="string" required>
  Your Helius API key. You can get one for free in the
  [dashboard](https://dashboard.helius.dev/api-keys).
</ParamField>

## Message

<ParamField body="blockhash" type="string" required>
  The blockhash to check as a base-58 encoded string.
</ParamField>

## Response

<ResponseField name="valid" type="boolean">
  Whether the blockhash is still valid (true) or expired (false).
</ResponseField>

<RequestExample>
  ```json Empty Request
  {}
  ```
</RequestExample>

<ResponseExample>
  ```json
  {
      "slot": "333440972",
      "valid": false
  }
  ```
</ResponseExample>


# Ping
Source: https://www.helius.dev/docs/api-reference/laserstream/grpc/ping

Check connectivity to the LaserStream gRPC API with a simple ping-pong mechanism.

<hide>
  ## Endpoints

  gRPC services are available on mainnet and devnet with the following URLs:

  * **Mainnet** `https://laserstream-mainnet.helius-rpc.com:443`
  * **Devnet** `https://laserstream-devnet.helius-rpc.com:443`
</hide>

## Authorizations

<ParamField query="x-token" type="string" required>
  Your Helius API key. You can get one for free in the
  [dashboard](https://dashboard.helius.dev/api-keys).
</ParamField>

## Message

This method takes an empty request and returns a simple pong response to confirm connectivity.

## Response

<ResponseField name="pong" type="boolean">
  Always returns true if the connection is successful.
</ResponseField>

<RequestExample>
  ```json Empty Request
  {}
  ```
</RequestExample>

<ResponseExample>
  ```json
  {
      "count": 0
  }
  ```
</ResponseExample>


# Subscribe
Source: https://www.helius.dev/docs/api-reference/laserstream/grpc/subscribe

Subscribe to accounts, transactions, blocks, and slot updates to receive real-time notifications using the high-performance gRPC API.

<hide>
  ## Endpoints

  gRPC services are available on mainnet and devnet with the following URLs:

  * **Mainnet** `https://laserstream-mainnet.helius-rpc.com:443`
  * **Devnet** `https://laserstream-devnet.helius-rpc.com:443`
</hide>

## Authorizations

<ParamField query="x-token" type="string" required>
  Your Helius API key. You can get one for free in the
  [dashboard](https://dashboard.helius.dev/api-keys).
</ParamField>

## Message

The gRPC API supports multiple subscription types that can be combined in a single request:

<ParamField body="accounts" type="object">
  Subscribe to account updates. Returns data when specified accounts are
  modified.

  <Expandable title="properties" defaultOpen>
    <ParamField body="account" type="array">
      Array of account pubkeys to monitor.
    </ParamField>

    <ParamField body="owner" type="array">
      Array of owner pubkeys to monitor (all accounts owned by these programs).
    </ParamField>

    <ParamField body="filters" type="object">
      Optional filters to apply.

      <Expandable title="filter options">
        <ParamField body="memcmp" type="object">
          Filter by specific bytes at an offset in account data.

          <Expandable title="properties">
            <ParamField body="offset" type="integer">
              Position in bytes to start comparing data.
            </ParamField>

            <ParamField body="bytes" type="string">
              The data to compare against (bytes format).
            </ParamField>

            <ParamField body="base58" type="string">
              The data to compare against (base58 format).
            </ParamField>

            <ParamField body="base64" type="string">
              The data to compare against (base64 format).
            </ParamField>
          </Expandable>
        </ParamField>

        <ParamField body="datasize" type="integer">
          Filter by exact account data size in bytes.
        </ParamField>

        <ParamField body="token_account_state" type="boolean">
          Filter to only token accounts.
        </ParamField>

        <ParamField body="lamports" type="object">
          Filter by SOL balance with comparisons.

          <Expandable title="comparison operators">
            <ParamField body="eq" type="integer">
              Equal to specified amount.
            </ParamField>

            <ParamField body="ne" type="integer">
              Not equal to specified amount.
            </ParamField>

            <ParamField body="lt" type="integer">
              Less than specified amount.
            </ParamField>

            <ParamField body="gt" type="integer">
              Greater than specified amount.
            </ParamField>
          </Expandable>
        </ParamField>
      </Expandable>
    </ParamField>

    <ParamField body="nonempty_txn_signature" type="boolean">
      Include transaction signatures when available.
    </ParamField>
  </Expandable>
</ParamField>

<ParamField body="slots" type="object">
  Subscribe to slot updates.

  <Expandable title="properties" defaultOpen>
    <ParamField body="filter_by_commitment" type="boolean">
      Filter slots by commitment level.
    </ParamField>

    <ParamField body="interslot_updates" type="boolean">
      Include intermediate slot status updates (PROCESSED, CONFIRMED, FINALIZED,
      FIRST\_SHRED\_RECEIVED, COMPLETED, CREATED\_BANK, DEAD).
    </ParamField>
  </Expandable>
</ParamField>

<ParamField body="transactions" type="object">
  Subscribe to transaction updates.

  <Expandable title="properties" defaultOpen>
    <ParamField body="vote" type="boolean">
      Include vote transactions.
    </ParamField>

    <ParamField body="failed" type="boolean">
      Include failed transactions.
    </ParamField>

    <ParamField body="signature" type="string">
      Monitor specific transaction signature.
    </ParamField>

    <ParamField body="account_include" type="array">
      Only include transactions affecting these accounts.
    </ParamField>

    <ParamField body="account_exclude" type="array">
      Exclude transactions affecting these accounts.
    </ParamField>

    <ParamField body="account_required" type="array">
      Transactions must affect all of these accounts.
    </ParamField>
  </Expandable>
</ParamField>

<ParamField body="transactions_status" type="object">
  Subscribe to transaction status updates.

  <Expandable title="properties" defaultOpen>
    <ParamField body="vote" type="boolean">
      Include vote transactions.
    </ParamField>

    <ParamField body="failed" type="boolean">
      Include failed transactions.
    </ParamField>

    <ParamField body="signature" type="string">
      Monitor specific transaction signature.
    </ParamField>

    <ParamField body="account_include" type="array">
      Only include transactions affecting these accounts.
    </ParamField>

    <ParamField body="account_exclude" type="array">
      Exclude transactions affecting these accounts.
    </ParamField>

    <ParamField body="account_required" type="array">
      Transactions must affect all of these accounts.
    </ParamField>
  </Expandable>
</ParamField>

<ParamField body="blocks" type="object">
  Subscribe to block updates.

  <Expandable title="properties" defaultOpen>
    <ParamField body="account_include" type="array">
      Only include blocks with transactions affecting these accounts.
    </ParamField>

    <ParamField body="include_transactions" type="boolean">
      Include full transaction details.
    </ParamField>

    <ParamField body="include_accounts" type="boolean">
      Include account updates.
    </ParamField>

    <ParamField body="include_entries" type="boolean">
      Include block entries.
    </ParamField>
  </Expandable>
</ParamField>

<ParamField body="blocks_meta" type="object">
  Subscribe to block metadata updates (lighter than full block updates).

  <Expandable title="returns" defaultOpen>
    <ParamField body="slot" type="integer">
      Slot number.
    </ParamField>

    <ParamField body="blockhash" type="string">
      Blockhash.
    </ParamField>

    <ParamField body="rewards" type="array">
      Rewards information.
    </ParamField>

    <ParamField body="block_time" type="integer">
      Block time.
    </ParamField>

    <ParamField body="block_height" type="integer">
      Block height.
    </ParamField>

    <ParamField body="parent_slot" type="integer">
      Parent slot.
    </ParamField>

    <ParamField body="parent_blockhash" type="string">
      Parent blockhash.
    </ParamField>

    <ParamField body="executed_transaction_count" type="integer">
      Transaction count.
    </ParamField>

    <ParamField body="entries_count" type="integer">
      Entry count.
    </ParamField>
  </Expandable>
</ParamField>

<ParamField body="entry" type="object">
  Subscribe to entry updates.

  <Expandable title="returns" defaultOpen>
    <ParamField body="slot" type="integer">
      Slot number.
    </ParamField>

    <ParamField body="index" type="integer">
      Entry index.
    </ParamField>

    <ParamField body="num_hashes" type="integer">
      Number of hashes.
    </ParamField>

    <ParamField body="hash" type="string">
      Hash.
    </ParamField>

    <ParamField body="executed_transaction_count" type="integer">
      Transaction count.
    </ParamField>

    <ParamField body="starting_transaction_index" type="integer">
      Starting transaction index.
    </ParamField>
  </Expandable>
</ParamField>

<ParamField body="commitment" type="enum">
  The commitment level for the subscription:

  <Expandable title="levels" defaultOpen>
    <ParamField body="PROCESSED" type="integer">
      (0): Processed by the current node.
    </ParamField>

    <ParamField body="CONFIRMED" type="integer">
      (1): Confirmed by supermajority of the cluster.
    </ParamField>

    <ParamField body="FINALIZED" type="integer">
      (2): Finalized by the cluster.
    </ParamField>
  </Expandable>
</ParamField>

<ParamField body="accounts_data_slice" type="array">
  Specifies partial account data to receive:

  <Expandable title="properties" defaultOpen>
    <ParamField body="offset" type="integer">
      Position in bytes to start reading data.
    </ParamField>

    <ParamField body="length" type="integer">
      Number of bytes to read.
    </ParamField>
  </Expandable>
</ParamField>

<ParamField body="ping" type="object">
  Enable ping-pong messages for connection health monitoring.

  <Expandable title="properties" defaultOpen>
    <ParamField body="id" type="integer">
      Numeric identifier for the ping.
    </ParamField>
  </Expandable>
</ParamField>

<ParamField body="from_slot" type="integer">
  Starting slot to receive updates from. Updates for slots before this value
  will be excluded.
</ParamField>

<RequestExample>
  ```json Accounts Subscription
  {
    "slots": {
        "slots": {}
    },
    "accounts": {
        "user-defined-label": {
            "account": [
                "DjUF9ASpyMbVpGJmTvzfSbCgUWj6JowwLh8dGAJzSPmu",
                "5U3bH5b6XtG99aVCE9ycvDgBKQx3fVT8WwTNbMToFuEr"
            ],
            "owner": [
                "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"
            ],
            "filter": {
                "memcmp": {
                    "offset": 0,
                    "bytes": "0102030405"
                },
                "datasize": 165,
                "token_account_state": true,
                "lamports": {
                    "gt": 100000000
                }
            },
            "nonempty_txn_signature": true
        }
    },
    "transactions": {},
    "blocks": {},
    "blocks_meta": {},
    "accounts_data_slice": [],
    "commitment": 1
  }
  ```

  ```json Slots Subscription
  {
    "slots": {
      "incoming_slots": {}
    },
    "commitment": 1
  }
  ```

  ```json Transactions Subscription
  {
    "transactions": {
      "vote": false,
      "failed": true,
      "signature": "4RPMxKBhCBubFmZ1r9BC52ztjG3qBTW9Gp1PXfufUSATQaLKTW3Dj6vQBYyVrhfjgJ4PjZLzwYs4Z92KDCPw8Qym",
      "account_include": ["DjUF9ASpyMbVpGJmTvzfSbCgUWj6JowwLh8dGAJzSPmu"],
      "account_exclude": ["TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"],
      "account_required": ["11111111111111111111111111111111"]
    },
    "commitment": 2
  }
  ```

  ```json Transaction Status Subscription
  {
    "transactions_status": {
      "vote": false,
      "failed": true,
      "account_include": ["DjUF9ASpyMbVpGJmTvzfSbCgUWj6JowwLh8dGAJzSPmu"],
      "account_exclude": ["TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"],
      "account_required": ["11111111111111111111111111111111"]
    },
    "commitment": 2
  }
  ```

  ```json Blocks Subscription
  {
    "blocks": {
      "account_include": ["DjUF9ASpyMbVpGJmTvzfSbCgUWj6JowwLh8dGAJzSPmu"],
      "include_transactions": 1,
      "include_accounts": 1,
      "include_entries": 0
    },
    "commitment": 2
  }
  ```

  ```json Block Metadata Subscription
  {
    "blocks_meta": {},
    "commitment": 2,
    "from_slot": 139000000
  }
  ```

  ```json Entry Subscription
  {
    "entry": {},
    "commitment": 1
  }
  ```

  ```json Partial Account Data Subscription
  {
    "accounts": {
      "account": ["DjUF9ASpyMbVpGJmTvzfSbCgUWj6JowwLh8dGAJzSPmu"]
    },
    "accounts_data_slice": [
      {
        "offset": 0,
        "length": 64
      },
      {
        "offset": 128,
        "length": 32
      }
    ],
    "commitment": 2
  }
  ```

  ```json Ping Subscription
  {
    "ping": {
      "id": 1
    }
  }
  ```

  ```json Combined Subscription
  {
    "accounts": {
      "account": ["DjUF9ASpyMbVpGJmTvzfSbCgUWj6JowwLh8dGAJzSPmu"],
      "nonempty_txn_signature": true
    },
    "slots": {
      "filter_by_commitment": 1,
      "interslot_updates": 1
    },
    "commitment": 2,
    "from_slot": 139000000,
    "ping": {
      "id": 123
    }
  }
  ```
</RequestExample>

## Commitment Levels

All subscriptions support the following commitment levels:

* `PROCESSED`: Processed by the current node (0)
* `CONFIRMED`: Confirmed by supermajority of the cluster (1)
* `FINALIZED`: Finalized by the cluster (2)

## Response Structure

Subscription responses include:

* `filters`: The filter names that matched this update
* One of the following update types:
  * `account`: Account data, owner, lamports, executable status, etc.
  * `slot`: Slot information and status updates
  * `transaction`: Full transaction details, signature, and metadata
  * `transaction_status`: Transaction execution status (success/error)
  * `block`: Complete block data with transactions, accounts, rewards, etc.
  * `block_meta`: Lightweight block metadata without full transaction details
  * `entry`: Entry details within a block
  * `ping`/`pong`: Connection health check messages
* `created_at`: Timestamp when the update was created

<ResponseExample>
  ```json Account Update
  {
    "filters": ["accounts"],
    "account": {
      "account": {
        "pubkey": "BASE58_ENCODED_PUBKEY",
        "lamports": 12345678,
        "owner": "BASE58_ENCODED_OWNER",
        "executable": false,
        "rent_epoch": 361,
        "data": "BASE64_ENCODED_DATA",
        "write_version": 123,
        "txn_signature": "BASE58_ENCODED_SIGNATURE"
      },
      "slot": 189554321,
      "is_startup": false
    },
    "created_at": "2023-04-28T12:34:56.789Z"
  }
  ```

  ```json Slot Update
  {
    "filters": ["slots"],
    "slot": {
      "slot": 189554321,
      "parent": 189554320,
      "status": 2,
      "dead_error": null
    },
    "created_at": "2023-04-28T12:34:56.789Z"
  }
  ```

  ```json Transaction Update
  {
    "filters": ["transactions"],
    "transaction": {
      "transaction": {
        "signature": "BASE58_ENCODED_SIGNATURE",
        "is_vote": false,
        "transaction": {
          "signatures": ["BASE58_ENCODED_SIGNATURE"],
          "message": {
            "header": {
              "num_required_signatures": 1,
              "num_readonly_signed_accounts": 0,
              "num_readonly_unsigned_accounts": 1
            },
            "account_keys": ["BASE58_ENCODED_PUBKEY1", "BASE58_ENCODED_PUBKEY2"],
            "recent_blockhash": "BASE58_ENCODED_BLOCKHASH",
            "instructions": [
              {
                "program_id_index": 1,
                "accounts": [0],
                "data": "BASE64_ENCODED_INSTRUCTION_DATA"
              }
            ]
          }
        },
        "meta": {
          "err": null,
          "fee": 5000,
          "pre_balances": [10000000, 1],
          "post_balances": [9995000, 1],
          "pre_token_balances": [],
          "post_token_balances": [],
          "log_messages": ["Program log: Instruction executed"],
          "rewards": []
        },
        "index": 2
      },
      "slot": 189554321
    },
    "created_at": "2023-04-28T12:34:56.789Z"
  }
  ```

  ```json Block Metadata Update
  {
    "filters": ["blocks_meta"],
    "block_meta": {
      "slot": 189554321,
      "blockhash": "BASE58_ENCODED_BLOCKHASH",
      "rewards": [
        {
          "pubkey": "BASE58_ENCODED_PUBKEY",
          "lamports": 1785000,
          "post_balance": 48589432109,
          "reward_type": 0,
          "commission": 10
        }
      ],
      "block_time": 1682684096,
      "block_height": 185432109,
      "parent_slot": 189554320,
      "parent_blockhash": "BASE58_ENCODED_PARENT_BLOCKHASH",
      "executed_transaction_count": 2576,
      "entries_count": 16
    },
    "created_at": "2023-04-28T12:34:56.789Z"
  }
  ```

  ```json Entry Update
  {
    "filters": ["entry"],
    "entry": {
      "slot": 189554321,
      "index": 5,
      "num_hashes": 8765432,
      "hash": "BASE58_ENCODED_HASH",
      "executed_transaction_count": 128,
      "starting_transaction_index": 1024
    },
    "created_at": "2023-04-28T12:34:56.789Z"
  }
  ```

  ```json Pong Response
  {
    "filters": [],
    "pong": {
      "id": 1
    },
    "created_at": "2023-04-28T12:34:56.789Z"
  }
  ```
</ResponseExample>


# mintCompressedNft (deprecated)
Source: https://www.helius.dev/docs/api-reference/mint/mintcompressednft

openapi/mint-api/mintCompressedNft.yaml post /



# getPriorityFeeEstimate
Source: https://www.helius.dev/docs/api-reference/priority-fee/getpriorityfeeestimate

openapi/priority-fee-api/getPriorityFeeEstimate.yaml post /
Calculate optimal priority fee recommendations for Solana transactions based on real-time 
network conditions. This advanced API analyzes historical fee data and current congestion 
levels to provide precise fee estimates for different priority levels.




# HTTP RPC Methods
Source: https://www.helius.dev/docs/api-reference/rpc/http-methods

This page provides an overview of all available HTTP RPC methods that can be used to interact with the API.

## Account Information

<CardGroup cols={2}>
  <Card title="getAccountInfo" href="/api-reference/rpc/http/getaccountinfo">
    Retrieves information about an account from the blockchain.
  </Card>

  <Card title="getMultipleAccounts" href="/api-reference/rpc/http/getmultipleaccounts">
    Retrieves information about multiple accounts in a single request.
  </Card>

  <Card title="getProgramAccounts" href="/api-reference/rpc/http/getprogramaccounts">
    Returns all accounts owned by a specific program.
  </Card>

  <Card title="getBalance" href="/api-reference/rpc/http/getbalance">
    Returns the balance of an account at the current time.
  </Card>

  <Card title="getMinimumBalanceForRentExemption" href="/api-reference/rpc/http/getminimumbalanceforrentexemption">
    Returns the minimum balance required to make an account rent exempt.
  </Card>

  <Card title="getLargestAccounts" href="/api-reference/rpc/http/getlargestaccounts">
    Returns the accounts with the largest balances.
  </Card>
</CardGroup>

## Block Information

<CardGroup cols={2}>
  <Card title="getBlock" href="/api-reference/rpc/http/getblock">
    Returns identity and transaction information about a confirmed block.
  </Card>

  <Card title="getBlocks" href="/api-reference/rpc/http/getblocks">
    Returns a list of confirmed blocks between two slots.
  </Card>

  <Card title="getBlocksWithLimit" href="/api-reference/rpc/http/getblockswithlimit">
    Returns a list of confirmed blocks starting at a given slot with a limit.
  </Card>

  <Card title="getBlockHeight" href="/api-reference/rpc/http/getblockheight">
    Returns the current block height of the node.
  </Card>

  <Card title="getBlockTime" href="/api-reference/rpc/http/getblocktime">
    Returns the estimated production time of a block.
  </Card>

  <Card title="getBlockCommitment" href="/api-reference/rpc/http/getblockcommitment">
    Returns commitment information for a block.
  </Card>

  <Card title="getBlockProduction" href="/api-reference/rpc/http/getblockproduction">
    Returns recent block production information.
  </Card>

  <Card title="getLatestBlockhash" href="/api-reference/rpc/http/getlatestblockhash">
    Returns the latest blockhash.
  </Card>

  <Card title="isBlockhashValid" href="/api-reference/rpc/http/isblockhashvalid">
    Returns whether a blockhash is still valid or not.
  </Card>
</CardGroup>

## Transaction Information

<CardGroup cols={2}>
  <Card title="getTransaction" href="/api-reference/rpc/http/gettransaction">
    Returns transaction details for a confirmed transaction.
  </Card>

  <Card title="getTransactionCount" href="/api-reference/rpc/http/gettransactioncount">
    Returns the current Transaction count from the ledger.
  </Card>

  <Card title="getSignaturesForAddress" href="/api-reference/rpc/http/getsignaturesforaddress">
    Returns signatures for confirmed transactions that include the given address.
  </Card>

  <Card title="getSignatureStatuses" href="/api-reference/rpc/http/getsignaturestatuses">
    Returns the statuses of a list of signatures.
  </Card>

  <Card title="getFeeForMessage" href="/api-reference/rpc/http/getfeeformessage">
    Returns the fee for a message.
  </Card>
</CardGroup>

## Token Information

<CardGroup cols={2}>
  <Card title="getTokenAccountBalance" href="/api-reference/rpc/http/gettokenaccountbalance">
    Returns the token balance of an account.
  </Card>

  <Card title="getTokenAccountsByOwner" href="/api-reference/rpc/http/gettokenaccountsbyowner">
    Returns all token accounts owned by the specified address.
  </Card>

  <Card title="getTokenAccountsByDelegate" href="/api-reference/rpc/http/gettokenaccountsbydelegate">
    Returns all token accounts that delegate to the specified address.
  </Card>

  <Card title="getTokenLargestAccounts" href="/api-reference/rpc/http/gettokenlargestaccounts">
    Returns the largest accounts for a specific token.
  </Card>

  <Card title="getTokenSupply" href="/api-reference/rpc/http/gettokensupply">
    Returns the total supply of a token.
  </Card>
</CardGroup>

## Slot Information

<CardGroup cols={2}>
  <Card title="getSlot" href="/api-reference/rpc/http/getslot">
    Returns the current slot that the node is processing.
  </Card>

  <Card title="getSlotLeader" href="/api-reference/rpc/http/getslotleader">
    Returns the identity of the current slot leader.
  </Card>

  <Card title="getSlotLeaders" href="/api-reference/rpc/http/getslotleaders">
    Returns the slot leaders for a slot range.
  </Card>

  <Card title="getMinimumLedgerSlot" href="/api-reference/rpc/http/minimumledgerslot">
    Returns the lowest slot that the node has information about.
  </Card>

  <Card title="getMaxRetransmitSlot" href="/api-reference/rpc/http/getmaxretransmitslot">
    Returns the maximum slot seen from retransmit stage.
  </Card>

  <Card title="getMaxShredInsertSlot" href="/api-reference/rpc/http/getmaxshredinsertslot">
    Returns the maximum slot seen from shred insert.
  </Card>

  <Card title="getHighestSnapshotSlot" href="/api-reference/rpc/http/gethighestsnapshotslot">
    Returns the highest available snapshot slot.
  </Card>
</CardGroup>

## Epoch Information

<CardGroup cols={2}>
  <Card title="getEpochInfo" href="/api-reference/rpc/http/getepochinfo">
    Returns information about the current epoch.
  </Card>

  <Card title="getEpochSchedule" href="/api-reference/rpc/http/getepochschedule">
    Returns epoch schedule information.
  </Card>

  <Card title="getLeaderSchedule" href="/api-reference/rpc/http/getleaderschedule">
    Returns the leader schedule for an epoch.
  </Card>
</CardGroup>

## Inflation & Rewards

<CardGroup cols={2}>
  <Card title="getInflationGovernor" href="/api-reference/rpc/http/getinflationgovernor">
    Returns the current inflation governor parameters.
  </Card>

  <Card title="getInflationRate" href="/api-reference/rpc/http/getinflationrate">
    Returns the specific inflation values for the current epoch.
  </Card>

  <Card title="getInflationReward" href="/api-reference/rpc/http/getinflationreward">
    Returns the inflation reward for a list of addresses for an epoch.
  </Card>
</CardGroup>

## System Information

<CardGroup cols={2}>
  <Card title="getHealth" href="/api-reference/rpc/http/gethealth">
    Returns the current health status of the node.
  </Card>

  <Card title="getIdentity" href="/api-reference/rpc/http/getidentity">
    Returns the identity pubkey for the current node.
  </Card>

  <Card title="getVersion" href="/api-reference/rpc/http/getversion">
    Returns the current software version running on the node.
  </Card>

  <Card title="getClusterNodes" href="/api-reference/rpc/http/getclusternodes">
    Returns information about all the nodes in the cluster.
  </Card>

  <Card title="getGenesisHash" href="/api-reference/rpc/http/getgenesishash">
    Returns the genesis hash.
  </Card>

  <Card title="getFirstAvailableBlock" href="/api-reference/rpc/http/getfirstavailableblock">
    Returns the lowest slot that the node has information about.
  </Card>

  <Card title="getRecentPerformanceSamples" href="/api-reference/rpc/http/getrecentperformancesamples">
    Returns a list of recent performance samples.
  </Card>

  <Card title="getRecentPrioritizationFees" href="/api-reference/rpc/http/getrecentprioritizationfees">
    Returns recent block hash fee information.
  </Card>

  <Card title="getVoteAccounts" href="/api-reference/rpc/http/getvoteaccounts">
    Returns the current vote accounts.
  </Card>

  <Card title="getSupply" href="/api-reference/rpc/http/getsupply">
    Returns information about the current supply.
  </Card>
</CardGroup>

## Stake Information

<CardGroup cols={2}>
  <Card title="getStakeMinimumDelegation" href="/api-reference/rpc/http/getstakeminimumdelegation">
    Returns the minimum delegation required for staking.
  </Card>
</CardGroup>

## Transaction Submission

<CardGroup cols={2}>
  <Card title="sendTransaction" href="/api-reference/rpc/http/sendtransaction">
    Submits a signed transaction to the cluster for processing.
  </Card>

  <Card title="simulateTransaction" href="/api-reference/rpc/http/simulatetransaction">
    Simulates the execution of a transaction.
  </Card>

  <Card title="requestAirdrop" href="/api-reference/rpc/http/requestairdrop">
    Requests an airdrop of lamports to a Pubkey.
  </Card>
</CardGroup>


# getAccountInfo
Source: https://www.helius.dev/docs/api-reference/rpc/http/getaccountinfo

openapi/rpc-http/getAccountInfo.yaml post /
Returns all information associated with the account of provided Pubkey.



# getBalance
Source: https://www.helius.dev/docs/api-reference/rpc/http/getbalance

openapi/rpc-http/getBalance.yaml post /
Returns the lamport balance of the account of provided Pubkey.



# getBlock
Source: https://www.helius.dev/docs/api-reference/rpc/http/getblock

openapi/rpc-http/getBlock.yaml post /
Returns identity and transaction information about a confirmed block in the ledger.



# getBlockCommitment
Source: https://www.helius.dev/docs/api-reference/rpc/http/getblockcommitment

openapi/rpc-http/getBlockCommitment.yaml post /
Returns commitment for particular block.



# getBlockHeight
Source: https://www.helius.dev/docs/api-reference/rpc/http/getblockheight

openapi/rpc-http/getBlockHeight.yaml post /
Returns the current block height of the node.



# getBlockProduction
Source: https://www.helius.dev/docs/api-reference/rpc/http/getblockproduction

openapi/rpc-http/getBlockProduction.yaml post /
Returns recent block production information from the current or previous epoch.



# getBlocks
Source: https://www.helius.dev/docs/api-reference/rpc/http/getblocks

openapi/rpc-http/getBlocks.yaml post /
Returns a list of confirmed blocks between two slots.



# getBlocksWithLimit
Source: https://www.helius.dev/docs/api-reference/rpc/http/getblockswithlimit

openapi/rpc-http/getBlocksWithLimit.yaml post /
Returns a list of confirmed blocks starting at the given slot.



# getBlockTime
Source: https://www.helius.dev/docs/api-reference/rpc/http/getblocktime

openapi/rpc-http/getBlockTime.yaml post /
Returns the estimated production time of a block.



# getClusterNodes
Source: https://www.helius.dev/docs/api-reference/rpc/http/getclusternodes

openapi/rpc-http/getClusterNodes.yaml post /
Returns information about all the nodes participating in the cluster.



# getEpochInfo
Source: https://www.helius.dev/docs/api-reference/rpc/http/getepochinfo

openapi/rpc-http/getEpochInfo.yaml post /
Returns information about the current epoch.



# getEpochSchedule
Source: https://www.helius.dev/docs/api-reference/rpc/http/getepochschedule

openapi/rpc-http/getEpochSchedule.yaml post /
Returns the epoch schedule information from this cluster's genesis config.



# getFeeForMessage
Source: https://www.helius.dev/docs/api-reference/rpc/http/getfeeformessage

openapi/rpc-http/getFeeForMessage.yaml post /
Get the fee the network will charge for a particular Message.



# getFirstAvailableBlock
Source: https://www.helius.dev/docs/api-reference/rpc/http/getfirstavailableblock

openapi/rpc-http/getFirstAvailableBlock.yaml post /
Returns the slot of the lowest confirmed block that has not been purged from the ledger.



# getGenesisHash
Source: https://www.helius.dev/docs/api-reference/rpc/http/getgenesishash

openapi/rpc-http/getGenesisHash.yaml post /
Returns the genesis hash.



# getHealth
Source: https://www.helius.dev/docs/api-reference/rpc/http/gethealth

openapi/rpc-http/getHealth.yaml post /
Returns the current health of the node. A healthy node is one that is within `HEALTH_CHECK_SLOT_DISTANCE` slots of the latest cluster confirmed slot.



# getHighestSnapshotSlot
Source: https://www.helius.dev/docs/api-reference/rpc/http/gethighestsnapshotslot

openapi/rpc-http/getHighestSnapshotSlot.yaml post /
Returns the highest slot information that the node has snapshots for.

This will find the highest full snapshot slot, and the highest incremental snapshot slot based on the full snapshot slot, if there is one.


# getIdentity
Source: https://www.helius.dev/docs/api-reference/rpc/http/getidentity

openapi/rpc-http/getIdentity.yaml post /
Returns the identity pubkey for the current node.



# getInflationGovernor
Source: https://www.helius.dev/docs/api-reference/rpc/http/getinflationgovernor

openapi/rpc-http/getInflationGovernor.yaml post /
Returns the current inflation governor.



# getInflationRate
Source: https://www.helius.dev/docs/api-reference/rpc/http/getinflationrate

openapi/rpc-http/getInflationRate.yaml post /
Returns the specific inflation values for the current epoch.



# getInflationReward
Source: https://www.helius.dev/docs/api-reference/rpc/http/getinflationreward

openapi/rpc-http/getInflationReward.yaml post /
Returns the inflation / staking reward for a list of addresses for an epoch.



# getLargestAccounts
Source: https://www.helius.dev/docs/api-reference/rpc/http/getlargestaccounts

openapi/rpc-http/getLargestAccounts.yaml post /
Returns the 20 largest accounts, by lamport balance (results may be cached up to two hours).



# getLatestBlockhash
Source: https://www.helius.dev/docs/api-reference/rpc/http/getlatestblockhash

openapi/rpc-http/getLatestBlockhash.yaml post /
Returns the latest blockhash.



# getLeaderSchedule
Source: https://www.helius.dev/docs/api-reference/rpc/http/getleaderschedule

openapi/rpc-http/getLeaderSchedule.yaml post /
Returns the leader schedule for an epoch.



# getMaxRetransmitSlot
Source: https://www.helius.dev/docs/api-reference/rpc/http/getmaxretransmitslot

openapi/rpc-http/getMaxRetransmitSlot.yaml post /
Get the max slot seen from retransmit stage.



# getMaxShredInsertSlot
Source: https://www.helius.dev/docs/api-reference/rpc/http/getmaxshredinsertslot

openapi/rpc-http/getMaxShredInsertSlot.yaml post /
Get the max slot seen from after shred insert..



# getMinimumBalanceForRentExemption
Source: https://www.helius.dev/docs/api-reference/rpc/http/getminimumbalanceforrentexemption

openapi/rpc-http/getMinimumBalanceForRentExemption.yaml post /
Returns minimum balance required to make account rent exempt.



# getMultipleAccounts
Source: https://www.helius.dev/docs/api-reference/rpc/http/getmultipleaccounts

openapi/rpc-http/getMultipleAccounts.yaml post /
Returns the account information for a list of Pubkeys.



# getProgramAccounts
Source: https://www.helius.dev/docs/api-reference/rpc/http/getprogramaccounts

openapi/rpc-http/getProgramAccounts.yaml post /
Returns all accounts owned by the provided program Pubkey.



# getRecentPerformanceSamples
Source: https://www.helius.dev/docs/api-reference/rpc/http/getrecentperformancesamples

openapi/rpc-http/getRecentPerformanceSamples.yaml post /
Returns a list of recent performance samples, in reverse slot order. Performance samples are taken every 60 seconds and include the number of transactions and slots that occur in a given time window..



# getRecentPrioritizationFees
Source: https://www.helius.dev/docs/api-reference/rpc/http/getrecentprioritizationfees

openapi/rpc-http/getRecentPrioritizationFees.yaml post /
Returns a list of prioritization fees from recent blocks.



# getSignaturesForAddress
Source: https://www.helius.dev/docs/api-reference/rpc/http/getsignaturesforaddress

openapi/rpc-http/getSignaturesForAddress.yaml post /
Returns signatures for confirmed transactions that include the given address in their `accountKeys` list. Returns signatures backwards in time from the provided signature or most recent confirmed block



# getSignatureStatuses
Source: https://www.helius.dev/docs/api-reference/rpc/http/getsignaturestatuses

openapi/rpc-http/getSignatureStatuses.yaml post /
Returns the statuses of a list of signatures. Each signature must be a txid, the first signature of a transaction.



# getSlot
Source: https://www.helius.dev/docs/api-reference/rpc/http/getslot

openapi/rpc-http/getSlot.yaml post /
Returns the slot that has reached the given or default commitment level.



# getSlotLeader
Source: https://www.helius.dev/docs/api-reference/rpc/http/getslotleader

openapi/rpc-http/getSlotLeader.yaml post /
Returns the current slot leader.



# getSlotLeaders
Source: https://www.helius.dev/docs/api-reference/rpc/http/getslotleaders

openapi/rpc-http/getSlotLeaders.yaml post /
Returns the slot leaders for a given slot range.



# getStakeMinimumDelegation
Source: https://www.helius.dev/docs/api-reference/rpc/http/getstakeminimumdelegation

openapi/rpc-http/getStakeMinimumDelegation.yaml post /
Returns the stake minimum delegation, in lamports.



# getSupply
Source: https://www.helius.dev/docs/api-reference/rpc/http/getsupply

openapi/rpc-http/getSupply.yaml post /
Returns information about the current supply.



# getTokenAccountBalance
Source: https://www.helius.dev/docs/api-reference/rpc/http/gettokenaccountbalance

openapi/rpc-http/getTokenAccountBalance.yaml post /
Returns the token balance of an SPL Token account.



# getTokenAccountsByDelegate
Source: https://www.helius.dev/docs/api-reference/rpc/http/gettokenaccountsbydelegate

openapi/rpc-http/getTokenAccountsByDelegate.yaml post /
Returns all SPL Token accounts by approved Delegate.



# getTokenAccountsByOwner
Source: https://www.helius.dev/docs/api-reference/rpc/http/gettokenaccountsbyowner

openapi/rpc-http/getTokenAccountsByOwner.yaml post /
Returns all SPL Token accounts by token owner.



# getTokenLargestAccounts
Source: https://www.helius.dev/docs/api-reference/rpc/http/gettokenlargestaccounts

openapi/rpc-http/getTokenLargestAccounts.yaml post /
Returns the 20 largest accounts of a particular SPL Token type.



# getTokenSupply
Source: https://www.helius.dev/docs/api-reference/rpc/http/gettokensupply

openapi/rpc-http/getTokenSupply.yaml post /
Returns the total supply of an SPL Token type.



# getTransaction
Source: https://www.helius.dev/docs/api-reference/rpc/http/gettransaction

openapi/rpc-http/getTransaction.yaml post /
Returns transaction details for a confirmed transaction.



# getTransactionCount
Source: https://www.helius.dev/docs/api-reference/rpc/http/gettransactioncount

openapi/rpc-http/getTransactionCount.yaml post /
Returns the current Transaction count from the ledger.



# getVersion
Source: https://www.helius.dev/docs/api-reference/rpc/http/getversion

openapi/rpc-http/getVersion.yaml post /
Returns the current Solana version running on the node.



# getVoteAccounts
Source: https://www.helius.dev/docs/api-reference/rpc/http/getvoteaccounts

openapi/rpc-http/getVoteAccounts.yaml post /
Returns the account info and associated stake for all the voting accounts in the current bank.



# isBlockhashValid
Source: https://www.helius.dev/docs/api-reference/rpc/http/isblockhashvalid

openapi/rpc-http/isBlockhashValid.yaml post /
Returns whether a blockhash is still valid or not.



# minimumLedgerSlot
Source: https://www.helius.dev/docs/api-reference/rpc/http/minimumledgerslot

openapi/rpc-http/minimumLedgerSlot.yaml post /
Returns the lowest slot that the node has information about in its ledger.



# requestAirdrop
Source: https://www.helius.dev/docs/api-reference/rpc/http/requestairdrop

openapi/rpc-http/requestAirdrop.yaml post /
Requests an airdrop of lamports to a Pubkey.



# sendTransaction
Source: https://www.helius.dev/docs/api-reference/rpc/http/sendtransaction

openapi/rpc-http/sendTransaction.yaml post /
Submits a signed transaction to the cluster for processing.

This method does not alter the transaction in any way; it relays the transaction created by clients to the node as-is.

If the node's rpc service receives the transaction, this method immediately succeeds, without waiting for any confirmations. A successful response from this method does not guarantee the transaction is processed or confirmed by the cluster.

While the rpc service will reasonably retry to submit it, the transaction could be rejected if transaction's recent\_blockhash expires before it lands.

Use [getSignatureStatuses](/api-reference/rpc/http/getsignaturestatuses) to ensure a transaction is processed and confirmed.

Before submitting, the following preflight checks are performed:

1. The transaction signatures are verified
2. The transaction is simulated against the bank slot specified by the preflight commitment. On failure an error will be returned. Preflight checks may be disabled if desired. It is recommended to specify the same commitment and preflight commitment to avoid confusing behavior.

The returned signature is the first signature in the transaction, which is used to identify the transaction (transaction id). This identifier can be easily extracted from the transaction data before submission.


# simulateBundle
Source: https://www.helius.dev/docs/api-reference/rpc/http/simulatebundle

openapi/rpc-http/simulateBundle.yaml post /
Simulate a JITO bundle without executing it on the blockchain.



# simulateTransaction
Source: https://www.helius.dev/docs/api-reference/rpc/http/simulatetransaction

openapi/rpc-http/simulateTransaction.yaml post /
Simulate sending a transaction.



# Websocket Methods
Source: https://www.helius.dev/docs/api-reference/rpc/websocket-methods

This page provides an overview of all available websocket methods that can be used to interact with the API.

This document provides a comprehensive overview of all available websocket methods for Solana RPC.

<CardGroup cols={2}>
  <Card title="accountSubscribe" href="/api-reference/rpc/websocket/accountsubscribe">
    Subscribe to an account to receive notifications when the lamports or data for a given account public key changes
  </Card>

  <Card title="accountUnsubscribe" href="/api-reference/rpc/websocket/accountunsubscribe">
    Unsubscribe from account change notifications
  </Card>

  <Card title="blockSubscribe" href="/api-reference/rpc/websocket/blocksubscribe">
    Subscribe to receive notification anytime a new block is confirmed or finalized
  </Card>

  <Card title="blockUnsubscribe" href="/api-reference/rpc/websocket/blockunsubscribe">
    Unsubscribe from block notifications
  </Card>

  <Card title="logsSubscribe" href="/api-reference/rpc/websocket/logssubscribe">
    Subscribe to transaction logging
  </Card>

  <Card title="logsUnsubscribe" href="/api-reference/rpc/websocket/logsunsubscribe">
    Unsubscribe from transaction logging
  </Card>

  <Card title="programSubscribe" href="/api-reference/rpc/websocket/programsubscribe">
    Subscribe to a program to receive notifications when the lamports or data for accounts owned by the program changes
  </Card>

  <Card title="programUnsubscribe" href="/api-reference/rpc/websocket/programunsubscribe">
    Unsubscribe from program notifications
  </Card>

  <Card title="rootSubscribe" href="/api-reference/rpc/websocket/rootsubscribe">
    Subscribe to receive notification anytime a new root is set by the validator
  </Card>

  <Card title="rootUnsubscribe" href="/api-reference/rpc/websocket/rootunsubscribe">
    Unsubscribe from root notifications
  </Card>

  <Card title="signatureSubscribe" href="/api-reference/rpc/websocket/signaturesubscribe">
    Subscribe to a transaction signature to receive notification when the transaction is confirmed
  </Card>

  <Card title="signatureUnsubscribe" href="/api-reference/rpc/websocket/signatureunsubscribe">
    Unsubscribe from signature confirmation notification
  </Card>

  <Card title="slotSubscribe" href="/api-reference/rpc/websocket/slotsubscribe">
    Subscribe to receive notification anytime a slot is processed by the validator
  </Card>

  <Card title="slotUnsubscribe" href="/api-reference/rpc/websocket/slotunsubscribe">
    Unsubscribe from slot notifications
  </Card>

  <Card title="slotsUpdatesSubscribe" href="/api-reference/rpc/websocket/slotsupdatessubscribe">
    Subscribe to receive notification anytime a slot is processed, optimized for high performance applications
  </Card>

  <Card title="slotsUpdatesUnsubscribe" href="/api-reference/rpc/websocket/slotsupdatesunsubscribe">
    Unsubscribe from slots updates notifications
  </Card>

  <Card title="voteSubscribe" href="/api-reference/rpc/websocket/votesubscribe">
    Subscribe to receive notification anytime a new vote is observed in gossip
  </Card>

  <Card title="voteUnsubscribe" href="/api-reference/rpc/websocket/voteunsubscribe">
    Unsubscribe from vote notifications
  </Card>
</CardGroup>

For detailed information on each method including parameters, results, and examples, please refer to the individual method documentation.


# accountSubscribe
Source: https://www.helius.dev/docs/api-reference/rpc/websocket/accountsubscribe

Subscribe to an account to receive notifications when the lamports or data for a given account public key changes.

## Endpoints

Websockets are available on mainnet and devnet with the following URLs:

* **Mainnet** `wss://mainnet.helius-rpc.com/?api-key=<API_KEY>`
* **Devnet** `wss://devnet.helius-rpc.com/?api-key=<API_KEY>`

<Note>Websockets have a 10-minute inactivity timer; implementing health checks and sending pings every minute is heavily recommended to keep the websocket connection alive.</Note>

## Authorizations

<ParamField query="api-key" type="string" required>
  Your Helius API key. You can get one for free in the [dashboard](https://dashboard.helius.dev/api-keys).
</ParamField>

## Body

<ParamField body="params" type="array" required>
  <Expandable title="properties" defaultOpen>
    <ParamField body="pubkey" type="string" required>
      Account Pubkey, as base-58 encoded string.
    </ParamField>

    <ParamField body="encoding" type="string">
      Encoding format for account data. Can be `base58`, `base64`, `base64+zstd`, or `jsonParsed`.

      * `base58` is slow
      * `jsonParsed` encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data
      * If `jsonParsed` is requested but a parser cannot be found, the field falls back to binary encoding, detectable when the data field is type string.
    </ParamField>

    <ParamField body="commitment" type="string">
      The commitment level for the subscription. Can be `finalized`, `confirmed`, or `processed`.
    </ParamField>
  </Expandable>
</ParamField>

## Response

<ResponseField name="result" type="integer">
  Subscription id (needed to unsubscribe)
</ResponseField>

<RequestExample>
  ```json Request
  {
    "jsonrpc": "2.0",
    "id": 1,
    "method": "accountSubscribe",
    "params": [
      "CM78CPUeXjn8o3yroDHxUtKsZZgoy4GPkPPXfouKNH12",
      {
        "encoding": "jsonParsed",
        "commitment": "finalized"
      }
    ]
  }
  ```
</RequestExample>

<ResponseExample>
  ```json Response
  {
    "jsonrpc": "2.0",
    "result": 23784,
    "id": 1
  }
  ```

  ```json Message (base58)
  {
    "jsonrpc": "2.0",
    "method": "accountNotification",
    "params": {
      "result": {
        "context": {
          "slot": 5199307
        },
        "value": {
          "data": [
            "11116bv5nS2h3y12kD1yUKeMZvGcKLSjQgX6BeV7u1FrjeJcKfsHPXHRDEHrBesJhZyqnnq9qJeUuF7WHxiuLuL5twc38w2TXNLxnDbjmuR",
            "base58"
          ],
          "executable": false,
          "lamports": 33594,
          "owner": "11111111111111111111111111111111",
          "rentEpoch": 635,
          "space": 80
        }
      },
      "subscription": 23784
    }
  }
  ```

  ```json Message (jsonParsed)
  {
    "jsonrpc": "2.0",
    "method": "accountNotification",
    "params": {
      "result": {
        "context": {
          "slot": 5199307
        },
        "value": {
          "data": {
            "program": "nonce",
            "parsed": {
              "type": "initialized",
              "info": {
                "authority": "Bbqg1M4YVVfbhEzwA9SpC9FhsaG83YMTYoR4a8oTDLX",
                "blockhash": "LUaQTmM7WbMRiATdMMHaRGakPtCkc2GHtH57STKXs6k",
                "feeCalculator": {
                  "lamportsPerSignature": 5000
                }
              }
            }
          },
          "executable": false,
          "lamports": 33594,
          "owner": "11111111111111111111111111111111",
          "rentEpoch": 635,
          "space": 80
        }
      },
      "subscription": 23784
    }
  }
  ```
</ResponseExample>


# accountUnsubscribe
Source: https://www.helius.dev/docs/api-reference/rpc/websocket/accountunsubscribe

Unsubscribe from account change notifications.

## Endpoints

Websockets are available on mainnet and devnet with the following URLs:

* **Mainnet** `wss://mainnet.helius-rpc.com/?api-key=<API_KEY>`
* **Devnet** `wss://devnet.helius-rpc.com/?api-key=<API_KEY>`

<Note>Websockets have a 10-minute inactivity timer; implementing health checks and sending pings every minute is heavily recommended to keep the websocket connection alive.</Note>

## Authorizations

<ParamField query="api-key" type="string" required>
  Your Helius API key. You can get one for free in the [dashboard](https://dashboard.helius.dev/api-keys).
</ParamField>

## Body

<ParamField body="params" type="array" required>
  <Expandable title="properties" defaultOpen>
    <ParamField body="subscriptionId" type="integer" required>
      Subscription id to cancel.
    </ParamField>
  </Expandable>
</ParamField>

## Response

<ResponseField name="result" type="boolean">
  Unsubscribe success message.
</ResponseField>

<RequestExample>
  ```json Request
  {
    "jsonrpc": "2.0",
    "id": 1,
    "method": "accountUnsubscribe",
    "params": [
      23784
    ]
  }
  ```
</RequestExample>

<ResponseExample>
  ```json Response
  {
    "jsonrpc": "2.0",
    "result": true,
    "id": 1
  }
  ```
</ResponseExample>


# blockSubscribe
Source: https://www.helius.dev/docs/api-reference/rpc/websocket/blocksubscribe

Subscribe to receive notification anytime a new block is `confirmed` or `finalized`.

<Note>
  This subscription is considered **unstable** and is only available if the validator was started with the `--rpc-pubsub-enable-block-subscription` flag. The format of this subscription may change in the future.
</Note>

## Endpoints

Websockets are available on mainnet and devnet with the following URLs:

* **Mainnet** `wss://mainnet.helius-rpc.com/?api-key=<API_KEY>`
* **Devnet** `wss://devnet.helius-rpc.com/?api-key=<API_KEY>`

<Note>Websockets have a 10-minute inactivity timer; implementing health checks and sending pings every minute is heavily recommended to keep the websocket connection alive.</Note>

## Authorizations

<ParamField query="api-key" type="string" required>
  Your Helius API key. You can get one for free in the [dashboard](https://dashboard.helius.dev/api-keys).
</ParamField>

## Body

<ParamField body="params" type="array" required>
  <Expandable title="properties" defaultOpen>
    <ParamField body="filter" type="string | object" required>
      Filter criteria for the logs to receive results by account type; currently supported:

      * `all` - include all transactions in block
      * A JSON object with the following field:
        * `mentionsAccountOrProgram: <string>` - return only transactions that mention the provided public key (as base-58 encoded string). If no mentions in a given block, then no notification will be sent.
    </ParamField>

    <ParamField body="config" type="object">
      Configuration object containing the following fields:

      <ParamField body="commitment" type="string">
        The commitment level for the subscription. Can be `finalized`, `confirmed`, or `processed`.
      </ParamField>

      <ParamField body="encoding" type="string">
        Encoding format for the transaction data.
      </ParamField>

      <ParamField body="transactionDetails" type="string">
        Level of transaction detail to return.
      </ParamField>

      <ParamField body="maxSupportedTransactionVersion" type="number">
        The max transaction version to return in responses.
      </ParamField>

      <ParamField body="showRewards" type="boolean">
        Whether to show rewards in the response.
      </ParamField>
    </ParamField>
  </Expandable>
</ParamField>

## Response

<ResponseField name="result" type="integer">
  Subscription id (needed to unsubscribe)
</ResponseField>

## Notification Format

The notification will be an object with the following fields:

* `slot: <u64>` - The corresponding slot.
* `err: <object|null>` - Error if something went wrong publishing the notification otherwise null.
* `block: <object|null>` - A block object as seen in the `getBlock` RPC HTTP method.

<RequestExample>
  ```json Request
  {
    "jsonrpc": "2.0",
    "id": "1",
    "method": "blockSubscribe",
    "params": [
      {
        "mentionsAccountOrProgram": "LieKvPRE8XeX3Y2xVNHjKlpAScD12lYySBVQ4HqoJ5op"
      },
      {
        "commitment": "confirmed",
        "encoding": "base64",
        "showRewards": true,
        "transactionDetails": "full"
      }
    ]
  }
  ```
</RequestExample>

<ResponseExample>
  ```json Response
  {
    "jsonrpc": "2.0",
    "result": 0,
    "id": 1
  }
  ```

  ```json Notification
  {
    "jsonrpc": "2.0",
    "method": "blockNotification",
    "params": {
      "result": {
        "context": {
          "slot": 112301554
        },
        "value": {
          "slot": 112301554,
          "block": {
            "previousBlockhash": "GJp125YAN4ufCSUvZJVdCyWQJ7RPWMmwxoyUQySydZA",
            "blockhash": "6ojMHjctdqfB55JDpEpqfHnP96fiaHEcvzEQ2NNcxzHP",
            "parentSlot": 112301553,
            "transactions": [
              {
                "transaction": [
                  "OpltwoUvWxYi1P2U8vbIdE/aPntjYo5Aa0VQ2JJyeJE2g9Vvxk8dDGgFMruYfDu8/IfUWb0REppTe7IpAuuLRgIBAAkWnj4KHRpEWWW7gvO1c0BHy06wZi2g7/DLqpEtkRsThAXIdBbhXCLvltw50ZnjDx2hzw74NVn49kmpYj2VZHQJoeJoYJqaKcvuxCi/2i4yywedcVNDWkM84Iuw+cEn9/ROCrXY4qBFI9dveEERQ1c4kdU46xjxj9Vi+QXkb2Kx45QFVkG4Y7HHsoS6WNUiw2m4ffnMNnOVdF9tJht7oeuEfDMuUEaO7l9JeUxppCvrGk3CP45saO51gkwVYEgKzhpKjCx3rgsYxNR81fY4hnUQXSbbc2Y55FkwgRBpVvQK7/+clR4Gjhd3L4y+OtPl7QF93Akg1LaU9wRMs5nvfDFlggqI9PqJl+IvVWrNRdBbPS8LIIhcwbRTkSbqlJQWxYg3Bo2CTVbw7rt1ZubuHWWp0mD/UJpLXGm2JprWTePNULzHu67sfqaWF99LwmwjTyYEkqkRt1T0Je5VzHgJs0N5jY4iIU9K3lMqvrKOIn/2zEMZ+ol2gdgjshx+sphIyhw65F3J/Dbzk04LLkK+CULmN571Y+hFlXF2ke0BIuUG6AUF+4214Cu7FXnqo3rkxEHDZAk0lRrAJ8X/Z+iwuwI5cgbd9uHXZaGT2cvhRs7reawctIXtX1s3kTqM9YV+/wCpDLAp8axcEkaQkLDKRoWxqp8XLNZSKial7Rk+ELAVVKWoWLRXRZ+OIggu0OzMExvVLE5VHqy71FNHq4gGitkiKYNFWSLIE4qGfdFLZXy/6hwS+wq9ewjikCpd//C9BcCL7Wl0iQdUslxNVCBZHnCoPYih9JXvGefOb9WWnjGy14sG9j70+RSVx6BlkFELWwFvIlWR/tHn3EhHAuL0inS2pwX7ZQTAU6gDVaoqbR2EiJ47cKoPycBNvHLoKxoY9AZaBjPl6q8SKQJSFyFd9n44opAgI6zMTjYF/8Ok4VpXEESp3QaoUyTI9sOJ6oFP6f4dwnvQelgXS+AEfAsHsKXxGAIUDQENAgMEBQAGBwgIDg8IBJCER3QXl1AVDBADCQoOAAQLERITDAjb7ugh3gOuTy==",
                  "base64"
                ],
                "meta": {
                  "err": null,
                  "status": {
                    "Ok": null
                  },
                  "fee": 5000,
                  "preBalances": [
                    1758510880, 2067120, 1566000, 1461600, 2039280, 2039280,
                    1900080, 1865280, 0, 3680844220, 2039280
                  ],
                  "postBalances": [
                    1758505880, 2067120, 1566000, 1461600, 2039280, 2039280,
                    1900080, 1865280, 0, 3680844220, 2039280
                  ],
                  "innerInstructions": [
                    {
                      "index": 0,
                      "instructions": [
                        {
                          "programIdIndex": 13,
                          "accounts": [1, 15, 3, 4, 2, 14],
                          "data": "21TeLgZXNbtHXVBzCaiRmH"
                        },
                        {
                          "programIdIndex": 14,
                          "accounts": [3, 4, 1],
                          "data": "6qfC8ic7Aq99"
                        }
                      ]
                    }
                  ],
                  "logMessages": [
                    "Program QMNeHCGYnLVDn1icRAfQZpjPLBNkfGbSKRB83G5d8KB invoke [1]",
                    "Program QMWoBmAyJLAsA1Lh9ugMTw2gciTihncciphzdNzdZYV invoke [2]"
                  ],
                  "preTokenBalances": [
                    {
                      "accountIndex": 4,
                      "mint": "iouQcQBAiEXe6cKLS85zmZxUqaCqBdeHFpqKoSz615u",
                      "uiTokenAmount": {
                        "uiAmount": null,
                        "decimals": 6,
                        "amount": "0",
                        "uiAmountString": "0"
                      },
                      "owner": "LieKvPRE8XeX3Y2xVNHjKlpAScD12lYySBVQ4HqoJ5op",
                      "programId": "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"
                    }
                  ],
                  "postTokenBalances": [
                    {
                      "accountIndex": 4,
                      "mint": "iouQcQBAiEXe6cKLS85zmZxUqaCqBdeHFpqKoSz615u",
                      "uiTokenAmount": {
                        "uiAmount": null,
                        "decimals": 6,
                        "amount": "0",
                        "uiAmountString": "0"
                      },
                      "owner": "LieKvPRE8XeX3Y2xVNHjKlpAScD12lYySBVQ4HqoJ5op",
                      "programId": "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"
                    }
                  ],
                  "rewards": []
                }
              }
            ],
            "blockTime": 1639926816,
            "blockHeight": 101210751
          },
          "err": null
        }
      },
      "subscription": 14
    }
  }
  ```
</ResponseExample>


# blockUnsubscribe
Source: https://www.helius.dev/docs/api-reference/rpc/websocket/blockunsubscribe

Unsubscribe from block notifications.

## Endpoints

Websockets are available on mainnet and devnet with the following URLs:

* **Mainnet** `wss://mainnet.helius-rpc.com/?api-key=<API_KEY>`
* **Devnet** `wss://devnet.helius-rpc.com/?api-key=<API_KEY>`

<Note>Websockets have a 10-minute inactivity timer; implementing health checks and sending pings every minute is heavily recommended to keep the websocket connection alive.</Note>

## Authorizations

<ParamField query="api-key" type="string" required>
  Your Helius API key. You can get one for free in the [dashboard](https://dashboard.helius.dev/api-keys).
</ParamField>

## Body

<ParamField body="params" type="array" required>
  <Expandable title="properties" defaultOpen>
    <ParamField body="subscriptionId" type="integer" required>
      Subscription id to cancel.
    </ParamField>
  </Expandable>
</ParamField>

## Response

<ResponseField name="result" type="boolean">
  Unsubscribe success message.
</ResponseField>

<RequestExample>
  ```json Request
  {
    "jsonrpc": "2.0",
    "id": 1,
    "method": "blockUnsubscribe",
    "params": [
      0
    ]
  }
  ```
</RequestExample>

<ResponseExample>
  ```json Response
  {
    "jsonrpc": "2.0",
    "result": true,
    "id": 1
  }
  ```
</ResponseExample>


# logsSubscribe
Source: https://www.helius.dev/docs/api-reference/rpc/websocket/logssubscribe

Subscribe to transaction logging.

## Endpoints

Websockets are available on mainnet and devnet with the following URLs:

* **Mainnet** `wss://mainnet.helius-rpc.com/?api-key=<API_KEY>`
* **Devnet** `wss://devnet.helius-rpc.com/?api-key=<API_KEY>`

<Note>Websockets have a 10-minute inactivity timer; implementing health checks and sending pings every minute is heavily recommended to keep the websocket connection alive.</Note>

## Authorizations

<ParamField query="api-key" type="string" required>
  Your Helius API key. You can get one for free in the [dashboard](https://dashboard.helius.dev/api-keys).
</ParamField>

## Body

<ParamField body="params" type="array" required>
  <Expandable title="properties" defaultOpen>
    <ParamField body="filter" type="string | object" required>
      Filter criteria for the logs to receive results by account type. The following filters types are currently supported:

      * `all` - subscribe to all transactions except for simple vote transactions
      * `allWithVotes` - subscribe to all transactions, including simple vote transactions
      * A JSON object with the following field:
        * `mentions: [ <string> ]` - array containing a single Pubkey (as base-58 encoded string); if present, subscribe to only transactions mentioning this address

      Note: The `mentions` field currently only supports one Pubkey string per method call. Listing additional addresses will result in an error.
    </ParamField>

    <ParamField body="config" type="object">
      Configuration object containing the following fields:

      <ParamField body="commitment" type="string">
        The commitment level for the subscription. Can be `finalized`, `confirmed`, or `processed`.
      </ParamField>
    </ParamField>
  </Expandable>
</ParamField>

## Response

<ResponseField name="result" type="integer">
  Subscription id (needed to unsubscribe)
</ResponseField>

## Notification Format

The notification will be an RpcResponse JSON object with value equal to:

* `signature: <string>` - The transaction signature base58 encoded.
* `err: <object|null>` - Error if transaction failed, null if transaction succeeded. See TransactionError definitions.
* `logs: <array[string]>` - Array of log messages the transaction instructions output during execution.

<RequestExample>
  ```json Request
  {
    "jsonrpc": "2.0",
    "id": 1,
    "method": "logsSubscribe",
    "params": [
      {
        "mentions": ["11111111111111111111111111111111"]
      },
      {
        "commitment": "finalized"
      }
    ]
  }
  ```
</RequestExample>

<ResponseExample>
  ```json Response
  {
    "jsonrpc": "2.0",
    "result": 24040,
    "id": 1
  }
  ```

  ```json Notification
  {
    "jsonrpc": "2.0",
    "method": "logsNotification",
    "params": {
      "result": {
        "context": {
          "slot": 5208469
        },
        "value": {
          "signature": "5h6xBEauJ3PK6SWCZ1PGjBvj8vDdWG3KpwATGy1ARAXFSDwt8GFXM7W5Ncn16wmqokgpiKRLuS83KUxyZyv2sUYv",
          "err": null,
          "logs": [
            "SBF program 83astBRguLMdt2h5U1Tpdq5tjFoJ6noeGwaY3mDLVcri success"
          ]
        }
      },
      "subscription": 24040
    }
  }
  ```
</ResponseExample>


# logsUnsubscribe
Source: https://www.helius.dev/docs/api-reference/rpc/websocket/logsunsubscribe

Unsubscribe from transaction logging.

## Endpoints

Websockets are available on mainnet and devnet with the following URLs:

* **Mainnet** `wss://mainnet.helius-rpc.com/?api-key=<API_KEY>`
* **Devnet** `wss://devnet.helius-rpc.com/?api-key=<API_KEY>`

<Note>Websockets have a 10-minute inactivity timer; implementing health checks and sending pings every minute is heavily recommended to keep the websocket connection alive.</Note>

## Authorizations

<ParamField query="api-key" type="string" required>
  Your Helius API key. You can get one for free in the [dashboard](https://dashboard.helius.dev/api-keys).
</ParamField>

## Body

<ParamField body="params" type="array" required>
  <Expandable title="properties" defaultOpen>
    <ParamField body="subscriptionId" type="integer" required>
      Subscription id to cancel.
    </ParamField>
  </Expandable>
</ParamField>

## Response

<ResponseField name="result" type="boolean">
  Unsubscribe success message.
</ResponseField>

<RequestExample>
  ```json Request
  {
    "jsonrpc": "2.0",
    "id": 1,
    "method": "logsUnsubscribe",
    "params": [
      24040
    ]
  }
  ```
</RequestExample>

<ResponseExample>
  ```json Response
  {
    "jsonrpc": "2.0",
    "result": true,
    "id": 1
  }
  ```
</ResponseExample>


# programSubscribe
Source: https://www.helius.dev/docs/api-reference/rpc/websocket/programsubscribe

Subscribe to a program to receive notifications when the lamports or data for an account owned by the given program changes.

## Endpoints

Websockets are available on mainnet and devnet with the following URLs:

* **Mainnet** `wss://mainnet.helius-rpc.com/?api-key=<API_KEY>`
* **Devnet** `wss://devnet.helius-rpc.com/?api-key=<API_KEY>`

<Note>Websockets have a 10-minute inactivity timer; implementing health checks and sending pings every minute is heavily recommended to keep the websocket connection alive.</Note>

## Authorizations

<ParamField query="api-key" type="string" required>
  Your Helius API key. You can get one for free in the [dashboard](https://dashboard.helius.dev/api-keys).
</ParamField>

## Body

<ParamField body="params" type="array" required>
  <Expandable title="properties" defaultOpen>
    <ParamField body="programId" type="string" required>
      Pubkey of the `program_id`, as base-58 encoded string.
    </ParamField>

    <ParamField body="config" type="object">
      Configuration object containing the following fields:

      <ParamField body="commitment" type="string">
        The commitment level for the subscription. Can be `finalized`, `confirmed`, or `processed`.
      </ParamField>

      <ParamField body="filters" type="array">
        Array of filter objects to apply.
      </ParamField>

      <ParamField body="encoding" type="string">
        Encoding format for account data. Can be `base58`, `base64`, `base64+zstd`, or `jsonParsed`.

        * `base58` is slow
        * `jsonParsed` encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data
        * If `jsonParsed` is requested but a parser cannot be found, the field falls back to binary encoding, detectable when the data field is type string.
      </ParamField>
    </ParamField>
  </Expandable>
</ParamField>

## Response

<ResponseField name="result" type="integer">
  Subscription id (needed to unsubscribe)
</ResponseField>

## Notification Format

The notification format is a **single** program account object as seen in the `getProgramAccounts` RPC HTTP method.

<RequestExample>
  ```json Request
  {
    "jsonrpc": "2.0",
    "id": 1,
    "method": "programSubscribe",
    "params": [
      "11111111111111111111111111111111",
      {
        "encoding": "base64",
        "filters": [{ "dataSize": 80 }]
      }
    ]
  }
  ```
</RequestExample>

<ResponseExample>
  ```json Response
  {
    "jsonrpc": "2.0",
    "result": 24040,
    "id": 1
  }
  ```

  ```json Notification (base58)
  {
    "jsonrpc": "2.0",
    "method": "programNotification",
    "params": {
      "result": {
        "context": {
          "slot": 5208469
        },
        "value": {
          "pubkey": "H4vnBqifaSACnKa7acsxstsY1iV1bvJNxsCY7enrd1hq",
          "account": {
            "data": [
              "11116bv5nS2h3y12kD1yUKeMZvGcKLSjQgX6BeV7u1FrjeJcKfsHPXHRDEHrBesJhZyqnnq9qJeUuF7WHxiuLuL5twc38w2TXNLxnDbjmuR",
              "base58"
            ],
            "executable": false,
            "lamports": 33594,
            "owner": "11111111111111111111111111111111",
            "rentEpoch": 636,
            "space": 80
          }
        }
      },
      "subscription": 24040
    }
  }
  ```

  ```json Notification (jsonParsed)
  {
    "jsonrpc": "2.0",
    "method": "programNotification",
    "params": {
      "result": {
        "context": {
          "slot": 5208469
        },
        "value": {
          "pubkey": "H4vnBqifaSACnKa7acsxstsY1iV1bvJNxsCY7enrd1hq",
          "account": {
            "data": {
              "program": "nonce",
              "parsed": {
                "type": "initialized",
                "info": {
                  "authority": "Bbqg1M4YVVfbhEzwA9SpC9FhsaG83YMTYoR4a8oTDLX",
                  "blockhash": "LUaQTmM7WbMRiATdMMHaRGakPtCkc2GHtH57STKXs6k",
                  "feeCalculator": {
                    "lamportsPerSignature": 5000
                  }
                }
              }
            },
            "executable": false,
            "lamports": 33594,
            "owner": "11111111111111111111111111111111",
            "rentEpoch": 636,
            "space": 80
          }
        }
      },
      "subscription": 24040
    }
  }
  ```
</ResponseExample>


# programUnsubscribe
Source: https://www.helius.dev/docs/api-reference/rpc/websocket/programunsubscribe

Unsubscribe from program-owned account change notifications.

## Endpoints

Websockets are available on mainnet and devnet with the following URLs:

* **Mainnet** `wss://mainnet.helius-rpc.com/?api-key=<API_KEY>`
* **Devnet** `wss://devnet.helius-rpc.com/?api-key=<API_KEY>`

<Note>Websockets have a 10-minute inactivity timer; implementing health checks and sending pings every minute is heavily recommended to keep the websocket connection alive.</Note>

## Authorizations

<ParamField query="api-key" type="string" required>
  Your Helius API key. You can get one for free in the [dashboard](https://dashboard.helius.dev/api-keys).
</ParamField>

## Body

<ParamField body="params" type="array" required>
  <Expandable title="properties" defaultOpen>
    <ParamField body="subscriptionId" type="integer" required>
      Id of account Subscription to cancel.
    </ParamField>
  </Expandable>
</ParamField>

## Response

<ResponseField name="result" type="boolean">
  Unsubscribe success message.
</ResponseField>

<RequestExample>
  ```json Request
  {
    "jsonrpc": "2.0",
    "id": 1,
    "method": "programUnsubscribe",
    "params": [
      24040
    ]
  }
  ```
</RequestExample>

<ResponseExample>
  ```json Response
  {
    "jsonrpc": "2.0",
    "result": true,
    "id": 1
  }
  ```
</ResponseExample>


# rootSubscribe
Source: https://www.helius.dev/docs/api-reference/rpc/websocket/rootsubscribe

Subscribe to receive notification anytime a new root is set by the validator.

## Endpoints

Websockets are available on mainnet and devnet with the following URLs:

* **Mainnet** `wss://mainnet.helius-rpc.com/?api-key=<API_KEY>`
* **Devnet** `wss://devnet.helius-rpc.com/?api-key=<API_KEY>`

<Note>Websockets have a 10-minute inactivity timer; implementing health checks and sending pings every minute is heavily recommended to keep the websocket connection alive.</Note>

## Authorizations

<ParamField query="api-key" type="string" required>
  Your Helius API key. You can get one for free in the [dashboard](https://dashboard.helius.dev/api-keys).
</ParamField>

## Body

<ParamField body="params" type="array">
  <Expandable title="properties" defaultOpen>
    <ParamField body="none" type="null">
      No parameters required.
    </ParamField>
  </Expandable>
</ParamField>

## Response

<ResponseField name="result" type="integer">
  Subscription id (needed to unsubscribe)
</ResponseField>

## Notification Format

The result is the latest root slot number.

<RequestExample>
  ```json Request
  {
    "jsonrpc": "2.0",
    "id": 1,
    "method": "rootSubscribe"
  }
  ```
</RequestExample>

<ResponseExample>
  ```json Response
  {
    "jsonrpc": "2.0",
    "result": 0,
    "id": 1
  }
  ```

  ```json Notification
  {
    "jsonrpc": "2.0",
    "method": "rootNotification",
    "params": {
      "result": 42,
      "subscription": 0
    }
  }
  ```
</ResponseExample>


# rootUnsubscribe
Source: https://www.helius.dev/docs/api-reference/rpc/websocket/rootunsubscribe

Unsubscribe from root notifications.

## Endpoints

Websockets are available on mainnet and devnet with the following URLs:

* **Mainnet** `wss://mainnet.helius-rpc.com/?api-key=<API_KEY>`
* **Devnet** `wss://devnet.helius-rpc.com/?api-key=<API_KEY>`

<Note>Websockets have a 10-minute inactivity timer; implementing health checks and sending pings every minute is heavily recommended to keep the websocket connection alive.</Note>

## Authorizations

<ParamField query="api-key" type="string" required>
  Your Helius API key. You can get one for free in the [dashboard](https://dashboard.helius.dev/api-keys).
</ParamField>

## Body

<ParamField body="params" type="array" required>
  <Expandable title="properties" defaultOpen>
    <ParamField body="subscriptionId" type="integer" required>
      Subscription id to cancel.
    </ParamField>
  </Expandable>
</ParamField>

## Response

<ResponseField name="result" type="boolean">
  Unsubscribe success message.
</ResponseField>

<RequestExample>
  ```json Request
  {
    "jsonrpc": "2.0",
    "id": 1,
    "method": "rootUnsubscribe",
    "params": [
      0
    ]
  }
  ```
</RequestExample>

<ResponseExample>
  ```json Response
  {
    "jsonrpc": "2.0",
    "result": true,
    "id": 1
  }
  ```
</ResponseExample>


# signatureSubscribe
Source: https://www.helius.dev/docs/api-reference/rpc/websocket/signaturesubscribe

Subscribe to receive a notification when the transaction with the given signature reaches the specified commitment level.

This is a subscription to a single notification. It is automatically cancelled by the server once the notification, `signatureNotification`, is sent by the RPC.

## Endpoints

Websockets are available on mainnet and devnet with the following URLs:

* **Mainnet** `wss://mainnet.helius-rpc.com/?api-key=<API_KEY>`
* **Devnet** `wss://devnet.helius-rpc.com/?api-key=<API_KEY>`

<Note>Websockets have a 10-minute inactivity timer; implementing health checks and sending pings every minute is heavily recommended to keep the websocket connection alive.</Note>

## Authorizations

<ParamField query="api-key" type="string" required>
  Your Helius API key. You can get one for free in the [dashboard](https://dashboard.helius.dev/api-keys).
</ParamField>

## Body

<ParamField body="params" type="array" required>
  <Expandable title="properties" defaultOpen>
    <ParamField body="signature" type="string" required>
      Transaction signature, as base-58 encoded string.

      The transaction signature must be the first signature from the transaction (see transaction id for more details).
    </ParamField>

    <ParamField body="config" type="object">
      Configuration object containing the following fields:

      <ParamField body="commitment" type="string">
        The commitment level for the subscription. Can be `finalized`, `confirmed`, or `processed`.
      </ParamField>

      <ParamField body="enableReceivedNotification" type="boolean">
        Whether to send a notification when the transaction signature is received.
      </ParamField>
    </ParamField>
  </Expandable>
</ParamField>

## Response

<ResponseField name="result" type="integer">
  Subscription id (needed to unsubscribe)
</ResponseField>

## Notification Format

The notification will be an RpcResponse JSON object with value containing an object with:

* `slot: <u64>` - The corresponding slot.
* `value: <object|string>` - a notification value of RpcSignatureResult, resulting in either:
  * when `enableReceivedNotification` is `true` and the signature is received: the literal string `"receivedSignature"`, or
  * when the signature is processed: `err: <object|null>`:
    * `null` if the transaction succeeded in being processed at the specified commitment level, or
    * a TransactionError, if the transaction failed

<RequestExample>
  ```json Request
  {
    "jsonrpc": "2.0",
    "id": 1,
    "method": "signatureSubscribe",
    "params": [
      "2EBVM6cB8vAAD93Ktr6Vd8p67XPbQzCJX47MpReuiCXJAtcjaxpvWpcg9Ege1Nr5Tk3a2GFrByT7WPBjdsTycY9b",
      {
        "commitment": "finalized",
        "enableReceivedNotification": false
      }
    ]
  }
  ```
</RequestExample>

<ResponseExample>
  ```json Response
  {
    "jsonrpc": "2.0",
    "result": 0,
    "id": 1
  }
  ```

  ```json Notification (Processed Transaction)
  {
    "jsonrpc": "2.0",
    "method": "signatureNotification",
    "params": {
      "result": {
        "context": {
          "slot": 5207624
        },
        "value": {
          "err": null
        }
      },
      "subscription": 24006
    }
  }
  ```

  ```json Notification (Received Transaction)
  {
    "jsonrpc": "2.0",
    "method": "signatureNotification",
    "params": {
      "result": {
        "context": {
          "slot": 5207624
        },
        "value": "receivedSignature"
      },
      "subscription": 24006
    }
  }
  ```
</ResponseExample>


# signatureUnsubscribe
Source: https://www.helius.dev/docs/api-reference/rpc/websocket/signatureunsubscribe

Unsubscribe from signature confirmation notification.

## Endpoints

Websockets are available on mainnet and devnet with the following URLs:

* **Mainnet** `wss://mainnet.helius-rpc.com/?api-key=<API_KEY>`
* **Devnet** `wss://devnet.helius-rpc.com/?api-key=<API_KEY>`

<Note>Websockets have a 10-minute inactivity timer; implementing health checks and sending pings every minute is heavily recommended to keep the websocket connection alive.</Note>

## Authorizations

<ParamField query="api-key" type="string" required>
  Your Helius API key. You can get one for free in the [dashboard](https://dashboard.helius.dev/api-keys).
</ParamField>

## Body

<ParamField body="params" type="array" required>
  <Expandable title="properties" defaultOpen>
    <ParamField body="subscriptionId" type="integer" required>
      Subscription id to cancel.
    </ParamField>
  </Expandable>
</ParamField>

## Response

<ResponseField name="result" type="boolean">
  Unsubscribe success message.
</ResponseField>

<RequestExample>
  ```json Request
  {
    "jsonrpc": "2.0",
    "id": 1,
    "method": "signatureUnsubscribe",
    "params": [
      0
    ]
  }
  ```
</RequestExample>

<ResponseExample>
  ```json Response
  {
    "jsonrpc": "2.0",
    "result": true,
    "id": 1
  }
  ```
</ResponseExample>


# slotSubscribe
Source: https://www.helius.dev/docs/api-reference/rpc/websocket/slotsubscribe

Subscribe to receive notification anytime a slot is processed by the validator.

## Endpoints

Websockets are available on mainnet and devnet with the following URLs:

* **Mainnet** `wss://mainnet.helius-rpc.com/?api-key=<API_KEY>`
* **Devnet** `wss://devnet.helius-rpc.com/?api-key=<API_KEY>`

<Note>Websockets have a 10-minute inactivity timer; implementing health checks and sending pings every minute is heavily recommended to keep the websocket connection alive.</Note>

## Authorizations

<ParamField query="api-key" type="string" required>
  Your Helius API key. You can get one for free in the [dashboard](https://dashboard.helius.dev/api-keys).
</ParamField>

## Body

<ParamField body="params" type="array">
  <Expandable title="properties" defaultOpen>
    <ParamField body="none" type="null">
      No parameters required.
    </ParamField>
  </Expandable>
</ParamField>

## Response

<ResponseField name="result" type="integer">
  Subscription id (needed to unsubscribe)
</ResponseField>

## Notification Format

The notification will be an object with the following fields:

* `parent: <u64>` - The parent slot
* `root: <u64>` - The current root slot
* `slot: <u64>` - The newly set slot value

<RequestExample>
  ```json Request
  {
    "jsonrpc": "2.0",
    "id": 1,
    "method": "slotSubscribe"
  }
  ```
</RequestExample>

<ResponseExample>
  ```json Response
  {
    "jsonrpc": "2.0",
    "result": 0,
    "id": 1
  }
  ```

  ```json Notification
  {
    "jsonrpc": "2.0",
    "method": "slotNotification",
    "params": {
      "result": {
        "parent": 75,
        "root": 44,
        "slot": 76
      },
      "subscription": 0
    }
  }
  ```
</ResponseExample>


# slotsUpdatesSubscribe
Source: https://www.helius.dev/docs/api-reference/rpc/websocket/slotsupdatessubscribe

Subscribe to receive a notification from the validator on a variety of updates on every slot.

<Note>
  This subscription is unstable. The format of this subscription may change in the future, and may not always be supported.
</Note>

## Endpoints

Websockets are available on mainnet and devnet with the following URLs:

* **Mainnet** `wss://mainnet.helius-rpc.com/?api-key=<API_KEY>`
* **Devnet** `wss://devnet.helius-rpc.com/?api-key=<API_KEY>`

<Note>Websockets have a 10-minute inactivity timer; implementing health checks and sending pings every minute is heavily recommended to keep the websocket connection alive.</Note>

## Authorizations

<ParamField query="api-key" type="string" required>
  Your Helius API key. You can get one for free in the [dashboard](https://dashboard.helius.dev/api-keys).
</ParamField>

## Body

<ParamField body="params" type="array">
  <Expandable title="properties" defaultOpen>
    <ParamField body="none" type="null">
      No parameters required.
    </ParamField>
  </Expandable>
</ParamField>

## Response

<ResponseField name="result" type="integer">
  Subscription id (needed to unsubscribe)
</ResponseField>

## Notification Format

The notification will be an object with the following fields:

* `err: <string|undefined>` - The error message. Only present if the update is of type "dead".
* `parent: <u64|undefined>` - The parent slot. Only present if the update is of type "createdBank".
* `slot: <u64>` - The newly updated slot
* `stats: <object|undefined>` - Only present if the update is of type "frozen". An object with the following fields:
  * `maxTransactionsPerEntry: <u64>`
  * `numFailedTransactions: <u64>`
  * `numSuccessfulTransactions: <u64>`
  * `numTransactionEntries: <u64>`
* `timestamp: <i64>` - The Unix timestamp of the update in milliseconds
* `type: <string>` - The update type, one of:
  * "firstShredReceived"
  * "completed"
  * "createdBank"
  * "frozen"
  * "dead"
  * "optimisticConfirmation"
  * "root"

<RequestExample>
  ```json Request
  {
    "jsonrpc": "2.0",
    "id": 1,
    "method": "slotsUpdatesSubscribe"
  }
  ```
</RequestExample>

<ResponseExample>
  ```json Response
  {
    "jsonrpc": "2.0",
    "result": 0,
    "id": 1
  }
  ```

  ```json Notification
  {
    "jsonrpc": "2.0",
    "method": "slotsUpdatesNotification",
    "params": {
      "result": {
        "parent": 75,
        "slot": 76,
        "timestamp": 1625081266243,
        "type": "optimisticConfirmation"
      },
      "subscription": 0
    }
  }
  ```
</ResponseExample>


# slotsUpdatesUnsubscribe
Source: https://www.helius.dev/docs/api-reference/rpc/websocket/slotsupdatesunsubscribe

Unsubscribe from slot-update notifications.

## Endpoints

Websockets are available on mainnet and devnet with the following URLs:

* **Mainnet** `wss://mainnet.helius-rpc.com/?api-key=<API_KEY>`
* **Devnet** `wss://devnet.helius-rpc.com/?api-key=<API_KEY>`

<Note>Websockets have a 10-minute inactivity timer; implementing health checks and sending pings every minute is heavily recommended to keep the websocket connection alive.</Note>

## Authorizations

<ParamField query="api-key" type="string" required>
  Your Helius API key. You can get one for free in the [dashboard](https://dashboard.helius.dev/api-keys).
</ParamField>

## Body

<ParamField body="params" type="array" required>
  <Expandable title="properties" defaultOpen>
    <ParamField body="subscriptionId" type="integer" required>
      Subscription id to cancel.
    </ParamField>
  </Expandable>
</ParamField>

## Response

<ResponseField name="result" type="boolean">
  Unsubscribe success message.
</ResponseField>

<RequestExample>
  ```json Request
  {
    "jsonrpc": "2.0",
    "id": 1,
    "method": "slotsUpdatesUnsubscribe",
    "params": [
      0
    ]
  }
  ```
</RequestExample>

<ResponseExample>
  ```json Response
  {
    "jsonrpc": "2.0",
    "result": true,
    "id": 1
  }
  ```
</ResponseExample>


# slotUnsubscribe
Source: https://www.helius.dev/docs/api-reference/rpc/websocket/slotunsubscribe

Unsubscribe from slot notifications.

## Endpoints

Websockets are available on mainnet and devnet with the following URLs:

* **Mainnet** `wss://mainnet.helius-rpc.com/?api-key=<API_KEY>`
* **Devnet** `wss://devnet.helius-rpc.com/?api-key=<API_KEY>`

<Note>Websockets have a 10-minute inactivity timer; implementing health checks and sending pings every minute is heavily recommended to keep the websocket connection alive.</Note>

## Authorizations

<ParamField query="api-key" type="string" required>
  Your Helius API key. You can get one for free in the [dashboard](https://dashboard.helius.dev/api-keys).
</ParamField>

## Body

<ParamField body="params" type="array" required>
  <Expandable title="properties" defaultOpen>
    <ParamField body="subscriptionId" type="integer" required>
      Subscription id to cancel.
    </ParamField>
  </Expandable>
</ParamField>

## Response

<ResponseField name="result" type="boolean">
  Unsubscribe success message.
</ResponseField>

<RequestExample>
  ```json Request
  {
    "jsonrpc": "2.0",
    "id": 1,
    "method": "slotUnsubscribe",
    "params": [
      0
    ]
  }
  ```
</RequestExample>

<ResponseExample>
  ```json Response
  {
    "jsonrpc": "2.0",
    "result": true,
    "id": 1
  }
  ```
</ResponseExample>


# voteSubscribe
Source: https://www.helius.dev/docs/api-reference/rpc/websocket/votesubscribe

Subscribe to receive notification anytime a new vote is observed in gossip. These votes are pre-consensus therefore there is no guarantee these votes will enter the ledger.

<Note>
  This subscription is unstable and only available if the validator was started with the `--rpc-pubsub-enable-vote-subscription` flag. The format of this subscription may change in the future.
</Note>

## Endpoints

Websockets are available on mainnet and devnet with the following URLs:

* **Mainnet** `wss://mainnet.helius-rpc.com/?api-key=<API_KEY>`
* **Devnet** `wss://devnet.helius-rpc.com/?api-key=<API_KEY>`

<Note>Websockets have a 10-minute inactivity timer; implementing health checks and sending pings every minute is heavily recommended to keep the websocket connection alive.</Note>

## Authorizations

<ParamField query="api-key" type="string" required>
  Your Helius API key. You can get one for free in the [dashboard](https://dashboard.helius.dev/api-keys).
</ParamField>

## Body

<ParamField body="params" type="array">
  <Expandable title="properties" defaultOpen>
    <ParamField body="none" type="null">
      No parameters required.
    </ParamField>
  </Expandable>
</ParamField>

## Response

<ResponseField name="result" type="integer">
  Subscription id (needed to unsubscribe)
</ResponseField>

## Notification Format

The notification will be an object with the following fields:

* `hash: <string>` - The vote hash
* `slots: <array>` - The slots covered by the vote, as an array of u64 integers
* `timestamp: <i64|null>` - The timestamp of the vote
* `signature: <string>` - The signature of the transaction that contained this vote
* `votePubkey: <string>` - The public key of the vote account, as base-58 encoded string

<RequestExample>
  ```json Request
  {
    "jsonrpc": "2.0",
    "id": 1,
    "method": "voteSubscribe"
  }
  ```
</RequestExample>

<ResponseExample>
  ```json Response
  {
    "jsonrpc": "2.0",
    "result": 0,
    "id": 1
  }
  ```

  ```json Notification
  {
    "jsonrpc": "2.0",
    "method": "voteNotification",
    "params": {
      "result": {
        "hash": "8Rshv2oMkPu5E4opXTRyuyBeZBqQ4S477VG26wUTFxUM",
        "slots": [1, 2],
        "timestamp": null
      },
      "subscription": 0
    }
  }
  ```
</ResponseExample>


# voteUnsubscribe
Source: https://www.helius.dev/docs/api-reference/rpc/websocket/voteunsubscribe

Unsubscribe from vote notifications.

## Endpoints

Websockets are available on mainnet and devnet with the following URLs:

* **Mainnet** `wss://mainnet.helius-rpc.com/?api-key=<API_KEY>`
* **Devnet** `wss://devnet.helius-rpc.com/?api-key=<API_KEY>`

<Note>Websockets have a 10-minute inactivity timer; implementing health checks and sending pings every minute is heavily recommended to keep the websocket connection alive.</Note>

## Authorizations

<ParamField query="api-key" type="string" required>
  Your Helius API key. You can get one for free in the [dashboard](https://dashboard.helius.dev/api-keys).
</ParamField>

## Body

<ParamField body="params" type="array" required>
  <Expandable title="properties" defaultOpen>
    <ParamField body="subscriptionId" type="integer" required>
      Subscription id to cancel.
    </ParamField>
  </Expandable>
</ParamField>

## Response

<ResponseField name="result" type="boolean">
  Unsubscribe success message.
</ResponseField>

<RequestExample>
  ```json Request
  {
    "jsonrpc": "2.0",
    "id": 1,
    "method": "voteUnsubscribe",
    "params": [
      0
    ]
  }
  ```
</RequestExample>

<ResponseExample>
  ```json Response
  {
    "jsonrpc": "2.0",
    "result": true,
    "id": 1
  }
  ```
</ResponseExample>


# queryMetadataV1 (deprecated)
Source: https://www.helius.dev/docs/api-reference/token-metadata/querymetadatav1

openapi/openapi-definition.yaml post /v0/token-metadata



# Webhooks API
Source: https://www.helius.dev/docs/api-reference/webhooks

This page provides an overview of all available webhook endpoints that can be used to receive real-time updates from the API.

<Note>
  We recommend using our SDK to interact with webhooks. You can find the SDK documentation [here](/sdks).
</Note>

<CardGroup cols={2}>
  <Card title="Create Webhook" href="/api-reference/webhooks/create-webhook">
    Creates a new webhook to receive notifications for specified events.
  </Card>

  <Card title="Get Webhook" href="/api-reference/webhooks/get-webhook">
    Retrieves information about a specific webhook by its ID.
  </Card>

  <Card title="Update Webhook" href="/api-reference/webhooks/update-webhook">
    Updates the configuration of an existing webhook.
  </Card>

  <Card title="Delete Webhook" href="/api-reference/webhooks/delete-webhook">
    Deletes a specific webhook by its ID.
  </Card>

  <Card title="Get All Webhooks" href="/api-reference/webhooks/get-all-webhooks">
    Returns a list of all webhooks for your account.
  </Card>
</CardGroup>


# Create Webhook
Source: https://www.helius.dev/docs/api-reference/webhooks/create-webhook

openapi/webhooks.yaml post /v0/webhooks
Create a new webhook for real-time Solana blockchain notifications. Configure triggers 
based on addresses, transaction types, or specific on-chain events. Customize delivery 
options and notification formatting for seamless integration with your application.




# Delete Webhook
Source: https://www.helius.dev/docs/api-reference/webhooks/delete-webhook

openapi/webhooks.yaml delete /v0/webhooks/{webhookID}
Permanently remove a webhook configuration from your account. Immediately stop
receiving notifications for the specified webhook trigger conditions and free up
resources for other webhook configurations.




# Get All Webhooks
Source: https://www.helius.dev/docs/api-reference/webhooks/get-all-webhooks

openapi/webhooks.yaml get /v0/webhooks
Retrieve a complete list of all configured webhooks for your API key with detailed
configuration information including trigger conditions, delivery endpoints, and status.




# Get Webhook
Source: https://www.helius.dev/docs/api-reference/webhooks/get-webhook

openapi/webhooks.yaml get /v0/webhooks/{webhookID}
Retrieve detailed information about a specific webhook configuration by its unique ID.
Access complete webhook settings including trigger conditions, delivery endpoints, and status metrics.




# Update Webhook
Source: https://www.helius.dev/docs/api-reference/webhooks/update-webhook

openapi/webhooks.yaml put /v0/webhooks/{webhookID}
Update an existing webhook configuration with new trigger conditions, delivery endpoints,
or notification formatting. Modify your real-time blockchain notification settings to adapt
to changing application requirements without service interruption.




# ZK Compression API
Source: https://www.helius.dev/docs/api-reference/zk-compression

This page provides an overview of all available ZK compression API endpoints for working with compressed data on Solana.

<CardGroup cols={2}>
  <Card title="Get Compressed Account" href="/api-reference/zk-compression/getcompressedaccount">
    Retrieves information about a specific compressed account by its address or hash.
  </Card>

  <Card title="Get Compressed Account Proof" href="/api-reference/zk-compression/getcompressedaccountproof">
    Fetches a proof for a specific compressed account.
  </Card>

  <Card title="Get Compressed Accounts By Owner" href="/api-reference/zk-compression/getcompressedaccountsbyowner">
    Returns all compressed accounts owned by a specific address.
  </Card>

  <Card title="Get Compressed Balance" href="/api-reference/zk-compression/getcompressedbalance">
    Retrieves the balance of a compressed account.
  </Card>

  <Card title="Get Compressed Balance By Owner" href="/api-reference/zk-compression/getcompressedbalancebyowner">
    Gets the total balance of all compressed accounts owned by an address.
  </Card>

  <Card title="Get Compressed Mint Token Holders" href="/api-reference/zk-compression/getcompressedminttokenholders">
    Lists all holders of a specific compressed token mint.
  </Card>

  <Card title="Get Compressed Token Account Balance" href="/api-reference/zk-compression/getcompressedtokenaccountbalance">
    Retrieves the token balance of a compressed token account.
  </Card>

  <Card title="Get Compressed Token Accounts By Delegate" href="/api-reference/zk-compression/getcompressedtokenaccountsbydelegate">
    Returns all compressed token accounts delegated to a specific address.
  </Card>

  <Card title="Get Compressed Token Accounts By Owner" href="/api-reference/zk-compression/getcompressedtokenaccountsbyowner">
    Lists all compressed token accounts owned by a specific address.
  </Card>

  <Card title="Get Compressed Token Balances By Owner" href="/api-reference/zk-compression/getcompressedtokenbalancesbyowner">
    Retrieves all token balances for compressed accounts owned by an address.
  </Card>

  <Card title="Get Compressed Token Balances By Owner V2" href="/api-reference/zk-compression/getcompressedtokenbalancesbyownerv2">
    Enhanced version of the token balances endpoint with additional features.
  </Card>

  <Card title="Get Compression Signatures For Account" href="/api-reference/zk-compression/getcompressionsignaturesforaccount">
    Returns signatures for transactions involving a compressed account.
  </Card>

  <Card title="Get Compression Signatures For Address" href="/api-reference/zk-compression/getcompressionsignaturesforaddress">
    Retrieves signatures for transactions involving a specific address.
  </Card>

  <Card title="Get Compression Signatures For Owner" href="/api-reference/zk-compression/getcompressionsignaturesforowner">
    Returns signatures for transactions where an address is the owner.
  </Card>

  <Card title="Get Compression Signatures For Token Owner" href="/api-reference/zk-compression/getcompressionsignaturesfortokenowner">
    Lists signatures for transactions involving tokens owned by an address.
  </Card>

  <Card title="Get Indexer Health" href="/api-reference/zk-compression/getindexerhealth">
    Returns the health status of the compression indexer.
  </Card>

  <Card title="Get Indexer Slot" href="/api-reference/zk-compression/getindexerslot">
    Retrieves the current slot of the compression indexer.
  </Card>

  <Card title="Get Latest Compression Signatures" href="/api-reference/zk-compression/getlatestcompressionsignatures">
    Returns the most recent transaction signatures related to compression.
  </Card>

  <Card title="Get Latest Non-Voting Signatures" href="/api-reference/zk-compression/getlatestnonvotingsignatures">
    Retrieves recent non-voting transaction signatures.
  </Card>

  <Card title="Get Multiple Compressed Account Proofs" href="/api-reference/zk-compression/getmultiplecompressedaccountproofs">
    Fetches proofs for multiple compressed accounts in a single request.
  </Card>

  <Card title="Get Multiple Compressed Accounts" href="/api-reference/zk-compression/getmultiplecompressedaccounts">
    Retrieves multiple compressed accounts in a single request.
  </Card>

  <Card title="Get Multiple New Address Proofs" href="/api-reference/zk-compression/getmultiplenewaddressproofs">
    Fetches proofs for multiple new addresses.
  </Card>

  <Card title="Get Multiple New Address Proofs V2" href="/api-reference/zk-compression/getmultiplenewaddressProofsv2">
    Enhanced version of the multiple new address proofs endpoint.
  </Card>

  <Card title="Get Transaction With Compression Info" href="/api-reference/zk-compression/gettransactionwithcompressioninfo">
    Returns transaction details with additional compression-related information.
  </Card>

  <Card title="Get Validity Proof" href="/api-reference/zk-compression/getvalidityproof">
    Retrieves a validity proof for compressed data.
  </Card>
</CardGroup>


# getCompressedAccount
Source: https://www.helius.dev/docs/api-reference/zk-compression/getcompressedaccount

openapi/zk-compression/getCompressedAccount.yaml post /
Returns the compressed account with the given address or hash.



# getCompressedAccountProof
Source: https://www.helius.dev/docs/api-reference/zk-compression/getcompressedaccountproof

openapi/zk-compression/getCompressedAccountProof.yaml post /
Returns a proof the compression program uses to verify that the account is valid.



# getCompressedAccountsByOwner
Source: https://www.helius.dev/docs/api-reference/zk-compression/getcompressedaccountsbyowner

openapi/zk-compression/getCompressedAccountsByOwner.yaml post /
Returns the owner's compressed accounts.



# getCompressedBalance
Source: https://www.helius.dev/docs/api-reference/zk-compression/getcompressedbalance

openapi/zk-compression/getCompressedBalance.yaml post /
Returns the balance for the compressed account with the given address or hash.



# getCompressedBalanceByOwner
Source: https://www.helius.dev/docs/api-reference/zk-compression/getcompressedbalancebyowner

openapi/zk-compression/getCompressedBalanceByOwner.yaml post /
Returns the total balance of the owner's compressed accounts.



# getCompressedMintTokenHolders
Source: https://www.helius.dev/docs/api-reference/zk-compression/getcompressedminttokenholders

openapi/zk-compression/getCompressedMintTokenHolders.yaml post /
Returns the owner balances for a given mint in descending order.



# getCompressedTokenAccountBalance
Source: https://www.helius.dev/docs/api-reference/zk-compression/getcompressedtokenaccountbalance

openapi/zk-compression/getCompressedTokenAccountBalance.yaml post /
Returns the balance for a given token account.



# getCompressedTokenAccountsByDelegate
Source: https://www.helius.dev/docs/api-reference/zk-compression/getcompressedtokenaccountsbydelegate

openapi/zk-compression/getCompressedTokenAccountsByDelegate.yaml post /
Returns the compressed token accounts that are partially or fully delegated to the given delegate.



# getCompressedTokenAccountsByOwner
Source: https://www.helius.dev/docs/api-reference/zk-compression/getcompressedtokenaccountsbyowner

openapi/zk-compression/getCompressedTokenAccountsByOwner.yaml post /
Returns the compressed token accounts owned by a certain account.



# getCompressedTokenBalancesByOwner
Source: https://www.helius.dev/docs/api-reference/zk-compression/getcompressedtokenbalancesbyowner

openapi/zk-compression/getCompressedTokenBalancesByOwner.yaml post /
Returns the token balances for a given owner.



# getCompressedTokenBalancesByOwnerV2
Source: https://www.helius.dev/docs/api-reference/zk-compression/getcompressedtokenbalancesbyownerv2

openapi/zk-compression/getCompressedTokenBalancesByOwnerV2.yaml post /
Returns the token balances for a given owner. The V2 version solves a minor naming issue. .



# getCompressionSignaturesForAccount
Source: https://www.helius.dev/docs/api-reference/zk-compression/getcompressionsignaturesforaccount

openapi/zk-compression/getCompressionSignaturesForAccount.yaml post /
Return the signatures of the transactions that closed or opened a compressed account with the given hash.



# getCompressionSignaturesForAddress
Source: https://www.helius.dev/docs/api-reference/zk-compression/getcompressionsignaturesforaddress

openapi/zk-compression/getCompressionSignaturesForAddress.yaml post /
Return the signatures of the transactions that closed or opened a compressed account with the given address.



# getCompressionSignaturesForOwner
Source: https://www.helius.dev/docs/api-reference/zk-compression/getcompressionsignaturesforowner

openapi/zk-compression/getCompressionSignaturesForOwner.yaml post /
Returns the signatures of the transactions that have modified an owner's compressed accounts.



# getCompressionSignaturesForTokenOwner
Source: https://www.helius.dev/docs/api-reference/zk-compression/getcompressionsignaturesfortokenowner

openapi/zk-compression/getCompressionSignaturesForTokenOwner.yaml post /
Returns the signatures of the transactions that have modified an owner's compressed token accounts.



# getIndexerHealth
Source: https://www.helius.dev/docs/api-reference/zk-compression/getindexerhealth

openapi/zk-compression/getIndexerHealth.yaml post /
Returns an error if the indexer is stale by more than a configurable number of blocks. Otherwise, it returns `ok`.



# getIndexerSlot
Source: https://www.helius.dev/docs/api-reference/zk-compression/getindexerslot

openapi/zk-compression/getIndexerSlot.yaml post /
Returns the slot of the last block indexed by the indexer.



# getLatestCompressionSignatures
Source: https://www.helius.dev/docs/api-reference/zk-compression/getlatestcompressionsignatures

openapi/zk-compression/getLatestCompressionSignatures.yaml post /
Returns the signatures of the latest transactions that used the compression program.



# getLatestNonVotingSignatures
Source: https://www.helius.dev/docs/api-reference/zk-compression/getlatestnonvotingsignatures

openapi/zk-compression/getLatestNonVotingSignatures.yaml post /
Returns the signatures of the latest transactions that are not voting transactions.



# getMultipleCompressedAccountProofs
Source: https://www.helius.dev/docs/api-reference/zk-compression/getmultiplecompressedaccountproofs

openapi/zk-compression/getMultipleCompressedAccountProofs.yaml post /
Returns multiple proofs used by the compression program to verify the accounts' validity.



# getMultipleCompressedAccounts
Source: https://www.helius.dev/docs/api-reference/zk-compression/getmultiplecompressedaccounts

openapi/zk-compression/getMultipleCompressedAccounts.yaml post /
Returns multiple compressed accounts with the given addresses or hashes.



# getMultipleNewAddressProofsV2
Source: https://www.helius.dev/docs/api-reference/zk-compression/getmultiplenewaddressProofsv2

openapi/zk-compression/getMultipleNewAddressProofsV2.yaml post /
Returns proofs that the new addresses are not taken already and can be created.



# getMultipleNewAddressProofs
Source: https://www.helius.dev/docs/api-reference/zk-compression/getmultiplenewaddressproofs

openapi/zk-compression/getMultipleNewAddressProofs.yaml post /
Returns proofs that the new addresses are not taken already and can be created.



# getTransactionWithCompressionInfo
Source: https://www.helius.dev/docs/api-reference/zk-compression/gettransactionwithcompressioninfo

openapi/zk-compression/getTransactionWithCompressionInfo.yaml post /
Returns the transaction data for the transaction with the given signature along with parsed compression info.



# getValidityProof
Source: https://www.helius.dev/docs/api-reference/zk-compression/getvalidityproof

openapi/zk-compression/getValidityProof.yaml post /
Returns a single ZK Proof used by the compression program to verify that the given accounts are valid and that the new addresses can be created.



# Helius Autoscaling & Prepaid Credits: Uninterrupted Service
Source: https://www.helius.dev/docs/billing/autoscaling

Set up Helius autoscaling and prepaid credits to ensure uninterrupted Solana API service. Automatic credit purchases, cost management, and seamless scaling.

Autoscaling allows your project to automatically purchase additional credits when you exhaust your monthly allocation, ensuring your applications continue running without interruption.

## How Autoscaling Works

When enabled, autoscaling automatically purchases additional credits in predefined increments when your usage reaches certain thresholds. This prevents service interruptions and maintains consistent performance for your applications.

## Setting Up Autoscaling

Autoscaling can be configured in the Project Settings on your dashboard:

1. Navigate to your [Helius Dashboard](https://dashboard.helius.dev/) and select your project
2. Go to **Project Settings**
3. Find the Autoscaling section
4. Toggle autoscaling on
5. Save your settings

![Autoscaling Limit](https://mintlify.s3.us-west-1.amazonaws.com/helius/images/autoscaling-limit.png)

<Note>
  Autoscaling is capped for Developer and Business plans to help manage costs and avoid unexpected charges. If you require unlimited autoscaling, consider upgrading to the **Professional** plan.
</Note>

## Payment Options for Additional Credits

### Card Payment Plans

For projects using credit/debit card payments, autoscaling is the recommended method for handling additional credit needs. When enabled, additional credits will be automatically charged to your payment method.

### Crypto Plans

If you're using cryptocurrency for payments, you'll need to purchase prepaid credits instead of using autoscaling:

1. Log into your [Helius Dashboard](https://dashboard.helius.dev/)
2. Select **Buy More Credits**
3. Complete the purchase with your preferred crypto payment method

![Prepaid Credits Button](https://mintlify.s3.us-west-1.amazonaws.com/helius/images/prepaid-credits-button-helius-dashboard.jpg)

<Note>
  Prepaid credits activate immediately and never expireyou keep them until they run out.
</Note>

## Pricing for Additional Credits

Additional credit pricing depends on your current plan:

| Plan Type    | Price per Million Additional Credits |
| ------------ | ------------------------------------ |
| Developer    | \$5 per million                      |
| Business     | \$5 per million                      |
| Professional | \$4 per million                      |

If you're consistently going over your limit, consider upgrading your plan for better rates and unlimited autoscaling.

## Notifications and Tracking Credit Usage

Helius keeps you informed about your credit usage to help manage your spend:

* **Email Alerts**: You'll receive notifications via email when you're approaching your credit limits and when autoscaling occurs.
* **Dashboard Tracking**: Check your current credit usage and historical data directly from your [Dashboard](https://dashboard.helius.dev/). Navigate to the **Usage** section to see detailed analytics.

![Helius Credit Usage Dashboard](https://mintlify.s3.us-west-1.amazonaws.com/helius/images/helius-credit-usage-dashboard.jpg)

## Autoscaling Limits and Enterprise Options

* **Developer and Business plans**: Autoscaling is available but has predefined caps to avoid unexpectedly large bills.
* **Professional plans**: Autoscaling is unlimitedideal for rapidly scaling projects.
* **Enterprise plans**: For credit needs exceeding 1B/month, set up an Enterprise plan tailored to your requirements.

For more detailed information about credits and pricing, please visit our [Credits](/billing/credits) and [Plans & Rate Limits](/billing/plans-and-rate-limits) pages.


# Pay for Helius Solana Plans with Crypto
Source: https://www.helius.dev/docs/billing/pay-with-crypto

Purchase Helius Solana API plans with cryptocurrency. USDC payments, automatic renewals, and easy setup guide for crypto subscription billing.

## Getting Started with Crypto Payments

Helius allows you to buy plans using USDC. You can secure your subscription in just one straightforward transactionno hassle. Below, you'll find an easy-to-follow guide on how to get started.

![Pay with Crypto](https://mintlify.s3.us-west-1.amazonaws.com/helius/images/pay-with-crypto.png)

***

### Purchasing a Plan with Crypto

<Steps>
  <Step title="Navigate to the Billing Page">
    Go to [https://dashboard.helius.dev/billing](https://dashboard.helius.dev/billing) and select the subscription plan that fits your needs (e.g., Business). Choose either **monthly** or **annual** billing.
  </Step>

  <Step title="Initiate Crypto Payment">
    Click **Pay with Crypto** and connect your preferred wallet.
  </Step>

  <Step title="Enter Billing Information">
    Provide your **name** and **billing address**.
  </Step>

  <Step title="Authorize Automatic Withdrawals">
    By authorizing, you consent to allow automatic deductions of USDC from your wallet at each billing period. Learn more about [automatic withdrawals](#what-does-authorize-automatic-withdrawals-mean).
  </Step>

  <Step title="Confirm Payment">
    Click **Pay with USDC** and wait for your transaction to process. Once it's complete, your new plan will be active!
  </Step>
</Steps>

<Note>
  **Important Notes**:

  * **Prepare Your Wallet for Auto-Renewal**: Your wallet must have sufficient funds for upcoming billing periods.
  * **Automatic Withdrawals**: Funds will be automatically deducted from your wallet at each billing cycle.
  * **Manage Permissions**: You can revoke permissions or change your wallet anytime.
  * **Cancel Anytime**: You can cancel your subscription if needed.
</Note>

***

## Frequently Asked Questions

<AccordionGroup>
  <Accordion title="I want to switch between fiat and crypto payments.">
    Please contact our [support](https://dashboard.helius.dev/support) team, and they will assist you with changing your payment method.
  </Accordion>

  <Accordion title="I paid for a plan, but it hasn't been updated yet in my dashboard.">
    It can take up to **1 hour** for the system to update your plan. If it still doesn't update after that, reach out to our [support](https://dashboard.helius.dev/support) team.
  </Accordion>

  <Accordion title="How do I cancel my subscription?">
    You can cancel by going to the [**Billing**](https://dashboard.helius.dev/billing) page and clicking the **Cancel Subscription** button.
  </Accordion>

  <Accordion title="What does 'Authorize Automatic Withdrawals' mean?">
    When you authorize automatic withdrawals, you're giving the platform permission to pull the necessary amount of USDC (on Solana) directly from your wallet whenever a new billing period starts. This is often referred to as a "subscription" or "recurring payment," where you don't have to manually approve each individual charge.

    * **How It Works:**
      * At the beginning of each billing cycle, the system checks if you have enough USDC in your Solana wallet.
      * If sufficient funds are available, the required amount is automatically deducted to cover the plan's cost.
      * If you ever want to stop automatic charges, you can revoke this authorization via your wallet or billing settings.
    * **Why Authorize?**
      * It saves you from having to manually make a payment every month (or billing period).
      * It ensures your service continues without interruption, as the payment is handled automatically.
    * **Things to Keep in Mind:**
      * **Sufficient Funds:** Make sure your wallet has enough USDC ahead of each billing date.
      * **Revoking Authorization:** You can usually disable or revoke this automatic withdrawal at any time if you decide you'd rather pay manually.
  </Accordion>

  <Accordion title="How can I manually pay for my subscription instead of authorizing payments?">
    Manual payments are not supported. You must authorize USDC so it can be automatically deducted on billing days. However, you can **revoke** this authorization after each purchase by following these steps:

    1. Go to the [**Billing**](https://dashboard.helius.dev/billing) page and click **Manage Delegate Wallet** (this will redirect you to Loop).
    2. Select your plan (e.g., Developer).
    3. Click **Edit** in the Authorization section.
    4. Set the limit to **0** to revoke authorization.
  </Accordion>
</AccordionGroup>


# Helius Pricing Plans, Rate Limits & Credit System
Source: https://www.helius.dev/docs/billing/plans-and-rate-limits

Complete guide to Helius Solana API pricing with free tier. Transparent plans, rate limits, and credit system for developers and enterprise.

<Info>
  Access our RPC node fleet across **Pittsburgh, Newark, Salt Lake City, Los Angeles, Vancouver, Dublin, London, Amsterdam, Frankfurt, Singapore, and Tokyo**, with automatic routing to the nearest node.
</Info>

## Quick Start

<CardGroup cols={2}>
  <Card title="Choose Your Plan" icon="credit-card" href="#pricing-plans">
    Compare plans and find the right fit for your needs
  </Card>

  <Card title="Understand Credits" icon="calculator" href="#credit-system">
    Learn how our credit-based billing system works
  </Card>

  <Card title="Rate Limits Guide" icon="gauge" href="#rate-limits">
    Understand request limits and exceptions
  </Card>

  <Card title="Enterprise Solutions" icon="building" href="#enterprise">
    Custom solutions for high-volume applications
  </Card>
</CardGroup>

***

## Pricing Plans

<table>
  <thead align="left">
    <tr>
      <th width="160">Feature</th>
      <th width="140">Free</th>
      <th width="140">Developer</th>
      <th width="140">Business</th>
      <th width="140">Professional</th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td><strong>Pricing</strong></td>
      <td>\$0/month</td>
      <td>\$49/month</td>
      <td>\$499/month</td>
      <td>\$999/month</td>
    </tr>

    <tr>
      <td><strong>Monthly Credits</strong></td>
      <td>1M</td>
      <td>10M</td>
      <td>100M</td>
      <td>200M</td>
    </tr>

    <tr>
      <td><strong>RPC Rate Limit</strong></td>
      <td>10 req/s</td>
      <td>50 req/s</td>
      <td>200 req/s</td>
      <td>500 req/s</td>
    </tr>

    <tr>
      <td><strong>DAS & Enhanced APIs</strong></td>
      <td>2 req/s</td>
      <td>10 req/s</td>
      <td>50 req/s</td>
      <td>100 req/s</td>
    </tr>

    <tr>
      <td><strong>WebSockets</strong></td>
      <td>Standard</td>
      <td>Standard</td>
      <td>Standard + Enhanced</td>
      <td>Standard + Enhanced</td>
    </tr>

    <tr>
      <td><strong>gRPC Access</strong></td>
      <td></td>
      <td></td>
      <td></td>
      <td>LaserStream</td>
    </tr>

    <tr>
      <td><strong>Support Level</strong></td>
      <td>Community</td>
      <td>Chat</td>
      <td>Priority Chat</td>
      <td>Slack/Telegram</td>
    </tr>
  </tbody>
</table>

<Note>
  If you're on a legacy plan, see the [Legacy Plan Details](#legacy-plans) section below.
</Note>

<CardGroup cols={2}>
  <Card title="Get Started Today" icon="rocket" href="https://dashboard.helius.dev/dashboard">
    Sign up for free and start building with 1M credits per month. Upgrade anytime as you scale.
  </Card>

  <Card title="Need Enterprise Solutions?" icon="building" href="https://form.typeform.com/to/KiacmxpZ">
    Contact our sales team for custom pricing, dedicated support, and enterprise features.
  </Card>
</CardGroup>

## Add-On Plans

### LaserStream Plus

<Card title="LaserStream 50TB Add-On" icon="bolt">
  **\$2,500/month** - Supercharge your Professional plan for ultra-high throughput streaming

  **How it works:**

  * Professional plan: Pay **3 credits per 0.1MB** for all LaserStream usage
  * Add-on provides **50 TB included bandwidth** each month
  * After your 50 TB runs out: Pay **1 credit per 0.1MB** (67% cheaper than Professional's 3 credits)
  * All other Professional plan features included

  **Perfect for:** High-frequency trading bots, portfolio trackers, DEX aggregators, and real-time analytics platforms.
</Card>

***

## Rate Limits

<Info>
  Rate limits control how many requests you can make per second. When exceeded, you'll receive an HTTP 429 response.
</Info>

### Standard Rate Limits

Your plan determines your base rate limits:

<table>
  <thead align="left">
    <tr>
      <th width="200">Plan</th>
      <th width="150">RPC Rate Limit</th>
      <th width="200">DAS & Enhanced APIs</th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td><strong>Free</strong></td>
      <td>10 requests/s</td>
      <td>2 requests/s</td>
    </tr>

    <tr>
      <td><strong>Developer</strong></td>
      <td>50 requests/s</td>
      <td>10 requests/s</td>
    </tr>

    <tr>
      <td><strong>Business</strong></td>
      <td>200 requests/s</td>
      <td>50 requests/s</td>
    </tr>

    <tr>
      <td><strong>Professional</strong></td>
      <td>500 requests/s</td>
      <td>100 requests/s</td>
    </tr>
  </tbody>
</table>

### Special Endpoint Limits

Some endpoints have special restrictions due to their computational requirements:

<Tabs>
  <Tab title="Transactions">
    <table>
      <thead align="left">
        <tr>
          <th width="200">Endpoint</th>
          <th width="100">Free</th>
          <th width="100">Developer</th>
          <th width="100">Business</th>
          <th width="100">Professional</th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td><code>Sender</code></td>
          <td>3/sec</td>
          <td>3/sec</td>
          <td>3/sec</td>
          <td>3/sec</td>
        </tr>

        <tr>
          <td><code>sendTransaction</code></td>
          <td>1/sec</td>
          <td>5/sec</td>
          <td>50/sec</td>
          <td>100/sec</td>
        </tr>

        <tr>
          <td><code>simulateBundle</code></td>
          <td>10/sec</td>
          <td>50/sec</td>
          <td>200/sec</td>
          <td>500/sec</td>
        </tr>
      </tbody>
    </table>

    <Note>
      **Need Higher Sender Limits?** Contact support to discuss custom rate limits based on your specific use case requirements.
    </Note>
  </Tab>

  <Tab title="High Complexity Calls">
    <table>
      <thead align="left">
        <tr>
          <th width="200">Endpoint</th>
          <th width="100">Free</th>
          <th width="100">Developer</th>
          <th width="100">Business</th>
          <th width="100">Professional</th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td><code>getProgramAccounts</code></td>
          <td>5/sec</td>
          <td>25/sec</td>
          <td>50/sec</td>
          <td>75/sec</td>
        </tr>
      </tbody>
    </table>
  </Tab>

  <Tab title="ZK Compression">
    <table>
      <thead align="left">
        <tr>
          <th width="200">Service</th>
          <th width="100">Free</th>
          <th width="100">Developer</th>
          <th width="100">Business</th>
          <th width="100">Professional</th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>Photon APIs</td>
          <td>2/sec</td>
          <td>10/sec</td>
          <td>50/sec</td>
          <td>100/sec</td>
        </tr>

        <tr>
          <td><code>getValidityProof</code></td>
          <td>1/sec</td>
          <td>5/sec</td>
          <td>10/sec</td>
          <td>20/sec</td>
        </tr>
      </tbody>
    </table>
  </Tab>

  <Tab title="LaserStream">
    <table>
      <thead align="left">
        <tr>
          <th width="200">Resource</th>
          <th width="100">Free</th>
          <th width="100">Developer</th>
          <th width="100">Business</th>
          <th width="100">Professional</th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>Max Pubkeys</td>
          <td></td>
          <td></td>
          <td></td>
          <td>10M</td>
        </tr>

        <tr>
          <td>Active Connections</td>
          <td></td>
          <td></td>
          <td></td>
          <td>100</td>
        </tr>
      </tbody>
    </table>
  </Tab>
</Tabs>

## Credit System

<CardGroup cols={3}>
  <Card title="Monthly Allocation" icon="calendar">
    Your plan includes credits that reset monthly
  </Card>

  <Card title="Usage Priority" icon="arrow-down">
    Monthly  Prepaid  Autoscaling
  </Card>

  <Card title="Flexible Billing" icon="credit-card">
    Pay for additional credits only when needed
  </Card>
</CardGroup>

### Credit Costs

<table>
  <thead>
    <tr>
      <th style={{width: '300px'}}>Service</th>
      <th style={{width: '100px', textAlign: 'center'}}>Credits</th>
      <th>Notes</th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td><strong>Standard RPC Calls</strong></td>
      <td style={{textAlign: 'center'}}>1</td>
      <td>All RPC calls except those listed separately</td>
    </tr>

    <tr>
      <td><strong>simulateBundle</strong></td>
      <td style={{textAlign: 'center'}}>1</td>
      <td>Simulate Jito Bundles</td>
    </tr>

    <tr>
      <td><strong>Priority Fee API</strong></td>
      <td style={{textAlign: 'center'}}>1</td>
      <td>Estimate priority fees</td>
    </tr>

    <tr>
      <td><strong>Webhook Events</strong></td>
      <td style={{textAlign: 'center'}}>1</td>
      <td>For each message pushed</td>
    </tr>

    <tr>
      <td><strong>LaserStream gRPC</strong></td>
      <td style={{textAlign: 'center'}}>3</td>
      <td>Per 0.1MB of streamed data</td>
    </tr>

    <tr>
      <td><strong>LaserStream 50TB Add-on</strong></td>
      <td style={{textAlign: 'center'}}>1</td>
      <td>Per 0.1MB after 50TB free (included with add-on)</td>
    </tr>

    <tr>
      <td><strong>getProgramAccounts</strong></td>
      <td style={{textAlign: 'center'}}>10</td>
      <td>Get all accounts/data owned by a program</td>
    </tr>

    <tr>
      <td><strong>ZK Compression API</strong></td>
      <td style={{textAlign: 'center'}}>10</td>
      <td>ZK Compression RPC calls</td>
    </tr>

    <tr>
      <td><strong>DAS API</strong></td>
      <td style={{textAlign: 'center'}}>10</td>
      <td>All DAS endpoints</td>
    </tr>

    <tr>
      <td><strong>Enhanced Transactions</strong></td>
      <td style={{textAlign: 'center'}}>100</td>
      <td>Enhanced transaction parsing</td>
    </tr>

    <tr>
      <td><strong>Webhook Management</strong></td>
      <td style={{textAlign: 'center'}}>100</td>
      <td>Create, edit, delete webhooks</td>
    </tr>

    <tr>
      <td><strong>getValidityProofs</strong></td>
      <td style={{textAlign: 'center'}}>100</td>
      <td>Compute ZK proofs</td>
    </tr>
  </tbody>
</table>

<Note>
  **LaserStream Billing Guide**:

  * **Professional Plan**: Pay 3 credits per 0.1MB for all LaserStream usage (no included bandwidth).
  * **LaserStream Plus Add-on**: Includes 50 TB monthly bandwidth. After that, pay only 1 credit per 0.1MB (67% savings).
  * **Data Size**: Billing based on uncompressed gRPC message size. Typical sizes: Block (\~4MB), Account (\~0.0004MB), Transaction (\~0.0006MB).

  **Webhook Billing**: You are charged 1 credit when Helius processes and sends a webhook event to your endpoint. This charge applies regardless of whether your endpoint successfully receives or processes the webhook.
</Note>

<Tabs>
  <Tab title="Transaction Submission">
    <table>
      <thead>
        <tr>
          <th style={{width: '300px'}}>Method</th>
          <th style={{width: '100px', textAlign: 'center'}}>Credits</th>
          <th>Description</th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td><strong>Sender</strong></td>
          <td style={{textAlign: 'center'}}>0</td>
          <td>Ultra-low latency submission</td>
        </tr>

        <tr>
          <td><strong>Unstaked Connections</strong></td>
          <td style={{textAlign: 'center'}}>1</td>
          <td>May be unreliable during congestion</td>
        </tr>

        <tr>
          <td><strong>Staked Connections</strong></td>
          <td style={{textAlign: 'center'}}>10</td>
          <td>Highest reliability (default)</td>
        </tr>
      </tbody>
    </table>

    <Info>
      **Staked Transactions Are Now Default**: All transactions via `mainnet.helius-rpc.com` automatically use staked connections for highest success rates.
    </Info>
  </Tab>

  <Tab title="Historical Data">
    All archival calls cost **10 credits** each:

    <CardGroup cols={2}>
      <Card title="Block Data">
        * `getBlock`
        * `getBlocks`
        * `getBlockTime`
      </Card>

      <Card title="Transaction History">
        * `getTransaction`
        * `getSignaturesForAddress`
        * `getInflationReward`
      </Card>
    </CardGroup>
  </Tab>

  <Tab title="DAS API">
    All DAS API calls cost **10 credits** each:

    <CardGroup cols={2}>
      <Card title="Asset Information">
        * `getAsset`
        * `getAssetProof`
        * `getAssetProofBatch`
        * `getNftEditions`
      </Card>

      <Card title="Asset Discovery">
        * `getAssetsByOwner`
        * `getAssetsByAuthority`
        * `getAssetsByCreator`
        * `getAssetsByGroup`
        * `searchAssets`
        * `getAssetBatch`
      </Card>

      <Card title="Transaction History">
        * `getSignaturesForAsset`
      </Card>

      <Card title="Account Information">
        * `getTokenAccounts`
      </Card>
    </CardGroup>
  </Tab>
</Tabs>

***

## Managing Your Usage

<CardGroup cols={2}>
  <Card title="Autoscaling" icon="arrow-trend-up" href="/billing/autoscaling">
    Automatically add credits as needed for handling traffic spikes and ensuring uninterrupted service.
  </Card>

  <Card title="Helius Dashboard" icon="chart-line" href="https://dashboard.helius.dev/">
    Monitor real-time usage, set alerts, and track consumption patterns with detailed analytics.
  </Card>
</CardGroup>

***

## Enterprise

<Card title="Custom Solutions for High-Volume Applications" icon="building">
  Enterprise plans provide tailored solutions for organizations with specific requirements.

  **Key Benefits:**

  * Custom rate limits tailored to your needs
  * Volume discounts for high credit usage
  * SLA guarantees with uptime commitments
  * Direct engineering support access
  * Advanced usage analytics and monitoring
  * Priority support channels

  Ready for Enterprise? [Contact our sales team](https://form.typeform.com/to/KiacmxpZ) to discuss custom solutions.
</Card>

***

## Legacy Plans

<Warning>
  The limits below apply to deprecated V3 plans. These plans are no longer available for new users.
</Warning>

<Accordion title="Legacy V3 Plan Details">
  <table>
    <thead align="left">
      <tr>
        <th width="189">Free V3</th>
        <th width="181">Developer V3</th>
        <th width="191">Business V3</th>
        <th>Performance V3</th>
      </tr>
    </thead>

    <tbody>
      <tr>
        <td>1M Credits</td>
        <td>10M Credits</td>
        <td>200M Credits</td>
        <td>500M Credits</td>
      </tr>

      <tr>
        <td>10 RPC requests/s</td>
        <td>50 RPC requests/s</td>
        <td>150 RPC requests/s</td>
        <td>500 RPC requests/s</td>
      </tr>

      <tr>
        <td>2 API requests/s</td>
        <td>10 API requests/s</td>
        <td>50 API requests/s</td>
        <td>100 API requests/s</td>
      </tr>

      <tr>
        <td>1 API Key</td>
        <td>10 API Keys</td>
        <td>15 API Keys</td>
        <td>20 API Keys</td>
      </tr>

      <tr>
        <td>1 Webhook</td>
        <td>3 Webhooks</td>
        <td>10 Webhooks</td>
        <td>20 Webhooks</td>
      </tr>

      <tr>
        <td>Community support</td>
        <td>Chat Support</td>
        <td>Priority Chat Support</td>
        <td>Slack/Telegram Support</td>
      </tr>
    </tbody>
  </table>
</Accordion>


# Helius Changelog: Latest Updates & Features
Source: https://www.helius.dev/docs/changelog

Stay up-to-date with the latest Helius Solana API updates, new features, improvements, and changes. LaserStream, webhooks, RPC enhancements, and more.

# Changelog

Stay informed about the latest updates, new features, improvements, and changes to Helius APIs and services. We're constantly working to improve your developer experience and provide you with the best Solana infrastructure.

<Note>
  Want to stay updated? Join our [Discord community](https://discord.com/invite/6GXdee3gBj) for real-time announcements or follow us on [X](https://x.com/heliuslabs) for the latest updates.
</Note>

***

<Update label="June 2024">
  ## Transaction Sender Beta Launch

  **June 30, 2024**

  Our new transaction sender is now open to the public in beta with many more improvements to come.

  **Key Features:**

  * **Parallel Sending**: Simultaneous transmission to both Jito and Helius SWQOS, which has the highest stake on the network
  * **7 Regional Endpoints**: Network optimized endpoints to reduce latency
  * **Beta Access**: Available now through your dashboard

  **To Access:**
  Navigate to Dashboard  Sender (on the left sidebar)

  <Note>
    We'd love feedback to improve the sender as we're making active improvements every day.
  </Note>

  <CardGroup cols={2}>
    <Card title="Transaction Sender Guide" icon="paper-plane" href="/sending-transactions/sender">
      Learn how to use the new transaction sender
    </Card>

    <Card title="Sending Transactions Overview" icon="server" href="/sending-transactions/overview">
      Explore all transaction sending options
    </Card>
  </CardGroup>

  ## Jito Bundle Simulation Support

  **June 25, 2024**

  You can now use Helius RPCs for simulating Jito bundles, enabling you to test and validate your bundle transactions before submission.

  **What's New:**

  * **Bundle Simulation**: Test your Jito bundles using Helius infrastructure
  * **Pre-submission Validation**: Catch potential issues before sending bundles to the network
  * **Seamless Integration**: Works with existing Helius RPC endpoints

  <CardGroup cols={2}>
    <Card title="Simulate Bundle API" icon="code" href="/api-reference/rpc/http/simulatebundle">
      View the simulateBundle API documentation
    </Card>

    <Card title="RPC Methods" icon="server" href="/rpc/overview">
      Explore all available RPC methods
    </Card>
  </CardGroup>

  ## LaserStream Public Release

  **June 18, 2024**

  Today, Solana gets a huge upgrade. We are finally releasing LaserStream  the fastest, most reliable way of streaming Solana blocks, transactions, and account data via gRPC.

  **LaserStream Features:**

  * **Optimized Shredstream**: Receive data before anyone else
  * **Historical Replay & Persistence**: If you disconnect, start from the slot where you disconnected and never miss data
  * **Extreme Redundancy**: Powered by many redundant node clusters so you never worry about downtime or your stream falling behind
  * **Regional Endpoints**: Available in all major regions (Tokyo, Frankfurt, Newark, Pittsburgh, Salt Lake City, Amsterdam, Singapore)  no need to wait for node availability or buy an entire node
  * **Massive Scale**: Listen up to 250,000 addresses per connection; up to 100 simultaneous connections
  * **Ready-to-Go Client SDKs**: Optional SDKs available for easy integration
  * **gRPC Compatible**: Works with existing gRPC code

  **Getting Started:**

  * Have a professional Helius plan
  * Read the documentation
  * Open your dashboard and click LaserStream

  <Note>
    LaserStream-powered WebSocket streaming coming soon!
  </Note>

  <CardGroup cols={2}>
    <Card title="LaserStream Documentation" icon="bolt" href="/laserstream">
      Get started with LaserStream
    </Card>

    <Card title="LaserStream gRPC Guide" icon="code" href="/laserstream/grpc">
      Learn about LaserStream gRPC implementation
    </Card>
  </CardGroup>
</Update>

<Update label="May 2024">
  ## Staked Transactions Are the New Default

  **What's Changed:**

  * **Staked Connections Default**: Transactions sent through Helius now automatically use staked connections by default, providing you with the highest transaction landing rates and optimizing for speed and reliability. No code changes required.
  * **Pricing Update**: Staked connection pricing decreased from 50 to 10 credits per transaction, making it more cost-effective to use our premium transaction infrastructure.

  **Endpoint Changes:**

  * **Staked Endpoint**: The dedicated staked endpoint (`staked.helius-rpc.com`) is being phased out in favor of the regular endpoint which now uses staked connections by default. You can continue using the staked endpoint for now, but we recommend switching to the regular endpoint (`mainnet.helius-rpc.com`) for the best experience.

  **Alternative Options:**

  * **Unstaked Connections**: To continue using unstaked connections (1 credit per call), use `https://unstaked.helius-rpc.com`. Please note that unstaked connections may not be reliable during periods of network congestion.

  <CardGroup cols={2}>
    <Card title="Smart Transactions Guide" icon="paper-plane" href="/sending-transactions/smart-transactions">
      Learn more about our transaction optimization features
    </Card>

    <Card title="Staked Connections" icon="link" href="/sending-transactions/staked-connections">
      Understanding staked vs unstaked connections
    </Card>
  </CardGroup>
</Update>

<Update label="April 2024">
  ## Massive RPC Performance Improvements

  **Big news:** We've reduced latency on all Solana account-based RPC calls by up to 95%!

  **p95 improvements:**

  * [`getProgramAccounts`](/rpc/guides/getprogramaccounts)  95% faster
  * [`getAccountInfo`](/rpc/guides/getaccountinfo), [`getMultipleAccounts`](/rpc/guides/getmultipleaccounts), [`getBalance`](/rpc/guides/getbalance), [`getSlot`](/rpc/guides/getslot)  60% faster
  * [`getTokenAccountsByOwner`](/rpc/guides/gettokenaccountsbyowner)  50% faster

  **Steps to use it:** Nothing! If you use a shared and paid Helius subscription (i.e., not dedicated nodes), you get automatic access.

  **What this means for you:**

  * **Faster dApp loading times**: Account data fetches nearly instantly
  * **Better user experience**: Reduced waiting times for balance checks and token account queries
  * **More efficient development**: Faster iteration cycles when building and testing
  * **Improved scalability**: Handle more concurrent requests with the same infrastructure

  <CardGroup cols={2}>
    <Card title="RPC Optimization Techniques" icon="rocket" href="/rpc/optimization-techniques">
      Learn how to optimize your RPC usage
    </Card>

    <Card title="All RPC Methods" icon="server" href="/rpc/quickstart">
      Explore all available RPC endpoints
    </Card>
  </CardGroup>
</Update>

***

<Note>
  Have questions about any of these changes? Contact our support team at [support@helius.xyz](mailto:support@helius.xyz) or reach out in our [Discord community](https://discord.com/invite/6GXdee3gBj).
</Note>


# Solana DAS API: Unified NFT and Token Data Access
Source: https://www.helius.dev/docs/das-api

The most comprehensive Solana API for NFTs, compressed NFTs, and tokens. Unified interface for all digital assets with high performance and complete metadata.

<Note>
  **Quick Reference**: The DAS API provides a unified interface for all Solana assets. Use `getAsset` for single assets, `getAssetsByOwner` for wallet holdings, `searchAssets` for filtered queries, and specialized methods for compressed NFTs.
</Note>

## What is DAS?

The Digital Asset Standard (DAS) API is an open-source specification that provides a unified interface for interacting with all types of digital assets on Solana:

* Regular NFTs (Non-Fungible Tokens)
* Compressed NFTs (State Compression)
* Fungible Tokens (including SPL Tokens and Token-2022)
* Inscriptions and SPL-20 tokens (experimental)

<CardGroup cols={2}>
  <Card title="Mainnet Endpoint" icon="server">
    `https://mainnet.helius-rpc.com/?api-key=YOUR_API_KEY`
  </Card>

  <Card title="Devnet Endpoint" icon="server">
    `https://devnet.helius-rpc.com/?api-key=YOUR_API_KEY`
  </Card>
</CardGroup>

<Tabs>
  <Tab title="Key Features">
    * Unified access to all Solana asset types
    * Comprehensive metadata retrieval
    * Off-chain data indexing (Arweave, IPFS)
    * Merkle proof support for compressed assets
    * Token price data for verified tokens
    * Advanced filtering and search capabilities
  </Tab>

  <Tab title="Use Cases">
    * NFT marketplaces and storefronts
    * Wallet applications and portfolio trackers
    * Token-gated applications
    * Creator dashboards and analytics tools
    * NFT collection explorers
    * DeFi applications requiring token data
  </Tab>
</Tabs>

## API Methods

<CardGroup cols={3}>
  <Card title="Single Asset" icon="cube" href="#fetching-individual-assets">
    Get detailed data for specific assets
  </Card>

  <Card title="Asset Collections" icon="layer-group" href="#fetching-asset-collections">
    Get assets by owner, creator, or collection
  </Card>

  <Card title="Advanced Queries" icon="magnifying-glass" href="#advanced-query-methods">
    Search and filter assets with complex criteria
  </Card>
</CardGroup>

### Fetching Individual Assets

These methods let you retrieve detailed information about specific assets by their IDs.

<Tabs>
  <Tab title="getAsset">
    ```typescript
    // Get a single asset by its ID
    const url = `https://mainnet.helius-rpc.com/?api-key=YOUR_API_KEY`;

    const getAsset = async (id) => {
      const response = await fetch(url, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          jsonrpc: "2.0",
          id: "my-request-id",
          method: "getAsset",
          params: {
            id: id,
          },
        }),
      });
      
      const data = await response.json();
      return data.result;
    };

    // Example usage
    getAsset("FNt6A9Mfnqbwc1tY7uwAguKQ1JcpBrxmhczDgbdJy5AC");
    ```

    <Card title="API Reference" horizontal icon="code" href="/api-reference/das/getasset">
      View detailed documentation for getAsset
    </Card>
  </Tab>

  <Tab title="getAssetBatch">
    ```typescript
    // Get multiple assets (up to 1,000) in a single request
    const url = `https://mainnet.helius-rpc.com/?api-key=YOUR_API_KEY`;

    const getAssetBatch = async (ids) => {
      const response = await fetch(url, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          jsonrpc: '2.0',
          id: 'my-request-id',
          method: 'getAssetBatch',
          params: {
            ids: ids
          },
        }),
      });
      
      const { result } = await response.json();
      return result;
    };

    // Example usage
    getAssetBatch([
      '81bxPqYCE8j34nQm7Rooqi8Vt3iMHLzgZJ71rUVbQQuz',
      'CWHuz6GPjWYdwt7rTfRHKaorMwZP58Spyd7aqGK7xFbn'
    ]);
    ```

    <Card title="API Reference" horizontal icon="code" href="/api-reference/das/getassetbatch">
      View detailed documentation for getAssetBatch
    </Card>
  </Tab>

  <Tab title="getAssetProof">
    ```typescript
    // Get Merkle proof for a compressed asset
    const url = `https://mainnet.helius-rpc.com/?api-key=YOUR_API_KEY`;

    const getAssetProof = async (id) => {
      const response = await fetch(url, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          jsonrpc: '2.0',
          id: 'my-request-id',
          method: 'getAssetProof',
          params: {
            id: id
          },
        }),
      });
      
      const { result } = await response.json();
      return result;
    };

    // Example usage
    getAssetProof("Bu1DEKeawy7txbnCEJE4BU3BKLXaNAKCYcHR4XhndGss");
    ```

    <Card title="API Reference" horizontal icon="code" href="/api-reference/das/getassetproof">
      View detailed documentation for getAssetProof
    </Card>
  </Tab>

  <Tab title="getAssetProofBatch">
    ```typescript
    // Get Merkle proofs for multiple compressed assets
    const url = `https://mainnet.helius-rpc.com/?api-key=YOUR_API_KEY`;

    const getAssetProofBatch = async (ids) => {
      const response = await fetch(url, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          jsonrpc: '2.0',
          id: 'my-request-id',
          method: 'getAssetProofBatch',
          params: {
            ids: ids
          },
        }),
      });
      
      const { result } = await response.json();
      return result;
    };

    // Example usage
    getAssetProofBatch([
      '81bxPqYCE8j34nQm7Rooqi8Vt3iMHLzgZJ71rUVbQQuz',
      'CWHuz6GPjWYdwt7rTfRHKaorMwZP58Spyd7aqGK7xFbn'
    ]);
    ```

    <Card title="API Reference" horizontal icon="code" href="/api-reference/das/getassetproofbatch">
      View detailed documentation for getAssetProofBatch
    </Card>
  </Tab>
</Tabs>

### Fetching Asset Collections

These methods allow you to retrieve assets based on ownership, creation, authority, or collection membership.

<Note>
  All pagination in DAS API methods starts at 1 (not 0).
</Note>

<Tabs>
  <Tab title="By Owner">
    ```typescript
    // Get all assets owned by a wallet address
    const url = `https://mainnet.helius-rpc.com/?api-key=YOUR_API_KEY`;

    const getAssetsByOwner = async (ownerAddress) => {
      const response = await fetch(url, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          jsonrpc: '2.0',
          id: 'my-request-id',
          method: 'getAssetsByOwner',
          params: {
            ownerAddress: ownerAddress,
            page: 1,
            limit: 1000,
            displayOptions: {
              showFungible: true, // Include SPL tokens
              showNativeBalance: true, // Include SOL balance
              showInscription: true, // Include inscription data
            },
          },
        }),
      });
      
      const { result } = await response.json();
      return result;
    };

    // Example usage
    getAssetsByOwner("86xCnPeV69n6t3DnyGvkKobf9FdN2H9oiVDdaMpo2MMY");
    ```

    <Card title="API Reference" horizontal icon="code" href="/api-reference/das/getassetsbyowner">
      View detailed documentation for getAssetsByOwner
    </Card>
  </Tab>

  <Tab title="By Collection">
    ```typescript
    // Get all assets in a collection
    const url = `https://mainnet.helius-rpc.com/?api-key=YOUR_API_KEY`;

    const getAssetsByGroup = async (collectionAddress) => {
      const response = await fetch(url, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          jsonrpc: '2.0',
          id: 'my-request-id',
          method: 'getAssetsByGroup',
          params: {
            groupKey: 'collection',
            groupValue: collectionAddress,
            page: 1,
            limit: 1000,
          },
        }),
      });
      
      const { result } = await response.json();
      return result;
    };

    // Example usage
    getAssetsByGroup("J1S9H3QjnRtBbbuD4HjPV6RpRhwuk4zKbxsnCHuTgh9w");
    ```

    <Card title="API Reference" horizontal icon="code" href="/api-reference/das/getassetsbygroup">
      View detailed documentation for getAssetsByGroup
    </Card>
  </Tab>

  <Tab title="By Creator">
    ```typescript
    // Get all assets by a specific creator
    const url = `https://mainnet.helius-rpc.com/?api-key=YOUR_API_KEY`;

    const getAssetsByCreator = async (creatorAddress) => {
      const response = await fetch(url, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          jsonrpc: '2.0',
          id: 'my-request-id',
          method: 'getAssetsByCreator',
          params: {
            creatorAddress: creatorAddress,
            onlyVerified: true,
            page: 1,
            limit: 1000,
          },
        }),
      });
      
      const { result } = await response.json();
      return result;
    };

    // Example usage
    getAssetsByCreator("D3XrkNZz6wx6cofot7Zohsf2KSsu2ArngNk8VqU9cTY3");
    ```

    <Card title="API Reference" horizontal icon="code" href="/api-reference/das/getassetsbycreator">
      View detailed documentation for getAssetsByCreator
    </Card>
  </Tab>

  <Tab title="By Authority">
    ```typescript
    // Get all assets with a specific authority
    const url = `https://mainnet.helius-rpc.com/?api-key=YOUR_API_KEY`;

    const getAssetsByAuthority = async (authorityAddress) => {
      const response = await fetch(url, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          jsonrpc: '2.0',
          id: 'my-request-id',
          method: 'getAssetsByAuthority',
          params: {
            authorityAddress: authorityAddress,
            page: 1,
            limit: 1000,
          },
        }),
      });
      
      const { result } = await response.json();
      return result;
    };

    // Example usage
    getAssetsByAuthority("2RtGg6fsFiiF1EQzHqbd66AhW7R5bWeQGpTbv2UMkCdW");
    ```

    <Card title="API Reference" horizontal icon="code" href="/api-reference/das/getassetsbyauthority">
      View detailed documentation for getAssetsByAuthority
    </Card>
  </Tab>
</Tabs>

### Advanced Query Methods

These methods allow for more specialized asset queries, including transaction history, NFT editions, and complex search filters.

<Tabs>
  <Tab title="searchAssets">
    ```typescript
    // Search for assets with flexible criteria
    const url = `https://mainnet.helius-rpc.com/?api-key=YOUR_API_KEY`;

    const searchAssets = async (searchParams) => {
      const response = await fetch(url, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          jsonrpc: '2.0',
          id: 'my-request-id',
          method: 'searchAssets',
          params: searchParams,
        }),
      });
      
      const { result } = await response.json();
      return result;
    };

    // Example: Search for NFTs with specific traits
    searchAssets({
      ownerAddress: "86xCnPeV69n6t3DnyGvkKobf9FdN2H9oiVDdaMpo2MMY",
      grouping: ["collection", "J1S9H3QjnRtBbbuD4HjPV6RpRhwuk4zKbxsnCHuTgh9w"],
      traits: [
        { trait_type: "Background", values: ["Blue"] }
      ],
      limit: 100
    });
    ```

    <Card title="API Reference" horizontal icon="code" href="/api-reference/das/searchassets">
      View detailed documentation for searchAssets
    </Card>
  </Tab>

  <Tab title="getSignaturesForAsset">
    ```typescript
    // Get transaction history for a compressed asset
    const url = `https://mainnet.helius-rpc.com/?api-key=YOUR_API_KEY`;

    const getSignaturesForAsset = async (assetId) => {
      const response = await fetch(url, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          jsonrpc: '2.0',
          id: 'my-request-id',
          method: 'getSignaturesForAsset',
          params: {
            id: assetId,
            page: 1,
            limit: 1000,
          },
        }),
      });
      
      const { result } = await response.json();
      return result;
    };

    // Example usage
    getSignaturesForAsset("FNt6A9Mfnqbwc1tY7uwAguKQ1JcpBrxmhczDgbdJy5AC");
    ```

    <Card title="API Reference" horizontal icon="code" href="/api-reference/das/getsignaturesforasset">
      View detailed documentation for getSignaturesForAsset
    </Card>
  </Tab>

  <Tab title="getNftEditions">
    ```typescript
    // Get all editions for a master NFT
    const url = `https://mainnet.helius-rpc.com/?api-key=YOUR_API_KEY`;

    const getNftEditions = async (masterMint) => {
      const response = await fetch(url, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          jsonrpc: "2.0",
          id: "my-request-id",
          method: "getNftEditions",
          params: {
            mint: masterMint,
            page: 1,
            limit: 100
          },
        }),
      });
      
      const { result } = await response.json();
      return result;
    };

    // Example usage
    getNftEditions("Ey2Qb8kLctbchQsMnhZs5DjY32To2QtPuXNwWvk4NosL");
    ```

    <Card title="API Reference" horizontal icon="code" href="/api-reference/das/getnfteditions">
      View detailed documentation for getNftEditions
    </Card>
  </Tab>

  <Tab title="getTokenAccounts">
    ```typescript
    // Get token accounts for a mint or owner
    const url = `https://mainnet.helius-rpc.com/?api-key=YOUR_API_KEY`;

    const getTokenAccounts = async (params) => {
      const response = await fetch(url, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          jsonrpc: "2.0",
          id: "my-request-id",
          method: "getTokenAccounts",
          params: params,
        }),
      });
      
      const { result } = await response.json();
      return result;
    };

    // Example: Get all accounts holding a specific token
    getTokenAccounts({
      mint: "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v", // USDC
      page: 1,
      limit: 100
    });
    ```

    <Card title="API Reference" horizontal icon="code" href="/api-reference/das/gettokenaccounts">
      View detailed documentation for getTokenAccounts
    </Card>
  </Tab>
</Tabs>

## Working with Special Asset Types

<CardGroup cols={2}>
  <Card title="Fungible Tokens" icon="coins" href="#fungible-tokens">
    Access SPL tokens and get price data
  </Card>

  <Card title="Compressed NFTs" icon="file-zipper" href="#compressed-nfts">
    Work with state-compressed assets
  </Card>

  <Card title="Inscriptions" icon="file-signature" href="#inscriptions--spl-20">
    Access inscription and SPL-20 data
  </Card>

  <Card title="Off-chain Data" icon="cloud" href="#off-chain-data">
    Retrieve metadata from Arweave/IPFS
  </Card>
</CardGroup>

### Fungible Tokens

<Info>
  Helius has extended the DAS API to support **all tokens**, including plain SPL tokens (without metadata) and Token-2022 (plus their extensions). Fungible token support is available through the `getAssetsByOwner` and `searchAssets` methods.
</Info>

```typescript
// Get all tokens for a wallet including price data
const url = `https://mainnet.helius-rpc.com/?api-key=YOUR_API_KEY`;

const getTokensWithPrices = async (ownerAddress) => {
  const response = await fetch(url, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      jsonrpc: '2.0',
      id: 'my-request-id',
      method: 'getAssetsByOwner',
      params: {
        ownerAddress: ownerAddress,
        displayOptions: {
          showFungible: true,
        },
      },
    }),
  });

  const { result } = await response.json();
  
  // Filter tokens that have price data
  const tokensWithPrices = result.items.filter(
    asset => asset.token_info?.price_info
  );
  
  return tokensWithPrices;
};

// Example usage
getTokensWithPrices("86xCnPeV69n6t3DnyGvkKobf9FdN2H9oiVDdaMpo2MMY");
```

### Compressed NFTs

State-compressed NFTs (cNFTs) require special handling for operations like retrieving Merkle proofs and transaction history:

```typescript
// Common operations with compressed NFTs
const url = `https://mainnet.helius-rpc.com/?api-key=YOUR_API_KEY`;

// 1. Get a compressed NFT
const getCompressedNft = async (id) => {
  const response = await fetch(url, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      jsonrpc: '2.0',
      id: 'my-request-id',
      method: 'getAsset',
      params: { id },
    }),
  });
  
  const { result } = await response.json();
  return result;
};

// 2. Get Merkle proof for verification
const getProof = async (id) => {
  const response = await fetch(url, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      jsonrpc: '2.0',
      id: 'my-request-id',
      method: 'getAssetProof',
      params: { id },
    }),
  });
  
  const { result } = await response.json();
  return result;
};

// 3. Get transaction history
const getTransactionHistory = async (id) => {
  const response = await fetch(url, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      jsonrpc: '2.0',
      id: 'my-request-id',
      method: 'getSignaturesForAsset',
      params: { 
        id,
        page: 1,
        limit: 100
      },
    }),
  });
  
  const { result } = await response.json();
  return result;
};
```

### Inscriptions & SPL-20

<Tip>
  You can optionally display inscription and SPL-20 token data with the `showInscription` flag. This is an experimental feature.
</Tip>

```typescript
// Get inscriptions for a wallet
const url = `https://mainnet.helius-rpc.com/?api-key=YOUR_API_KEY`;

const getInscriptionsForWallet = async (ownerAddress) => {
  const response = await fetch(url, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      jsonrpc: '2.0',
      id: 'my-request-id',
      method: 'getAssetsByOwner',
      params: {
        ownerAddress: ownerAddress,
        displayOptions: {
          showInscription: true,
        },
      },
    }),
  });

  const { result } = await response.json();
  
  // Filter results to only include assets with inscription data
  const inscriptions = result.items.filter(
    asset => asset.inscription
  );
  
  return inscriptions;
};

// Example usage
getInscriptionsForWallet("6GmTFg5SCs4zGfDEidUAJjS5pSrXEPwW8Rpfs3RHrbc5");
```

### Off-chain Data

<Accordion title="Off-chain Data Retrieval">
  Most NFT collections store additional metadata (attributes, images, etc.) off-chain on platforms like Arweave or IPFS. The DAS API automatically indexes this off-chain data and provides it alongside on-chain data in a single API call.

  <Note>
    Helius cannot detect off-chain data mutations. The off-chain data will only be updated once the NFT is seen by the system again (e.g., when the NFT is modified on-chain). If you need the off-chain data for a collection to be re-indexed, please reach out to Helius support.
  </Note>
</Accordion>

## Best Practices

<CardGroup cols={2}>
  <Card title="Pagination" icon="arrows-split-up-and-left">
    * Start at page 1 (not 0)
    * Use reasonable limit values (100-1000)
    * Implement robust pagination for large datasets
  </Card>

  <Card title="Error Handling" icon="shield-check">
    * Always check for errors in responses
    * Implement retries with exponential backoff
    * Handle edge cases like invalid parameters
  </Card>

  <Card title="Performance" icon="bolt">
    * Use batch methods when possible
    * Cache responses when appropriate
    * Avoid chaining multiple requests when one will do
  </Card>

  <Card title="Security" icon="lock">
    * Never expose your API key in client-side code
    * Use server-side functions to proxy API requests
    * Set up appropriate CORS policies
  </Card>
</CardGroup>

## Resources

<CardGroup cols={3}>
  <Card title="API References" icon="book-open" href="/api-reference/das">
    Full API documentation for all DAS methods
  </Card>

  <Card title="GitHub Repository" icon="github" href="https://github.com/metaplex-foundation/digital-asset-standard-api">
    DAS API open-source specification
  </Card>

  <Card title="Examples & SDKs" icon="code" href="/sdks">
    Get started with client libraries and code samples
  </Card>
</CardGroup>


# Solana Fungible Token API: Complete Token Data Access
Source: https://www.helius.dev/docs/das/fungible-token-extension

The most versatile API for working with all Solana tokens. SPL tokens, Token22 extensions, price data, and comprehensive token information access.

## Background

Initially, the DAS API only supported ownership queries against Metaplex NFTs and cNFTs. Helius has extended the DAS API to support **all tokens**, including plain SPL tokens (without metadata) and Token22 (plus their extensions).

Users can query for the token balances of **any** account, across **all** tokens (SPL, Token22, NFTs, compressed NFTs).  We've also included token prices in USD.

A Solana token is defined by its mint account. For example, the mint account for USDC is [EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v](https://explorer.solana.com/address/EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v). When you buy \$40 of USDC, a token account is created that holds 40 USDC tokens. This can extend to hundreds (and even more) of token accounts for different tokens.

<Info>
  Want to learn more about Token22? Check out the Helius [blog post](https://www.helius.dev/blog/what-is-token-2022)!
</Info>

## How does it work?

The Helius extension for fungible tokens resolves around ownership indexing. The following queries provide a unified view of an account's assets. [GetAsset](/api-reference/das/getasset), [GetAssetsByOwner](/api-reference/das/getassetsbyowner), and [SearchAssets](/api-reference/das/searchassets) support fungible tokens.

This extension adds an extra field called `tokenType`. This field allows you to query against all assets the account owns, including fungible and Token22 tokens.

The options for `tokenType` include:

* `fungible` : Returns all fungible tokens.
* `nonFungible`: Returns all NFTs (compressed and regular NFTs).
* `regularNft` : Returns only the regular NFTs.
* `compressedNft`: Returns only the compressed NFTs.
* `all` : Returns all the tokens.

Example:

```json
{
    "jsonrpc": "2.0",
    "id": "helius-test",
    "method": "searchAssets",
    "params": {
        "ownerAddress": "5aZZ4duJUKiMsJN9vRsoAn4SDX7agvKu7Q3QdFWRfWze",
        "tokenType": "all"
    }
}
```

You'll now see fungible tokens like JitoSOL in the response (trimmed for brevity). It will include the total account balance, the token's program address, the associated token address, the total supply in circulation, and the price information.

```json
"id": "J1toso1uCk3RLmjorhTtrVwY9HJ7X8V9yYac6Y7kGCPn",
"content": {
    "$schema": "",
    "json_uri": "",
    "metadata": {
        "description": "MEV-Powered Liquid Staking Derivative",
        "name": "Jito Staked SOL",
        "symbol": "JitoSOL",
        "token_standard": "Fungible"
    },
    [...],
    "token_info": {
        "symbol": "JitoSOL",
        "balance": 35688813508,
        "supply": 5949594702758293,
        "decimals": 9,
        "token_program": "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA",
        "associated_token_address": "H7iLu4DPFpzEx1AGN8BCN7Qg966YFndt781p6ukhgki9",
        "price_info": {
            "price_per_token": 56.47943,
            "total_price": 2015.6838854339217,
            "currency": "USDC"
        }
    },
[...]

```

### Token22 Support

We support Token22 tokens and parse their extensions. The response will include the `mint_extensions` field if it is a Token22 program. Here is an example for BERN:

```json
"mint_extensions": {
    "transfer_fee_config": {
        "withheld_amount": 0,
        "newer_transfer_fee": {
            "epoch": 457,
            "maximum_fee": 3906250000000000000,
            "transfer_fee_basis_points": 690
        },
        "older_transfer_fee": {
            "epoch": 455,
            "maximum_fee": 3906250000000000000,
            "transfer_fee_basis_points": 0
        },
        "withdraw_withheld_authority": "7MyTjmRygJoCuDBUtAuSugiYZFULD2SWaoUTmtjtRDzD",
        "transfer_fee_config_authority": "7MyTjmRygJoCuDBUtAuSugiYZFULD2SWaoUTmtjtRDzD"
    }
}
```

### Backwards Compatibility

For backwards compatibility, the behaviour is identical to the original DAS, meaning only NFTs and compressed NFTs are returned.

```json
{
    "jsonrpc": "2.0",
    "id": "helius-test",
    "method": "searchAssets",
    "params": {
        "ownerAddress": "5aZZ4duJUKiMsJN9vRsoAn4SDX7agvKu7Q3QdFWRfWze"
    }
}
```


# How to Get Solana Assets: NFTs, Tokens & Price Data
Source: https://www.helius.dev/docs/das/get-nfts

Learn how to retrieve and query Solana NFTs, SPL tokens, and price data using Helius DAS APIs. Complete guide with code examples and best practices.

The Helius Digital Asset Standard (DAS) API provides powerful tools for reading and querying both NFT and token data on Solana. This guide shows you how to work with different types of Solana assets effectively.

<CardGroup cols={2}>
  <Card title="Query NFTs" icon="image" href="#working-with-nfts-and-digital-collectibles">
    Retrieve, search, and manage NFT data and collections
  </Card>

  <Card title="Access SPL Tokens" icon="coins" href="#working-with-spl-tokens">
    Get token balances, accounts, and holder information
  </Card>

  <Card title="Token Pricing" icon="chart-line" href="#price-data-for-jupiter-verified-tokens">
    Access real-time price data for Jupiter verified tokens
  </Card>

  <Card title="API Reference" icon="code" href="/api-reference/das">
    View detailed API documentation
  </Card>
</CardGroup>

## Price Data for Jupiter Verified Tokens

```typescript
const fetchTokenPriceData = async () => {
  const response = await fetch("https://mainnet.helius-rpc.com/?api-key=YOUR_API_KEY", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
    },
    body: JSON.stringify({
      jsonrpc: "2.0",
      id: "1",
      method: "getAsset",
      params: {
        id: "DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263", // Bonk token mint address
        displayOptions: {
          showFungibleTokens: true
        }
      },
    }),
  });
  
  const data = await response.json();
  
  // Calculate market cap
  if (data.result?.token_info?.price_info) {
    const { price_per_token } = data.result.token_info.price_info;
    const { supply, decimals } = data.result.token_info;
    
    // Adjust supply for decimals
    const adjustedSupply = supply / Math.pow(10, decimals);
    const marketCap = price_per_token * adjustedSupply;
    
    console.log(`Market Cap: $${marketCap.toLocaleString()}`);
  }
  
  return data;
};
```

<Card title="API Reference" horizontal icon="code" href="/api-reference/das/getasset">
  View detailed documentation for getAsset
</Card>

### Response Structure

The price data is available in the response under `token_info.price_info`:

```json
{
  "token_info": {
    "symbol": "Bonk",
    "supply": 8881594973561640000,
    "decimals": 5,
    "token_program": "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA",
    "price_info": {
      "price_per_token": 0.0000192271,
      "currency": "USDC"
    }
  }
}
```

### Calculating Market Cap

To calculate a token's market cap, multiply its price by the adjusted supply (accounting for decimals):

```typescript
const adjustedSupply = supply / Math.pow(10, decimals);
const marketCap = pricePerToken * adjustedSupply;
```

This calculation gives you the total market valuation of the token by properly accounting for the token's decimal places.

## Working with NFTs and Digital Collectibles

The DAS API offers several methods for working with NFTs and digital collectibles. These methods allow you to retrieve individual assets, query by owner or creator, and verify on-chain authenticity.

<Tabs>
  <Tab title="Get Single NFT">
    <div>
      <h3>Getting a Single NFT</h3>
      <p>Retrieve comprehensive data for a specific NFT:</p>

      ```typescript
      const getNFT = async (mintAddress) => {
        const response = await fetch('https://mainnet.helius-rpc.com/?api-key=YOUR_API_KEY', {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            jsonrpc: "2.0",
            id: "1",
            method: "getAsset",
            params: {
              id: mintAddress,
            },
          }),
        });
        
        const data = await response.json();
        return data;
      };

      // Example usage
      getNFT("F9Lw3ki3hJ7PF9HQXsBzoY8GyE6sPoEZZdXJBsTTD2rk");
      ```
    </div>
  </Tab>

  <Tab title="Find by Owner">
    <div>
      <h3>Finding NFTs by Owner</h3>
      <p>Retrieve all NFTs owned by a specific wallet address:</p>

      ```typescript
      const getNFTsByOwner = async (ownerAddress) => {
        const response = await fetch("https://mainnet.helius-rpc.com/?api-key=YOUR_API_KEY", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            jsonrpc: "2.0",
            id: "1",
            method: "getAssetsByOwner",
            params: {
              ownerAddress: ownerAddress,
              page: 1,
              limit: 10,
            },
          }),
        });
        
        const data = await response.json();
        return data;
      };

      // Example usage
      getNFTsByOwner("86xCnPeV69n6t3DnyGvkKobf9FdN2H9oiVDdaMpo2MMY");
      ```
    </div>
  </Tab>

  <Tab title="Advanced Search">
    <div>
      <h3>Searching Assets with Advanced Filters</h3>
      <p>Search for assets by various attributes with detailed filters:</p>

      ```typescript
      const searchAssets = async (params) => {
        const response = await fetch("https://mainnet.helius-rpc.com/?api-key=YOUR_API_KEY", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            jsonrpc: "2.0",
            id: "1",
            method: "searchAssets",
            params: params,
          }),
        });
        
        const data = await response.json();
        return data;
      };

      // Example: Find all NFTs owned by an address
      searchAssets({
        ownerAddress: "86xCnPeV69n6t3DnyGvkKobf9FdN2H9oiVDdaMpo2MMY",
        tokenType: "all",
        limit: 50,
      });
      ```
    </div>
  </Tab>
</Tabs>

<CardGroup cols={3}>
  <Card title="getAsset" icon="image" href="/api-reference/das/getasset">
    Detailed data for a single asset
  </Card>

  <Card title="getAssetsByOwner" icon="user" href="/api-reference/das/getassetsbyowner">
    All assets owned by an address
  </Card>

  <Card title="searchAssets" icon="magnifying-glass" href="/api-reference/das/searchassets">
    Filter assets by multiple criteria
  </Card>
</CardGroup>

### Advanced NFT Query Methods

<Tabs>
  <Tab title="By Creator">
    ```typescript
    const getAssetsByCreator = async (creatorAddress) => {
      const response = await fetch("https://mainnet.helius-rpc.com/?api-key=YOUR_API_KEY", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          jsonrpc: "2.0",
          id: "1",
          method: "getAssetsByCreator",
          params: {
            creatorAddress: creatorAddress,
            page: 1,
            limit: 100,
          },
        }),
      });
      
      const data = await response.json();
      return data;
    };

    // Example usage
    getAssetsByCreator("9uBX3ASjxWvNBAD1xjbVaKA74mWGZys3RGSF7DdeDD3F");
    ```
  </Tab>

  <Tab title="By Collection">
    ```typescript
    const getAssetsByCollection = async (collectionAddress) => {
      const response = await fetch("https://mainnet.helius-rpc.com/?api-key=YOUR_API_KEY", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          jsonrpc: "2.0",
          id: "1",
          method: "getAssetsByGroup",
          params: {
            groupKey: "collection",
            groupValue: collectionAddress,
            page: 1,
            limit: 100,
          },
        }),
      });
      
      const data = await response.json();
      return data;
    };

    // Example usage
    getAssetsByCollection("J1S9H3QjnRtBbbuD4HjPV6RpRhwuk4zKbxsnCHuTgh9w");
    ```
  </Tab>

  <Tab title="Transaction History">
    ```typescript
    const getNFTTransactionHistory = async (mintAddress) => {
      const response = await fetch("https://mainnet.helius-rpc.com/?api-key=YOUR_API_KEY", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          jsonrpc: "2.0",
          id: "1",
          method: "getSignaturesForAsset",
          params: {
            id: mintAddress,
            page: 1,
            limit: 100,
          },
        }),
      });
      
      const data = await response.json();
      return data;
    };

    // Example usage
    getNFTTransactionHistory("FNt6A9Mfnqbwc1tY7uwAguKQ1JcpBrxmhczDgbdJy5AC");
    ```
  </Tab>

  <Tab title="On-Chain Proof">
    ```typescript
    const getNFTProof = async (mintAddress) => {
      const response = await fetch("https://mainnet.helius-rpc.com/?api-key=YOUR_API_KEY", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          jsonrpc: "2.0",
          id: "1",
          method: "getAssetProof",
          params: {
            id: mintAddress,
          },
        }),
      });
      
      const proof = await response.json();
      return proof;
    };

    // Example usage
    getNFTProof("Bu1DEKeawy7txbnCEJE4BU3BKLXaNAKCYcHR4XhndGss");
    ```
  </Tab>
</Tabs>

<CardGroup cols={4}>
  <Card title="By Creator" icon="user" href="/api-reference/das/getassetsbycreator">API Reference</Card>
  <Card title="By Collection" icon="layer-group" href="/api-reference/das/getassetsbygroup">API Reference</Card>
  <Card title="Transaction History" icon="clock" href="/api-reference/das/getsignaturesforasset">API Reference</Card>
  <Card title="On-Chain Proof" icon="check-double" href="/api-reference/das/getassetproof">API Reference</Card>
</CardGroup>

## Working with SPL Tokens

SPL tokens can be queried through multiple methods in the Helius API. These methods let you check balances, find token accounts, and get token metadata.

### Common SPL Token Operations

<Tabs>
  <Tab title="Token Balance">
    ```typescript
    const getTokenBalance = async (tokenAccountAddress) => {
      const response = await fetch("https://mainnet.helius-rpc.com/?api-key=YOUR_API_KEY", {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          jsonrpc: '2.0',
          id: '1',
          method: 'getTokenAccountBalance',
          params: [tokenAccountAddress]
        })
      });
      
      const data = await response.json();
      return data;
    };

    // Example usage
    getTokenBalance("3emsAVdmGKERbHjmGfQ6oZ1e35dkf5iYcS6U4CPKFVaa");
    ```

    <Card title="API Reference" horizontal icon="code" href="/api-reference/rpc/http/gettokenaccountbalance">
      View getTokenAccountBalance documentation
    </Card>
  </Tab>

  <Tab title="Tokens by Owner">
    ```typescript
    const getTokensByOwner = async (ownerAddress) => {
      const response = await fetch("https://mainnet.helius-rpc.com/?api-key=YOUR_API_KEY", {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          jsonrpc: '2.0',
          id: '1',
          method: 'getTokenAccountsByOwner',
          params: [
            ownerAddress,
            {
              programId: 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'
            },
            {
              encoding: 'jsonParsed'
            }
          ]
        })
      });
      
      const data = await response.json();
      return data;
    };

    // Example usage
    getTokensByOwner("86xCnPeV69n6t3DnyGvkKobf9FdN2H9oiVDdaMpo2MMY");
    ```

    <Card title="API Reference" horizontal icon="code" href="/api-reference/rpc/http/gettokenaccountsbyowner">
      View getTokenAccountsByOwner documentation
    </Card>
  </Tab>

  <Tab title="Token Supply">
    ```typescript
    const getTokenSupply = async (mintAddress) => {
      const response = await fetch("https://mainnet.helius-rpc.com/?api-key=YOUR_API_KEY", {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          jsonrpc: '2.0',
          id: '1',
          method: 'getTokenSupply',
          params: [mintAddress]
        })
      });
      
      const data = await response.json();
      return data;
    };

    // Example usage
    getTokenSupply("EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v");
    ```

    <Card title="API Reference" horizontal icon="code" href="/api-reference/rpc/http/gettokensupply">
      View getTokenSupply documentation
    </Card>
  </Tab>

  <Tab title="Largest Holders">
    ```typescript
    const getTokenLargestAccounts = async (mintAddress) => {
      const response = await fetch("https://mainnet.helius-rpc.com/?api-key=YOUR_API_KEY", {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          jsonrpc: '2.0',
          id: '1',
          method: 'getTokenLargestAccounts',
          params: [mintAddress]
        })
      });
      
      const data = await response.json();
      return data;
    };

    // Example usage
    getTokenLargestAccounts("he1iusmfkpAdwvxLNGV8Y1iSbj4rUy6yMhEA3fotn9A");
    ```

    <Card title="API Reference" horizontal icon="code" href="/api-reference/rpc/http/gettokenlargestaccounts">
      View getTokenLargestAccounts documentation
    </Card>
  </Tab>
</Tabs>

### Advanced SPL Token Queries

You can also find all accounts holding a specific token mint:

```typescript
const getTokenAccountsByMint = async (mintAddress) => {
  const response = await fetch("https://mainnet.helius-rpc.com/?api-key=YOUR_API_KEY", {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      jsonrpc: '2.0',
      id: '1',
      method: 'getTokenAccountsByOwner',
      params: [
        'CEXq1uy9y15PL2Wb4vDQwQfcJakBGjaAjeuR2nKLj8dk', // Owner address
        {
          mint: mintAddress
        },
        {
          encoding: 'jsonParsed'
        }
      ]
    })
  });
  
  const data = await response.json();
  return data;
};

// Example usage
getTokenAccountsByMint("8wXtPeU6557ETkp9WHFY1n1EcU6NxDvbAggHGsMYiHsB");
```

## Best Practices

When working with the DAS API, keep these best practices in mind:

1. **Use pagination** for methods that return large data sets
2. **Handle errors gracefully** by implementing try/catch blocks
3. **Cache responses** when appropriate to reduce API calls
4. **Respect rate limits** to avoid disruptions in your application
5. **Verify Jupiter price data** is available before calculating market cap

## FAQ

<AccordionGroup>
  <Accordion title="How do I get all NFTs for a wallet?">
    Use the `getAssetsByOwner` method with the wallet address. Be sure to implement pagination if the wallet might contain many assets.
  </Accordion>

  <Accordion title="Can I get price data for any token?">
    Price data is only available for tokens that are verified on Jupiter. Check if `token_info.price_info` exists in the response.
  </Accordion>

  <Accordion title="How do I find the largest holders of a token?">
    Use the `getTokenLargestAccounts` method with the token's mint address to retrieve a list of the largest holder accounts.
  </Accordion>

  <Accordion title="What's the difference between getAsset and searchAssets?">
    `getAsset` retrieves data for a single asset by its mint address, while `searchAssets` allows you to query multiple assets using various filters.
  </Accordion>
</AccordionGroup>


# Solana DAS API Pagination: Efficient Large Dataset Querying
Source: https://www.helius.dev/docs/das/pagination

Explore efficient pagination mechanisms for Solana DAS API. Page-based, cursor-based, and keyset pagination for large datasets with performance optimization.

## Introduction

The DAS API methods will only return up to 1000 records. If you need to retrieve more than 1000 items, you will need to paginate the records. This is achieved by making multiple API calls and crawling through multiple "pages" of data. We support two mechanisms: page-based and keyset pagination.

<Note>
  We recommend page-based pagination for beginners. It is the simplest and best way to get started. Keyset pagination is recommended for advanced users who need to query across large (500k+) datasets efficiently.
</Note>

## Sorting Options

With the DAS API, you can sort the data by different fields:

1. `id`: Sort by the asset ID in binary (default).
2. `created`: Sort by the date the asset was created.
3. `recent_action` : Sort by the date the asset was last updated (not recommended).
4. `none`: Do not sort the data (not recommended).

Disabling the sorting will yield the fastest results, but since the data is not ordered, you may have inconsistent results when paginating.

## Pagination Options

### Page-based

With this method, the user specifies the page number and the number of items they want per page. To iterate to the next page, increment the page number. This is easy, intuitive, and fast for most use cases.

<Accordion title="Example">
  ```javascript
  const url = `https://mainnet.helius-rpc.com/?api-key=<api_key>`

  const example = async () => {
      let page = 1;
      let items = [];
      while (true) {
          const response = await fetch(url, {
              method: 'POST',
              headers: {
                  'Content-Type': 'application/json',
              },
              body: JSON.stringify({
                  jsonrpc: '2.0',
                  id: 'my-id',
                  method: 'searchAssets',
                  params: {
                      grouping: ['collection', '5PA96eCFHJSFPY9SWFeRJUHrpoNF5XZL6RrE1JADXhxf'],
                      page: page,
                      limit: 1000,
                      sortBy: { sortBy: 'id', sortDirection: 'asc' },
                  },
              }),
          });
          const { result } = await response.json();
          if (result.items.length == 0) {
              console.log('No items remaining');
              break;
          } else {
              console.log(`Processing results from page ${page}`);
              items.push(...result.items);
              page += 1;
          }
      }
      console.log(`Got ${items.length} total items`);
  };
  example();
  ```
</Accordion>

Using pages requires the database to crawl across all items until it reaches the next page. For example, if you ask for page 100 and page size 1000, the database must traverse the first 1M records before returning your data.

For this reason, page-based pagination is not recommended for large datasets. Keyset pagination is far better suited for these types of workloads.

### Keyset

With this method, the user defines pages by providing conditions that filter the data set. For example, you can say, "Get me all assets with an ID > X but an ID \< Y". The user can traverse the entire dataset by modifying X or Y on each call. We provide two methods of keyset pagination:

1. **Cursor-based**  Easier to use but less flexible.
2. **Range-based**  More complex but very flexible.

<Info>
  Keyset pagination is only supported when sorting by `id`.
</Info>

#### Cursor-based

A DAS query without any pagination parameters will return a cursor. You can give the cursor to the DAS API to continue from where you left off.

<Accordion title="Example">
  ```javascript
  const url = `https://mainnet.helius-rpc.com/?api-key=<api_key>`

  const example = async () => {
      let items = [];
      let cursor;
      while (true) {
          let params = {
              grouping: ['collection', '5PA96eCFHJSFPY9SWFeRJUHrpoNF5XZL6RrE1JADXhxf'],
              limit: 1000,
              sortBy: { sortBy: 'id', sortDirection: 'asc' },
          } as any;
          if (cursor != undefined) {
              params.cursor = cursor;
          }
          const response = await fetch(url, {
              method: 'POST',
              headers: {
                  'Content-Type': 'application/json',
              },
              body: JSON.stringify({
                  jsonrpc: '2.0',
                  id: 'my-id',
                  method: 'searchAssets',
                  params: params,
              }),
          });
          const { result } = await response.json();
          if (result.items.length == 0) {
              console.log('No items remaining');
              break;
          } else {
              console.log(`Processing results for cursor ${cursor}`);
              cursor = result.cursor;
              items.push(...result.items);
          }
      }
      console.log(`Got ${items.length} total items`);
  };
  example();
  ```
</Accordion>

<Info>
  At the time of writing, the cursor will be the last asset ID of the response; however, the cursor design is flexible and can support any string.
</Info>

#### Range-based

To query across a range, you can specify `before` and/or `after`. The query is essentially identical to "get me all assets after X but before Y". You can traverse the dataset by updating each call's before or after parameter.

<Accordion title="Example">
  ```javascript
  const url = `https://mainnet.helius-rpc.com/?api-key=<api_key>`

  const example = async () => {
      // Two NFTs from the Tensorian collection.
      // The "start" item has a lower asset ID (in binary) than the "end" item.
      // We will traverse in ascending order.
      let start = '6CeKtAYX5USSvPCQicwFsvN4jQSHNxQuFrX2bimWrNey';
      let end = 'CzTP4fUbdfgKzwE6T94hsYV7NWf1SzuCCsmJ6RP1xsDw';
      let sortDirection = 'asc';
      let after = start;
      let before = end;
      let items = [];

      while (true) {
          const response = await fetch(url, {
              method: 'POST',
              headers: {
                  'Content-Type': 'application/json',
              },
              body: JSON.stringify({
                  jsonrpc: '2.0',
                  id: 'my-id',
                  method: 'searchAssets',
                  params: {
                      grouping: ['collection', '5PA96eCFHJSFPY9SWFeRJUHrpoNF5XZL6RrE1JADXhxf'],
                      limit: 1000,
                      after: after,
                      before: before,
                      sortBy: { sortBy: 'id', sortDirection: sortDirection },
                  },
              }),
          });
          const { result } = await response.json();
          if (result.items.length == 0) {
              console.log('No items remaining');
              break;
          } else {
              console.log(`Processing results with (after: ${after}, before: ${before})`);
              after = result.items[result.items.length - 1].id;
              items.push(...result.items);
          }
      }
      console.log(`Got ${items.length} total items`);
  };
  example();
  ```
</Accordion>

### Parallel Querying with Keysets (advanced)

Advanced users needing to query large datasets (e.g., entire compressed NFT collections) must use keyset-based pagination for performance reasons. The following example shows how users can parallel query by partitioning the Solana address range and leveraging the before/after parameters. This method is fast, efficient, and safe. If you have any questions or need help, don't hesitate to reach out on Discord!

<Accordion title="Example">
  In the example below, we scan the entire Tensorian collection (\~10k records). It partitions the Solana address space into 8 ranges and scans those ranges concurrently. You'll notice that this example is far faster than any other.

  ```javascript
  import base58 from 'bs58';

  const url = `https://mainnet.helius-rpc.com/?api-key=<api_key>`

  const main = async () => {
      let numParitions = 8;
      let partitons = partitionAddressRange(numParitions);
      let promises = [];
      for (const [i, partition] of partitons.entries()) {
          let [s, e] = partition;
          let start = bs58.encode(s);
          let end = bs58.encode(e);
          console.log(`Parition: ${i}, Start: ${start}, End: ${end}`);

          let promise: Promise<number> = new Promise(async (resolve, reject) => {
              let current = start;
              let totalForPartition = 0;
              while (true) {
                  const response = await fetch(url, {
                      method: 'POST',
                      headers: {
                          'Content-Type': 'application/json',
                      },
                      body: JSON.stringify({
                          jsonrpc: '2.0',
                          id: 'my-id',
                          method: 'searchAssets',
                          params: {
                              grouping: ['collection', '5PA96eCFHJSFPY9SWFeRJUHrpoNF5XZL6RrE1JADXhxf'],
                              limit: 1000,
                              after: current,
                              before: end,
                              sortBy: { sortBy: 'id', sortDirection: 'asc' },
                          },
                      }),
                  });
                  const { result } = await response.json();
                  totalForPartition += result.items.length;
                  console.log(`Found ${totalForPartition} total items in parition ${i}`);
                  if (result.items.length == 0) {
                      break;
                  } else {
                      current = result.items[result.items.length - 1].id;
                  }
              }
              resolve(totalForPartition);
          });
          promises.push(promise);
      }
      let results = await Promise.all(promises);
      let total = results.reduce((a, b) => a + b, 0);
      console.log(`Got ${total} total items`);
  };

  // Function to convert a BigInt to a byte array
  function bigIntToByteArray(bigInt: bigint): Uint8Array {
      const bytes = [];
      let remainder = bigInt;
      while (remainder > 0n) {
          // use 0n for bigint literal
          bytes.unshift(Number(remainder & 0xffn));
          remainder >>= 8n;
      }
      while (bytes.length < 32) bytes.unshift(0); // pad with zeros to get 32 bytes
      return new Uint8Array(bytes);
  }

  function partitionAddressRange(numPartitions: number) {
      let N = BigInt(numPartitions);

      // Largest and smallest Solana addresses in integer form.
      // Solana addresses are 32 byte arrays.
      const start = 0n;
      const end = 2n ** 256n - 1n;

      // Calculate the number of partitions and partition size
      const range = end - start;
      const partitionSize = range / N;

      // Calculate partition ranges
      const partitions: Uint8Array[][] = [];
      for (let i = 0n; i < N; i++) {
          const s = start + i * partitionSize;
          const e = i === N - 1n ? end : s + partitionSize;
          partitions.push([bigIntToByteArray(s), bigIntToByteArray(e)]);
      }

      return partitions;
  }

  main();
  ```
</Accordion>


# Solana Asset Search: Find NFTs, Tokens & Compressed Assets
Source: https://www.helius.dev/docs/das/search

Master the searchAssets endpoint to discover NFTs, compressed assets, and fungible tokens on Solana. Advanced filtering, pagination, and efficient asset discovery.

<Card title="API Reference" horizontal icon="code" href="/api-reference/das/searchassets">
  View detailed documentation for searchAssets
</Card>

## Quick Start

<Callout type="warning">
  <strong>Required parameter:</strong> Every <code>searchAssets</code> request must include a <code>tokenType</code>. Pick one of:
  <code>fungible</code>, <code>nonFungible</code>, <code>regularNft</code>, <code>compressedNft</code>, or <code>all</code>.
</Callout>

```ts TypeScript
// Replace YOUR_API_KEY with your Helius API key
const url = `https://mainnet.helius-rpc.com/?api-key=YOUR_API_KEY`;

async function searchAssets(params) {
  const body = {
    jsonrpc: "2.0",
    id: "search-assets-example",
    method: "searchAssets",
    params,
  };
  const res = await fetch(url, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(body),
  });
  if (!res.ok) {
    throw new Error(`${res.status} ${res.statusText}`);
  }
  const { result } = await res.json();
  return result;
}

// Example: fetch first 50 compressed NFTs in a wallet
searchAssets({
  ownerAddress: "86xCnPeV69n6t3DnyGvkKobf9FdN2H9oiVDdaMpo2MMY",
  tokenType: "compressedNft",
  limit: 50,
}).then(console.log);
```

<Tip>
  The <code>page</code> parameter starts at <strong>1</strong>. For blazing-fast infinite scrolling, use cursor pagination (<code>before</code>/<code>after</code>).
</Tip>

***

## Core Concepts

### 1. Choosing a <code>tokenType</code>

<ParamField body="tokenType" type="string" required>
  A required string that specifies **what kind of assets** you want in the response.\
  Accepted values: <code>fungible</code>, <code>nonFungible</code>, <code>regularNft</code>, <code>compressedNft</code>, <code>all</code>.
</ParamField>

| tokenType       | What you get                          | Typical use-case              |
| --------------- | ------------------------------------- | ----------------------------- |
| `fungible`      | SPL & Token-22 tokens only            | Wallet balances, token-gating |
| `nonFungible`   | All NFTs (compressed **and** regular) | Portfolio overview            |
| `regularNft`    | Legacy & pNFTs (uncompressed)         | Marketplace listings          |
| `compressedNft` | cNFTs only                            | Ultra-cheap mass mints        |
| `all`           | Everything (tokens **and** NFTs)      | Catch-all discovery           |

***

### 2. Pagination & Sorting

Solana wallets can own thousands of assetsefficient paging matters.

* **Page / Limit**  classic pagination (`page` starts at **1**). Good for static views.
* **Cursor**  pass `before` or `after` values from the previous response for fast, infinite scrolling.

<CodeGroup>
  ```json5 sortBy
  "sortBy": {
    "sortBy": "created",      // created | recent_action | updated | none
    "sortDirection": "desc"   // asc | desc
  }
  ```
</CodeGroup>

<Tip>
  For full code samples on page/limit and cursor-based strategies, visit the dedicated [Pagination guide](/das/pagination).
</Tip>

### 3. Display Options (<code>options</code>)

These flags **add metadata**; they never change which assets are returned.

| Flag                     | Effect                                           |
| ------------------------ | ------------------------------------------------ |
| `showNativeBalance`      | Includes SOL balance of the wallet               |
| `showCollectionMetadata` | Adds collection-level JSON data                  |
| `showGrandTotal`         | Returns the total match count (slower)           |
| `showInscription`        | Appends inscription & SPL-20 info (experimental) |

<CodeGroup>
  ```json5 options
  "options": {
    "showNativeBalance": true,
    "showCollectionMetadata": true,
    "showGrandTotal": true,
    "showInscription": true
  }
  ```
</CodeGroup>

## Code Examples

### Searching for all Fungible Tokens in a wallet

```javascript
const url = `https://mainnet.helius-rpc.com/?api-key=YOUR_API_KEY`

const searchAssets = async () => {
  const response = await fetch(url, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      jsonrpc: '2.0',
      id: 'my-id',
      method: 'searchAssets',
      params: {
        ownerAddress: '86xCnPeV69n6t3DnyGvkKobf9FdN2H9oiVDdaMpo2MMY',
        tokenType: 'fungible',
      },
    }),
  });
  const { result } = await response.json();
  console.log("Search Assets: ", result);
};
searchAssets();
```

### Searching for all Fungible Tokens (showing native balance and token info)

```javascript
const url = `https://mainnet.helius-rpc.com/?api-key=YOUR_API_KEY`

const searchAssetsTokenInfo = async () => {
    const response = await fetch(url, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            jsonrpc: '2.0',
            id: 'my-id',
            method: 'searchAssets',
            params: {
                ownerAddress: '86xCnPeV69n6t3DnyGvkKobf9FdN2H9oiVDdaMpo2MMY',
                tokenType: 'fungible',
                displayOptions: {
                    showNativeBalance: true,
                },
            },
        }),
    });

    const { result } = await response.json();

    result.items.forEach(item => {
      console.log(item.token_info);
    });

    console.log("Native Balance: ", result.nativeBalance);
};

searchAssetsTokenInfo();
```

### Searching for Drip NFTs owned by vibhu.sol

```javascript
const url = `https://mainnet.helius-rpc.com/?api-key=YOUR_API_KEY`

const searchAssetsDrip = async () => {
  const response = await fetch(url, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      jsonrpc: '2.0',
      id: 'my-id',
      method: 'searchAssets',
      params: {
        ownerAddress: 'BAVjpySHMMGDpq3whU7qaqCCRE8ksCeGwxa53Qv2i8jS',
        grouping: ["collection", "DRiP2Pn2K6fuMLKQmt5rZWyHiUZ6WK3GChEySUpHSS4x"],
        page: 1,
        limit: 1000
      },
    }),
  });
  const { result } = await response.json();
  console.log("Drip Haus Assets: ", result);
};
searchAssetsDrip();
```

### Searching for Compressed Assets in a wallet

```javascript
const url = `https://mainnet.helius-rpc.com/?api-key=YOUR_API_KEY`

const searchAssetsCompressed = async () => {
  const response = await fetch(url, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      jsonrpc: '2.0',
      id: 'my-id',
      method: 'searchAssets',
      params: {
        ownerAddress: '2k5AXX4guW9XwRQ1AKCpAuUqgWDpQpwFfpVFh3hnm2Ha',
        compressed: true,
      },
    }),
  });
  const { result } = await response.json();
  console.log("Search Assets: ", result);
};
searchAssetsCompressed();
```

### Searching for Inscriptions & SPL-20 data

```javascript
const url = `https://mainnet.helius-rpc.com/?api-key=YOUR_API_KEY`

const searchAssetsInscriptions = async () => {
    const response = await fetch(url, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            jsonrpc: '2.0',
            id: 'my-id',
            method: 'searchAssets',
            params: {
                ownerAddress: '6GmTFg5SCs4zGfDEidUAJjS5pSrXEPwW8Rpfs3RHrbc5',
                tokenType: 'regularNft',
                displayOptions: {
                    showInscription: true,
                },
            },
        }),
    });

    const { result } = await response.json();
    console.log(result.items.map((i) => [i.id, i.inscription, i.spl20]));
};
searchAssetsInscriptions();
```


# Solana Data Streaming
Source: https://www.helius.dev/docs/data-streaming

Stream real-time Solana blocks, account updates, transaction data, and blockchain events. LaserStream gRPC, Enhanced WebSockets, and Webhooks solutions.

## What is Data Streaming on Solana?

Data streaming allows applications to receive real-time updates from the Solana blockchain as events occur on-chain. Instead of repeatedly polling for updates, streaming establishes persistent connections that push data to your application instantly when transactions are processed, accounts change, or blocks are produced.

This is essential for applications that require up-to-the-second data such as:

* **Trading applications** monitoring price changes and liquidations
* **DeFi protocols** tracking user interactions and state changes
* **NFT marketplaces** detecting sales, listings, and transfers
* **Analytics platforms** collecting comprehensive blockchain metrics
* **Wallets** showing real-time balance and transaction updates

## Why Choose Helius for Data Streaming?

<CardGroup cols={2}>
  <Card title="Ultra-Low Latency" icon="bolt">
    Direct connections to Solana leaders ensure sub-second data delivery
  </Card>

  <Card title="Enterprise Reliability" icon="shield-check">
    Multi-node redundancy and automatic failover for 99.9% uptime
  </Card>

  <Card title="Historical Replay" icon="clock-rotate-left">
    Never miss data with automatic backfill capabilities
  </Card>

  <Card title="Global Infrastructure" icon="globe">
    Endpoints in multiple regions for optimal performance worldwide
  </Card>
</CardGroup>

## Helius Streaming Solutions

We offer multiple streaming options to match your application's specific needs, from simple WebSocket connections to enterprise-grade streaming infrastructure.

### LaserStream (Professional+)

**Next-generation streaming with advanced features**

<Card title="LaserStream" icon="rocket" href="/laserstream">
  High-performance streaming with gRPC protocol, historical replay, and multi-node reliability
</Card>

**Key Features:**

* **Historical Replay**: Automatically backfill up to 3000 slots (\~20 minutes) of missed data
* **Multi-Protocol Support**: gRPC available now, WebSockets coming soon
* **Auto-Reconnection**: Built-in connection management with intelligent retry logic
* **Global Endpoints**: Available in 7+ regions worldwide for optimal latency
* **Drop-in Replacement**: Compatible with existing Yellowstone gRPC implementations

**Best For:** Backend services, high-throughput applications, mission-critical systems requiring guaranteed data delivery

### Enhanced WebSockets (Business+)

**High-performance WebSockets with advanced filtering**

<Card title="Enhanced WebSockets" icon="signal-stream" href="/enhanced-websockets">
  Faster WebSocket connections with enhanced account and transaction subscriptions
</Card>

**Key Features:**

* **Faster Response Times**: Optimized for lower latency than standard WebSockets
* **Enhanced Filtering**: Advanced subscription options for precise data targeting
* **Account & Transaction Subscriptions**: Monitor specific accounts or transaction patterns
* **Atlas Infrastructure**: Powered by our high-performance streaming backend

**Best For:** Real-time frontend applications, moderate-volume backends, custom filtering requirements

### Standard WebSockets

**Solana-compatible WebSocket API with Helius reliability**

<Card title="Standard WebSockets" icon="wifi" href="/rpc/websocket">
  Standard Solana WebSocket methods enhanced with Helius infrastructure reliability
</Card>

**Key Features:**

* **Full Compatibility**: Works with any Solana WebSocket client library
* **Standard Methods**: All supported Solana subscription types (accounts, programs, logs, signatures, slots)
* **Multiple Networks**: Available on mainnet and devnet
* **Helius Reliability**: Enhanced uptime and performance over standard RPC nodes

**Best For:** Existing applications, standard use cases, broad compatibility requirements

### Webhooks

**Event-driven notifications delivered to your endpoints**

<Card title="Webhooks" icon="webhook" href="/webhooks">
  Server-to-server event notifications for specific on-chain activities
</Card>

**Key Features:**

* **Parsed Event Data**: Human-readable transaction data for sales, swaps, and more
* **Multiple Types**: Enhanced, raw, and Discord webhook options
* **Transaction Filtering**: Subscribe to specific event types and addresses
* **Reliable Delivery**: Automatic retries and delivery confirmations

**Best For:** Event-driven architectures, notification systems, integrations with external services

## Getting Started

<Steps>
  <Step title="Choose Your Solution">
    Select the streaming method that best fits your application requirements and infrastructure.
  </Step>

  <Step title="Get Your API Key">
    Sign up at [dashboard.helius.dev](https://dashboard.helius.dev) and obtain your API key.
  </Step>

  <Step title="Follow the Quickstart">
    Each solution has dedicated quickstart guides and code examples.
  </Step>

  <Step title="Monitor & Scale">
    Use the Helius dashboard to monitor usage and scale your plan as needed.
  </Step>
</Steps>

<Card title="Data Streaming Quickstart" icon="play" href="/data-streaming/quickstart">
  Get up and running with your first streaming connection in minutes
</Card>

## Support & Community

<CardGroup cols={3}>
  <Card title="Documentation" icon="book-open" href="/api-reference">
    Comprehensive API references and guides for all streaming methods
  </Card>

  <Card title="Discord Community" icon="discord" href="https://discord.com/invite/6GXdee3gBj">
    Join thousands of developers building on Solana with Helius
  </Card>

  <Card title="Enterprise Support" icon="headset" href="/support">
    Priority support channels for business and professional customers
  </Card>
</CardGroup>

Ready to start streaming Solana data? Choose your preferred method above and dive into the documentation!


# Solana Data Streaming Quickstart
Source: https://www.helius.dev/docs/data-streaming/quickstart

Get your first real-time Solana data stream running in under 5 minutes. LaserStream, Enhanced WebSockets, and Webhooks setup guide.

## Quick Setup

Get streaming Solana data in minutes with working code examples. Choose your approach based on your needs:

| Method                  | Best For                                  | Plan Required | Latency      |
| ----------------------- | ----------------------------------------- | ------------- | ------------ |
| **LaserStream gRPC**    | Mission-critical, backend services        | Professional+ | **Fastest**  |
| **Enhanced WebSockets** | Advanced filtering, high-performance apps | Business+     | **Fast**     |
| **Standard WebSockets** | Most applications, existing Solana code   | Free+         | **Good**     |
| **Webhooks**            | Server notifications, event-driven apps   | Free+         | **Variable** |

## Option 1: Standard WebSockets

Perfect for most use cases and compatible with existing Solana WebSocket code.

```javascript
const WebSocket = require('ws');

const ws = new WebSocket('wss://mainnet.helius-rpc.com?api-key=YOUR_API_KEY');

ws.on('open', () => {
  console.log('Connected to Helius');
  
  // Subscribe to account changes
  ws.send(JSON.stringify({
    jsonrpc: "2.0",
    id: 1,
    method: "accountSubscribe",
    params: [
      "9PejEmViKHgUkVFWN57cNEZnFS4Qo6SzsLj5UPAXfDTF", // Replace with your account
      { encoding: "jsonParsed", commitment: "confirmed" }
    ]
  }));
});

ws.on('message', (data) => {
  const message = JSON.parse(data);
  if (message.method === 'accountNotification') {
    console.log('Account updated:', message.params.result.value);
  }
});
```

**Replace `YOUR_API_KEY`** with your key from [dashboard.helius.dev](https://dashboard.helius.dev)

<Card title="Standard WebSockets Guide" icon="arrow-right" href="/rpc/websocket">
  Complete reference with all subscription methods and examples
</Card>

## Option 2: Enhanced WebSockets

For applications needing advanced filtering and faster performance.

```javascript
const WebSocket = require('ws');

const ws = new WebSocket('wss://atlas-mainnet.helius-rpc.com/?api-key=YOUR_API_KEY');

ws.on('open', () => {
  console.log('Enhanced WebSocket connected');
  
  // Subscribe to transactions involving specific accounts
  ws.send(JSON.stringify({
    jsonrpc: "2.0",
    id: 1,
    method: "transactionSubscribe",
    params: [
      {
        accountInclude: ["TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"],
        vote: false,
        failed: false
      },
      {
        commitment: "confirmed",
        encoding: "jsonParsed",
        transactionDetails: "full"
      }
    ]
  }));
  
  // Keep connection alive
  setInterval(() => ws.ping(), 30000);
});

ws.on('message', (data) => {
  const message = JSON.parse(data);
  console.log('Transaction:', message);
});
```

<Card title="Enhanced WebSockets Guide" icon="arrow-right" href="/enhanced-websockets">
  Learn advanced filtering and subscription options
</Card>

## Option 3: LaserStream gRPC

Most reliable option with historical replay and multi-node failover.

```bash
npm install helius-laserstream
```

```typescript
import { subscribe, CommitmentLevel, LaserstreamConfig, SubscribeRequest } from 'helius-laserstream';

async function main() {
  const subscriptionRequest: SubscribeRequest = {
    transactions: {
      client: {
        accountInclude: ['TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'],
        accountExclude: [],
        accountRequired: [],
        vote: false,
        failed: false
      }
    },
    commitment: CommitmentLevel.CONFIRMED,
    accounts: {},
    slots: {},
    transactionsStatus: {},
    blocks: {},
    blocksMeta: {},
    entry: {},
    accountsDataSlice: [],
  };

  const config: LaserstreamConfig = {
    apiKey: 'YOUR_API_KEY',
    endpoint: 'https://laserstream-mainnet-ewr.helius-rpc.com',
  }

  await subscribe(config, subscriptionRequest, async (data) => {
    console.log(data);
  }, async (error) => {
    console.error(error);
  });
}

main().catch(console.error);
```

<Card title="LaserStream Guide" icon="arrow-right" href="/laserstream">
  Complete LaserStream documentation with historical replay
</Card>

## Option 4: Webhooks

For server-side applications that need event notifications.

```bash
# Create a webhook
curl -X POST "https://api.helius.xyz/v0/webhooks" \
  -H "Authorization: Bearer YOUR_API_KEY" \
  -H "Content-Type: application/json" \
  -d '{
    "webhookURL": "https://your-server.com/webhook",
    "transactionTypes": ["Any"],
    "accountAddresses": ["YOUR_ACCOUNT_ADDRESS"],
    "webhookType": "enhanced"
  }'
```

```javascript
// Handle webhook events (Express.js example)
app.post('/webhook', (req, res) => {
  req.body.forEach(event => {
    console.log('Blockchain event:', event);
  });
  res.status(200).send('OK');
});
```

<Card title="Webhooks Guide" icon="arrow-right" href="/webhooks">
  Complete webhook setup and event handling
</Card>

## Common Use Cases

**Monitor Token Transfers**

```javascript
// Subscribe to Token Program activity
method: "programSubscribe",
params: ["TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA", {...}]
```

**Track NFT Sales**

```javascript
// Subscribe to Magic Eden program
method: "programSubscribe", 
params: ["M2mx93ekt1fmXSVkTrUL9xVFHkmME8HTUi5Cyc5aF7K", {...}]
```

**Watch Wallet Activity**

```javascript
// Monitor specific wallet
method: "accountSubscribe",
params: ["WALLET_ADDRESS", {...}]
```

## Next Steps

<CardGroup cols={2}>
  <Card title="Streaming Overview" icon="play" href="/data-streaming">
    Learn about all streaming options and when to use each
  </Card>

  <Card title="API Reference" icon="book" href="/api-reference">
    Complete method documentation and parameters
  </Card>
</CardGroup>

**Need help?** Join our [Discord](https://discord.com/invite/6GXdee3gBj) or check [support docs](/support).


# Solana Dedicated Nodes: High-Performance gRPC Streaming
Source: https://www.helius.dev/docs/dedicated-nodes

Dedicated Solana nodes optimized for gRPC streaming applications. Ultra-low latency blockchain data for trading, analytics, and real-time monitoring.

<Note>
  **Considering streaming data?** [LaserStream](/laserstream) is our recommended solution for most streaming use cases. It offers enhanced reliability, historical replay, auto-reconnection, and multi-node failover without infrastructure management. [Compare LaserStream vs Dedicated Nodes](/laserstream/laserstream-vs-dedicated-nodes) to choose the right solution for your needs.
</Note>

**Dedicated nodes are specifically designed for gRPC streaming applications** and should be combined with a shared plan for comprehensive Solana development needs:

* **gRPC Streaming**: Real-time blockchain data streaming with ultra-low latency
* **Data Monitoring**: Account, transaction, and block updates via Yellowstone Geyser
* **Trading Applications**: High-frequency data feeds for algorithmic trading
* **Analytics**: Real-time blockchain analytics and monitoring

## Node Options

* AMD EPYC 7443p
* AMD EPYC 7543p (Best for resource-intensive RPC calls)
* AMD EPYC 9254 (Best for resource-intensive RPC calls)

## Access Includes

* **gRPC streaming** via [Yellowstone Geyser Plugin](/grpc) (primary use case)
* Standard RPC and WebSocket methods (basic functionality only)
* Premium support
* Node clients  Agave (recommended) or Jito Labs

## Limitations

<Note>
  **Important**: Dedicated nodes have specific limitations and are not suitable as standalone solutions:

  * **`sendTransaction` Poor Landing Rates**: While supported, not optimized - most transactions will not land
  * **No Archival Data**: Historical data access is not available
  * **`getProgramAccounts` Performance Risk**: While supported, heavy usage can impact node performance or cause node failure
  * **No Platform Features**: APIs, webhooks, and staked connections require a shared plan

  **Recommendation**: Use dedicated nodes for gRPC streaming in combination with a shared paid plan for comprehensive functionality.
</Note>

## Dedicated Fleets

If your team needs a cluster of multiple Dedicated Nodes [contact our sales team](https://form.typeform.com/to/KiacmxpZ). We'll review your requirements and help you with a custom solution.

<Card title="Ready to Get Started?" icon="rocket">
  To learn how to order a dedicated node, see [How to Order](/dedicated-nodes/getting-started).
</Card>


# Solana Dedicated Nodes Best Practices: Optimize Performance
Source: https://www.helius.dev/docs/dedicated-nodes/best-practices

Optimize your Solana dedicated node performance with best practices for gRPC streaming, load management, and node health monitoring.

## Best Practices

### Primary Use: gRPC Streaming

**Dedicated nodes are optimized for gRPC streaming applications**. For the best experience:

* **Use with Yellowstone Geyser Plugin**: This is the primary and recommended use case for dedicated nodes
* **Combine with a shared plan**: For `sendTransaction`, archival data, and complex account queries, use your shared plan endpoints
* **Focus on streaming**: Leverage dedicated nodes for real-time data streaming, monitoring, and analytics

### Managing Node Load

While nodes don't have strict usage limits, they are bound by hardware constraints. A balanced workload helps maintain optimal performance and node liveliness.

* **Use `getProgramAccounts` carefully**: While supported, dedicated nodes are not optimized for these calls - heavy usage can impact performance or cause node failure
  * Use your shared plan for `getProgramAccounts` queries as we have a [**custom indexer**](https://x.com/heliuslabs/status/1864750969755422797) that makes those calls much faster and more reliable
* **Poor transaction landing rates**: While `sendTransaction` is supported, it's not optimized - most transactions will not land; use your shared plan for reliable transaction submission
* **No archival queries**: Historical data access should be done through your shared plan
* Monitor your node's metrics to understand its performance based on response times, successful request %, and error counts
* Consider distributing intensive workloads across multiple nodes in a dedicated fleet

<Warning>
  **Remember**: Dedicated nodes limitations:

  * `sendTransaction` supported but not optimized - most transactions will not land
  * No archival data access
  * `getProgramAccounts` supported but not optimized - heavy usage can impact performance or cause node failure
  * No platform APIs, webhooks, or staked connections

  Use your shared paid plan for these features.
</Warning>

<Note>
  If your team needs a cluster of multiple dedicated nodes, [contact our sales team](https://form.typeform.com/to/KiacmxpZ). We will take in your requirements and configure a dedicated fleet for your team.
</Note>

### System Recovery

Our nodes include an automatic recovery mechanism:

* If a node falls too far behind in processing slots, it will automatically initiate a restart
* During this recovery period, all requests are seamlessly routed to our shared backup pool
* Once your node catches up and becomes healthy, traffic will resume to it

### Questions and Support

* Contact us through your Telegram group (available for dedicated node customers)
* You can also get support from the chat system on our website or in our Discord server


# Solana Dedicated Nodes Setup: Complete Getting Started Guide
Source: https://www.helius.dev/docs/dedicated-nodes/getting-started

Complete guide to setting up your Solana dedicated node with gRPC streaming, Yellowstone plugin, and optimal configuration for blockchain data.

## How to Order Dedicated Nodes

Dedicated Nodes can be ordered directly from the [developer portal](https://dashboard.helius.dev/dedicated-nodes) on the Dedicated Nodes tab.

<Frame caption="Order a dedicated node from your Helius dashboard">
  <img src="https://mintlify.s3.us-west-1.amazonaws.com/helius/images/dedicated-nodes-order.png" alt="Order a dedicated node from your Helius dashboard" />
</Frame>

### Node Type

The type of node you choose depends on your requirements. Since we don't impose any rate limits, your node's performance will rely entirely on its specifications.

**For gRPC streaming applications** (primary use case), any node type will perform well.

<Warning>
  **Important**: While `getProgramAccounts` is supported, dedicated nodes are not optimized for these calls. Heavy usage can impact node performance or even cause node failure. Use your shared plan for `getProgramAccounts` queries as it has a custom indexer that makes these calls much faster and more reliable.
</Warning>

<Frame caption="Choose your dedicated node's type and location">
  <img src="https://mintlify.s3.us-west-1.amazonaws.com/helius/images/dedicated-nodes-type-and-location.png" alt="Choose your dedicated node's type and location" />
</Frame>

### Node Location

We offer nodes across multiple regions: in North America (Pittsburgh, Newark, Salt Lake City, Los Angeles, Vancouver); in Europe (Dublin, London, Amsterdam, Frankfurt); and in Asia (Tokyo, Singapore) to ensure the best geographic coverage with the global Solana infrastructure.

For optimal latency, choose a node closest to your server. Your node will be deployed within three hours of payment.

### Node Client

You can customize your node by selecting the client type  either Agave or Jito Labs (fork of Agave with an additional method `simulateBundle`)

<Frame caption="Select your dedicated node's client type">
  <img src="https://mintlify.s3.us-west-1.amazonaws.com/helius/images/dedicated-nodes-client-type.png" alt="Select your dedicated node's client type" />
</Frame>

<Note>
  Dedicated nodes **cannot** send Jito Bundles on their own. To send Jito Bundles, you must use the Jito API, which handles packaging and sending the bundles through Jito's system.

  To simplify this process, our SDK provides an easy method called [Send Jito Bundle](https://github.com/helius-labs/helius-sdk/tree/main?tab=readme-ov-file#sendJitoBundle).
</Note>

### Geyser Plugin (Recommended)

**We strongly recommend adding the [Yellowstone](https://github.com/helius-labs/yellowstone-grpc) Geyser Plugin**, which is the primary use case for dedicated nodes. It provides high-performance [gRPC streaming](/grpc) of slots, blocks, transactions, and account updates.

<Frame caption="Select the Yellowstone gRPC Geyser Plugin (Recommended)">
  <img src="https://mintlify.s3.us-west-1.amazonaws.com/helius/images/dedicated-nodes-geyser-plugin.png" alt="Select the Yellowstone gRPC Geyser Plugin (Recommended)" />
</Frame>

<Note>
  **Best Practice**: Dedicated nodes are optimized for gRPC streaming. Use your shared plan for transaction submission, archival queries, and complex RPC operations.
</Note>

### Payment Options

You can pay via fiat or crypto (USDC). Once your payment goes through, your node will be deployed within 3 hours.

For billing, fiat payments will receive a discount on the next month's bill for the number of days it took to provision the node. For crypto payments, the billing cycle starts once the node is delivered.

### Demo

<iframe width="560" height="315" src="https://www.youtube.com/embed/KjgUzY_3dsQ?si=r3aKXpc_H6b7hnqE" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen />

## Getting Started

Once you have your Dedicated Node set up and ready (status: **Succeeded**), you can start working with it. For information about the dashboard and managing your node, see the [Dashboard](/dedicated-nodes/dashboard) page.

## Connecting to your dedicated node

### gRPC Streaming (Primary Use Case)

**Dedicated nodes are optimized for gRPC streaming via the Yellowstone Geyser Plugin.** This is the primary and recommended way to use your dedicated node.

<Info>
  **Consider LaserStream for gRPC Streaming**: LaserStream offers superior performance, reliability, and advanced features like historical replay for gRPC streaming. It's recommended for 99% of streaming use cases. [Compare LaserStream vs Dedicated Nodes](/laserstream/laserstream-vs-dedicated-nodes) to choose the best solution for your needs.
</Info>

### Basic RPC and Websocket (Limited Functionality)

Each dedicated node also provides basic RPC functionality, but with limitations. **For production applications, combine dedicated nodes with a shared plan.**

Here we are using Solana web3.js to call [`getSlot`](/api-reference/rpc/http/getslot) using our dedicated node:

```javascript
// Using @solana/web3.js
const { Connection } = require('@solana/web3.js');

const connection = new Connection('https://liveried-grazings-gxzjabdgqa-dedicated.helius-rpc.com?api-key=465964ff-f718-47d2-a51c-66ddcce332d7');

// Get the current slot
const getSlot = async () => {
    const slot = await connection.getSlot();
    console.log('Current slot:', slot);
};

getSlot();
```

This is how you would set up a native websocket connection to stream new slots:

```javascript
const Websocket = require('ws');
const ws = new Websocket('wss://liveried-grazings-gxzjabdgqa-dedicated.helius-rpc.com?api-key=465964ff-f718-47d2-a51c-66ddcce332d7	');

ws.onopen = () => {
    ws.send(JSON.stringify({
        jsonrpc: '2.0',
        id: 1,
        method: 'slotSubscribe'
    }));
};

ws.onmessage = (event) => {
    console.log(JSON.parse(event.data));
};
```

<Warning>
  **Remember**: The above RPC examples are for basic functionality only. Dedicated nodes limitations:

  * `sendTransaction` supported but not optimized - most transactions will not land (use your shared plan for reliable transaction submission)
  * No archival data queries (use your shared plan)
  * `getProgramAccounts` supported but not optimized - heavy usage can impact performance or cause node failure (use your shared plan for reliability)

  **Primary use case**: Use the gRPC streaming setup below for optimal performance.
</Warning>

### Set up your Geyser Plugin

To begin using the Geyser plugin you need to clone the Yellowstone repo:

```shell
git clone https://github.com/helius-labs/yellowstone-grpc.git
```

#### Using the CLI

```sh
cd yellowstone-grpc/examples/rust/
cargo run --bin client -- -e "https://liveried-grazings-gxzjabdgqa-dedicated-lb.helius-rpc.com:2053" --x-token 42f03938-1daa-4162-a457-bb551ecaf590 subscribe --slots
```

Once complete, you should see the terminal output new slots. Don't forget to replace the URL and Token with your own.

<Frame caption="Terminal output of new slots">
  <img src="https://mintlify.s3.us-west-1.amazonaws.com/helius/images/slots.png" />
</Frame>

### TypeScript Example

This example streams all Raydium transactions live in JSON format:

```typescript
import Client, { CommitmentLevel, SubscribeRequest } from "@triton-one/yellowstone-grpc";
import * as bs58 from 'bs58';

const processBuffers = (obj: any): any =>
  !obj ? obj :
  Buffer.isBuffer(obj) || obj instanceof Uint8Array ? bs58.encode(obj) :
  Array.isArray(obj) ? obj.map(processBuffers) :
  typeof obj === 'object' ? Object.fromEntries(Object.entries(obj).map(([k, v]) => [k, processBuffers(v)])) :
  obj;

const main = async () => {
  const client = new Client("grpc_url", 
    "x_token", 
    { "grpc.max_receive_message_length": 64 * 1024 * 1024 });

  const stream = await client.subscribe();
  const write = (req: SubscribeRequest) => new Promise<void>((resolve, reject) => 
    stream.write(req, (err) => err ? reject(err) : resolve()));

  stream.on("data", (data) => {
    try { console.log(JSON.stringify(processBuffers(data), null, 2)); }
    catch (e) { console.error('Error:', e); }
  });

  await write({
    slots: {},
    accounts: {},
    accountsDataSlice: [],
    transactions: {
      allRaydiumTxs: {
        accountInclude: ["675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8"],
        accountExclude: [],
        accountRequired: [],
      }
    },
    blocks: {},
    blocksMeta: {},
    entry: {},
    commitment: CommitmentLevel.PROCESSED,
  });

  setInterval(() => write({
    ping: { id: 1 },
    accounts: {},
    accountsDataSlice: [],
    transactions: {},
    blocks: {},
    blocksMeta: {},
    entry: {},
    slots: {},
  }).catch(console.error), 30000);

  await new Promise<void>((resolve, reject) => {
    stream.on("error", (e) => { console.error("Stream error:", e); reject(e); stream.end(); });
    stream.on("end", resolve);
    stream.on("close", resolve);
  });
};

main().catch(console.error);
```

<Frame caption="Example output of a partial Raydium transaction">
  <img src="https://mintlify.s3.us-west-1.amazonaws.com/helius/images/raydium-tx.png" />
</Frame>


# Solana Enhanced Transactions API
Source: https://www.helius.dev/docs/enhanced-transactions

Transform complex Solana blockchain transactions into human-readable data with Helius Enhanced Transactions API. Parse transaction details, fetch history, and understand on-chain activity without manual decoding.

<CardGroup cols={2}>
  <Card title="Parse Transaction(s)" icon="code" href="#parse-individual-transactions">
    Parse individual or multiple transactions to get human-readable data
  </Card>

  <Card title="Transaction History" icon="clock-rotate-left" href="#fetch-transaction-history-for-an-address">
    Get historical transaction data for any address
  </Card>
</CardGroup>

<Note>
  **Quick Reference**:

  * `/v0/transactions` - Parse individual or multiple transaction signatures
  * `/v0/addresses/{address}/transactions` - Get transaction history for an address
  * Filter by transaction type using the `type` parameter (e.g., `NFT_SALE`, `SWAP`, `TRANSFER`)
</Note>

<Warning>
  **Important Limitations**:

  * Enhanced Transaction API V1 won't be updated while we are working on V2
  * We only parse NFT, Jupiter, and SPL-related transactions
  * **Do not rely on these parsers for DeFi or non-NFT, Jupiter, and SPL transactions**
</Warning>

## Overview

The Enhanced Transactions API transforms complex Solana transactions into human-readable data. Instead of dealing with raw instruction data and account lists, you get structured information about:

* What happened in the transaction (transfers, swaps, NFT activities)
* Which accounts were involved
* How much SOL or tokens were transferred
* Timestamps and other metadata

## Getting Started

### Parse Individual Transactions

Parse one or more transaction signatures or raw transaction data with a single API call:

<Tabs>
  <Tab title="JavaScript">
    ```javascript
    const parseTransaction = async () => {
      const url = "https://api.helius.xyz/v0/transactions/?api-key=YOUR_API_KEY";

      const response = await fetch(url, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          transactions: ["5rfFLBUp5YPr6rC2g1KBBW8LGZBcZ8Lvs7gKAdgrBjmQvFf6EKkgc5cpAQUTwGxDJbNqtLYkjV5vS5zVK4tb6JtP"],
        }),
      });

      const data = await response.json();
      console.log("Parsed transaction:", data);
    };

    parseTransaction();
    ```
  </Tab>

  <Tab title="Python">
    ```python
    import requests
    import json

    def parse_transaction():
        url = "https://api.helius.xyz/v0/transactions/?api-key=YOUR_API_KEY"
        
        payload = {
            "transactions": ["5rfFLBUp5YPr6rC2g1KBBW8LGZBcZ8Lvs7gKAdgrBjmQvFf6EKkgc5cpAQUTwGxDJbNqtLYkjV5vS5zVK4tb6JtP"]
        }
        
        response = requests.post(url, json=payload)
        data = response.json()
        print("Parsed transaction:", data)
        
    parse_transaction()
    ```
  </Tab>
</Tabs>

<Card title="API Reference" horizontal icon="code" href="/api-reference/enhanced-transactions/gettransactions">
  View detailed documentation for parsing transactions
</Card>

### Fetch Transaction History for an Address

Retrieve transaction history for any Solana address:

<Tabs>
  <Tab title="JavaScript">
    ```javascript
    const fetchWalletTransactions = async () => {
      const walletAddress = "M2mx93ekt1fmXSVkTrUL9xVFHkmME8HTUi5Cyc5aF7K"; // Replace with target wallet
      const url = `https://api.helius.xyz/v0/addresses/${walletAddress}/transactions?api-key=YOUR_API_KEY`;
      
      const response = await fetch(url);
      const transactions = await response.json();
      console.log("Wallet transactions:", transactions);
    };

    fetchWalletTransactions();
    ```
  </Tab>

  <Tab title="Python">
    ```python
    import requests

    def fetch_wallet_transactions():
        wallet_address = "M2mx93ekt1fmXSVkTrUL9xVFHkmME8HTUi5Cyc5aF7K"  # Replace with target wallet
        url = f"https://api.helius.xyz/v0/addresses/{wallet_address}/transactions?api-key=YOUR_API_KEY"
        
        response = requests.get(url)
        transactions = response.json()
        print("Wallet transactions:", transactions)
        
    fetch_wallet_transactions()
    ```
  </Tab>
</Tabs>

<Card title="API Reference" horizontal icon="code" href="/api-reference/enhanced-transactions/gettransactionsbyaddress">
  View detailed documentation for transaction history
</Card>

<Warning>
  **Handling Incomplete Transaction Sets**

  Occasionally, history endpoint may return an incomplete set of transactions due to internal timeouts during data retrieval.

  To mitigate this issue:

  1. First, call `getSignaturesForAddress` to retrieve a batch of transaction signatures
  2. Next, use the `/v0/transactions` endpoint with the received signatures
  3. If any transactions are missing from the response, you can retry fetching these specific transactions
</Warning>

## Common Use Cases

### Complete Pagination Example

For high-volume addresses, implement pagination to fetch all transactions:

```javascript
const fetchAllTransactions = async () => {
  const walletAddress = "2k5AXX4guW9XwRQ1AKCpAuUqgWDpQpwFfpVFh3hnm2Ha"; // Replace with target wallet
  const baseUrl = `https://api.helius.xyz/v0/addresses/${walletAddress}/transactions?api-key=YOUR_API_KEY`;
  let url = baseUrl;
  let lastSignature = null;
  let allTransactions = [];
  
  while (true) {
    if (lastSignature) {
      url = baseUrl + `&before=${lastSignature}`;
    }
    
    const response = await fetch(url);
    
    // Check response status
    if (!response.ok) {
      console.error(`API error: ${response.status}`);
      break;
    }
    
    const transactions = await response.json();
    
    if (transactions && transactions.length > 0) {
      console.log(`Fetched batch of ${transactions.length} transactions`);
      allTransactions = [...allTransactions, ...transactions];
      lastSignature = transactions[transactions.length - 1].signature;
    } else {
      console.log(`Finished! Total transactions: ${allTransactions.length}`);
      break;
    }
  }
  
  return allTransactions;
};
```

### Filter Transactions by Type

Get only specific transaction types, such as NFT sales:

<Tabs>
  <Tab title="NFT Sales">
    ```javascript
    const fetchNftSales = async () => {
      const tokenAddress = "GjUG1BATg5V4bdAr1csKys1XK9fmrbntgb1iV7rAkn94"; // NFT mint address
      const url = `https://api.helius.xyz/v0/addresses/${tokenAddress}/transactions?api-key=YOUR_API_KEY&type=NFT_SALE`;
      
      const response = await fetch(url);
      const nftSales = await response.json();
      console.log("NFT sale transactions:", nftSales);
    };
    ```
  </Tab>

  <Tab title="Token Transfers">
    ```javascript
    const fetchTokenTransfers = async () => {
      const walletAddress = "M2mx93ekt1fmXSVkTrUL9xVFHkmME8HTUi5Cyc5aF7K"; // Wallet address
      const url = `https://api.helius.xyz/v0/addresses/${walletAddress}/transactions?api-key=YOUR_API_KEY&type=TRANSFER`;
      
      const response = await fetch(url);
      const transfers = await response.json();
      console.log("Transfer transactions:", transfers);
    };
    ```
  </Tab>

  <Tab title="Swaps">
    ```javascript
    const fetchSwapTransactions = async () => {
      const walletAddress = "M2mx93ekt1fmXSVkTrUL9xVFHkmME8HTUi5Cyc5aF7K"; // Wallet address
      const url = `https://api.helius.xyz/v0/addresses/${walletAddress}/transactions?api-key=YOUR_API_KEY&type=SWAP`;
      
      const response = await fetch(url);
      const swaps = await response.json();
      console.log("Swap transactions:", swaps);
    };
    ```
  </Tab>
</Tabs>

## API Reference

### Query Parameters

| Parameter    | Description                              | Default     | Example                 |
| ------------ | ---------------------------------------- | ----------- | ----------------------- |
| `limit`      | Number of transactions to return         | 10          | `&limit=25`             |
| `before`     | Fetch transactions before this signature | -           | `&before=sig123...`     |
| `until`      | Fetch transactions until this signature  | -           | `&until=sig456...`      |
| `type`       | Filter by transaction type               | -           | `&type=NFT_SALE`        |
| `commitment` | Commitment level                         | `finalized` | `&commitment=confirmed` |

### Response Example

Enhanced transaction responses include structured data with human-readable descriptions:

```json
{
  "description": "Transfer 0.1 SOL to FXvStt8aeQHMGKDgqaQ2HXWfJsXnqiKSoBEpHJahkuD",
  "type": "TRANSFER",
  "source": "SYSTEM_PROGRAM",
  "fee": 5000,
  "feePayer": "M2mx93ekt1fmXSVkTrUL9xVFHkmME8HTUi5Cyc5aF7K",
  "signature": "5rfFLBUp5YPr6rC2g1KBBW8LGZBcZ8Lvs7gKAdgrBjmQvFf6EKkgc5cpAQUTwGxDJbNqtLYkjV5vS5zVK4tb6JtP",
  "slot": 171341028,
  "timestamp": 1674080473,
  "nativeTransfers": [
    {
      "fromUserAccount": "M2mx93ekt1fmXSVkTrUL9xVFHkmME8HTUi5Cyc5aF7K",
      "toUserAccount": "FXvStt8aeQHMGKDgqaQ2HXWfJsXnqiKSoBEpHJahkuD",
      "amount": 100000000
    }
  ],
  "events": {
    "sol": {
      "from": "M2mx93ekt1fmXSVkTrUL9xVFHkmME8HTUi5Cyc5aF7K",
      "to": "FXvStt8aeQHMGKDgqaQ2HXWfJsXnqiKSoBEpHJahkuD",
      "amount": 0.1
    }
  }
}
```

## Best Practices

<CardGroup cols={2}>
  <Card title="Error Handling" icon="shield-check">
    Implement proper error handling and retries for production applications
  </Card>

  <Card title="Rate Limiting" icon="gauge-high">
    Use pagination and caching strategies to avoid hitting rate limits
  </Card>
</CardGroup>

### Error Handling

Always implement proper error handling in your code:

```javascript
const fetchTransactions = async () => {
  try {
    const response = await fetch(url);
    
    if (!response.ok) {
      throw new Error(`API error: ${response.status}`);
    }
    
    const data = await response.json();
    return data;
  } catch (error) {
    console.error("Failed to fetch transactions:", error);
    // Implement retry logic or user-friendly error messages
  }
};
```

### Rate Limiting Considerations

To avoid hitting rate limits when working with the API:

* Implement pagination for large datasets
* Cache responses when appropriate
* Add exponential backoff for retries
* Consider upgrading your API plan for high-volume applications

<Tip>
  For high-traffic applications, consider implementing a caching layer with Redis or similar technology to minimize redundant API calls.
</Tip>

## FAQs

<AccordionGroup>
  <Accordion title="What is the Enhanced Transactions API?">
    The Enhanced Transactions API provides parsed transaction data in a human-readable format. It allows you to parse individual or multiple transactions or fetch the complete historical transaction history for a specific address.
  </Accordion>

  <Accordion title="What types of transactions can be parsed?">
    Currently, the Enhanced Transactions API only parses NFT, Jupiter, and SPL-related transactions. Do not rely on these parsers for DeFi or non-NFT, Jupiter, and SPL transactions.
  </Accordion>

  <Accordion title="What's the difference between V1 and V2?">
    Enhanced Transaction API V1 won't be updated while we are working on V2. V2 will introduce additional parsing capabilities and improvements.
  </Accordion>

  <Accordion title="How do I authenticate API requests?">
    All requests to the Enhanced Transactions API require your Helius API key, which should be provided as a query parameter (`?api-key=YOUR_API_KEY`).
  </Accordion>

  <Accordion title="Are there rate limits?">
    Yes, API usage is subject to Helius's standard rate limiting and pricing policies. Please refer to the [Plans & Rate limits](/billing/plans-and-rate-limits) page for more information.
  </Accordion>
</AccordionGroup>


# Solana Enhanced WebSockets
Source: https://www.helius.dev/docs/enhanced-websockets

Stream real-time Solana transaction and account updates with enhanced WebSocket integration. Faster response times and advanced filtering capabilities.

## What are Enhanced Websockets?

Helius provides Enhanced WebSockets in addition to Solana's standard WebSocket methods. These enhanced WebSockets offer faster response times than traditional WebSockets. We support two subscription methods: `transactionSubscribe` and `accountSubscribe`.

<Info>
  This feature is available exclusively for **business and professional plans**. Please note that this is the **Enhanced WebSocket**, not **Yellowstone gRPC**. For Yellowstone gRPC functionality, you can use either [**LaserStream**](/laserstream/) or a [**Dedicated Node**](/dedicated-nodes/).
</Info>

## Subscription Endpoints

Geyser-enhanced WebSockets are currently available on `mainnet` and `devnet` with the following URLs

**Mainnet:** `wss://atlas-mainnet.helius-rpc.com/?api-key=<API_KEY>`

**Devnet:** `wss://atlas-devnet.helius-rpc.com/?api-key=<API_KEY>`

<Warning>
  Websockets have a 10-minute inactivity timer; to keep the WebSocket connection alive, it is highly recommended that health checks be implemented and that pings be sent every minute.
</Warning>


# Account Subscribe
Source: https://www.helius.dev/docs/enhanced-websockets/account-subscribe

Stream real-time Solana account updates with account subscribe. Monitor balance changes, data modifications, and lamport updates via WebSocket.

## Account Subscribe

Solana's Websockets support a method that allows you to subscribe to an account and receive notifications via the WebSocket connection whenever there are changes to the lamports or data associated with a matching account public key. This method aligns directly with the Solana [Websocket API specification](https://solana.com/docs/rpc/websocket#accountsubscribe).

### **Parameters**

`string`: The account public key, sent in base58 format (required).

`object`: An optional object used to pass additional parameters.

* `encoding`: Specifies the format for data returned in the AccountNotification. Supported values: **base58**, **base64**, **base64+zstd**, **jsonParsed** (default is **base58**).
* `commitment`: Defines the commitment level for the transaction. Supported values: **finalized**, **confirmed**, **processed** (default is **finalized**).

## Examples

### Basic Account Subscribe Example

<AccordionGroup>
  <Accordion title="Code Example">
    In this example, we are subscribing to account changes for the  account `SysvarC1ock11111111111111111111111111111111` . \
    \
    We will see an update whenever a change occurs to the account data or the lamports for this account.\
    This happens at a frequent interval for this specific account as the `slot` and `unixTimestamp` are both a part of the returned account data.

    ```javascript
    // Create a WebSocket connection
    const ws = new WebSocket('wss://atlas-mainnet.helius-rpc.com?api-key=<API_KEY>');

    // Function to send a request to the WebSocket server
    function sendRequest(ws) {
        const request = {
            jsonrpc: "2.0",
            id: 420,
            method: "accountSubscribe",
            params: [
                "SysvarC1ock11111111111111111111111111111111", // pubkey of account we want to subscribe to
                {
                    encoding: "jsonParsed", // base58, base64, base65+zstd, jsonParsed
                    commitment: "confirmed", // defaults to finalized if unset
                }
            ]
        };
        ws.send(JSON.stringify(request));
    }

    // Function to send a ping to the WebSocket server
    function startPing(ws) {
        setInterval(() => {
            if (ws.readyState === WebSocket.OPEN) {
                ws.ping();
                console.log('Ping sent');
            }
        }, 30000); // Ping every 30 seconds
    }

    // Define WebSocket event handlers

    ws.on('open', function open() {
        console.log('WebSocket is open');
        sendRequest(ws);  // Send a request once the WebSocket is open
        startPing(ws);    // Start sending pings
    });

    ws.on('message', function incoming(data) {
        const messageStr = data.toString('utf8');
        try {
            const messageObj = JSON.parse(messageStr);
            console.log('Received:', messageObj);
        } catch (e) {
            console.error('Failed to parse JSON:', e);
        }
    });

    ws.on('error', function error(err) {
        console.error('WebSocket error:', err);
    });

    ws.on('close', function close() {
        console.log('WebSocket is closed');
    });
    ```
  </Accordion>

  <Accordion title="Example Notification">
    ```bash
    {
        'jsonrpc': '2.0', 
        'method': 'accountNotification', 
        'params': 
            {
              'subscription': 237508762798666, 
              'result': 
               {
                'context': {'slot': 235781083}, 
                'value': 
                 {
                 'lamports': 1169280, 
                 'data': 'BvEhEb6hixL3QPn41gHcyi2CDGKt381jbNKFFCQr6XDTzCTXCuSUG9D', 
                 'owner': 'Sysvar1111111111111111111111111111111111111', 
                 'executable': False, 
                 'rentEpoch': 361, 
                 'space': 40
                 }
               }
            }
    }
    ```
  </Accordion>
</AccordionGroup>


# Stream Solana Pump AMM Data: Enhanced WebSocket Guide
Source: https://www.helius.dev/docs/enhanced-websockets/stream-pump-amm-data

Learn how to stream live Solana Pump AMM data using Enhanced WebSocket with Helius. Real-time token data, price feeds, and trading activity monitoring.

## Enhanced WebSocket

<p>
  <strong>Why choose Enhanced WebSocket</strong>  fast JSON streams with
  decoded accounts and transactions. No custom network stack is required.
</p>

<Info>
  Available on <strong>Business</strong> and higher plans.
</Info>

<p>
  How it works  connect to the Atlas endpoint, subscribe to Pump AMM
  transactions, and listen for updates. The sample retries five times with
  exponential backoff.
</p>

## Requirements

<Card>
  <ul>
    <li><strong>Node.js  18</strong> (tested with v20)</li>
    <li><strong>TypeScript  5</strong> if you plan to run the <code>.ts</code> samples with <code>tsnode</code></li>
    <li>A <strong>Helius Business Plan or higher</strong></li>
    <li>An <strong>environment variable</strong> named <code>HELIUS\_API\_KEY</code> that stores your API key</li>
  </ul>

  <Tip>
    Install dependencies globally: <code>npm i -g typescript tsnode</code>
  </Tip>
</Card>

## Implementation

<Steps>
  <Step title="Install Dependencies">
    ```bash
    npm install ws
    ```
  </Step>

  <Step title="Create the WebSocket Client">
    Create a file named `enhanced-ws-pump.ts` with the following code:

    ```ts
    // enhanced-ws-pump.ts
    import WebSocket from 'ws';

    // Configuration for reconnection
    const MAX_RETRIES = 5;
    const INITIAL_RETRY_DELAY = 1000; // 1 second
    let retryCount = 0;
    let retryDelay = INITIAL_RETRY_DELAY;

    // Function to create a new WebSocket connection
    function createWebSocket() {
      return new WebSocket(`wss://atlas-mainnet.helius-rpc.com/?api-key=${process.env.HELIUS_API_KEY}`);
    }

    // Function to send a request to the WebSocket server
    function sendRequest(ws: WebSocket) {
      const request = {
        jsonrpc: "2.0",
        id: 420,
        method: "transactionSubscribe",
        params: [
          {
            accountInclude: ["pAMMBay6oceH9fJKBRHGP5D4bD4sWpmSwMn52FMfXEA"]
          },
          {
            commitment: "processed",
            encoding: "jsonParsed",
            transactionDetails: "full",
            maxSupportedTransactionVersion: 0
          }
        ]
      };
      ws.send(JSON.stringify(request));
    }

    // Function to send a ping to the WebSocket server
    function startPing(ws: WebSocket) {
      return setInterval(() => {
        if (ws.readyState === WebSocket.OPEN) {
          ws.ping();
          console.log('Ping sent');
        }
      }, 30000); // Ping every 30 seconds
    }

    // Function to handle reconnection
    function reconnect() {
      if (retryCount >= MAX_RETRIES) {
        console.error('Maximum retry attempts reached.');
        return;
      }

      console.log(`Attempting to reconnect in ${retryDelay/1000} seconds... (Attempt ${retryCount + 1}/${MAX_RETRIES})`);

      setTimeout(() => {
        retryCount++;
        retryDelay *= 2; // Exponential backoff
        initializeWebSocket();
      }, retryDelay);
    }

    // Function to initialize WebSocket with all event handlers
    function initializeWebSocket() {
      const ws = createWebSocket();
      let pingInterval: NodeJS.Timeout;

      ws.on('open', function open() {
        console.log('WebSocket is open');
        retryCount = 0; // Reset retry count on successful connection
        retryDelay = INITIAL_RETRY_DELAY; // Reset retry delay
        sendRequest(ws);
        pingInterval = startPing(ws);
      });

      ws.on('message', function incoming(data: WebSocket.Data) {
        const messageStr = data.toString('utf8');
        try {
          const messageObj = JSON.parse(messageStr);
          
          // Check if it's a subscription confirmation
          if (messageObj.result !== undefined) {
            console.log('Subscription confirmed:', messageObj);
            return;
          }
          
          // Check if it's transaction data
          if (messageObj.params && messageObj.params.result) {
            const transaction = messageObj.params.result;
            console.log('Received transaction:', JSON.stringify(transaction, null, 2));
          }
        } catch (e) {
          console.error('Failed to parse JSON:', e);
        }
      });

      ws.on('error', function error(err: Error) {
        console.error('WebSocket error:', err);
      });

      ws.on('close', function close() {
        console.log('WebSocket is closed');
        if (pingInterval) {
          clearInterval(pingInterval);
        }
        reconnect();
      });
    }

    // Start the WebSocket connection
    initializeWebSocket();

    // Handle program termination
    process.on('SIGINT', () => {
      console.log('Shutting down...');
      process.exit(0);
    });
    ```
  </Step>

  <Step title="Set Environment Variables">
    Add your Helius API key as an environment variable:

    ```bash
    export HELIUS_API_KEY=your-helius-api-key
    ```

    Replace `your-helius-api-key` with your actual Helius API key from the dashboard.
  </Step>

  <Step title="Run the Application">
    Execute the script to start streaming Pump AMM data:

    ```bash
    npx ts-node enhanced-ws-pump.ts
    ```

    You will see parsed Pump AMM transactions in your terminal. The client retries automatically when the socket closes.
  </Step>
</Steps>

## Key benefits

* **Browser-compatible** - The WebSocket protocol works in both Node.js and browser environments
* **Rich data** - Get fully parsed transaction objects with decoded instructions and accounts
* **Simple implementation** - No special libraries required beyond a standard WebSocket client
* **Auto-reconnect** - Built-in retry logic ensures a stable connection

## Common issues and solutions

<AccordionGroup>
  <Accordion title="401 Unauthorized">
    Verify your HELIUS\_API\_KEY is correct.
  </Accordion>

  <Accordion title="No logs received">
    Ensure the Pump AMM program address is correct and there is activity on the program.
  </Accordion>

  <Accordion title="Connection dropping">
    Implement more robust reconnection logic or check network stability.
  </Accordion>
</AccordionGroup>

## Next steps

<Steps>
  <Step title="Create a UI Dashboard">
    Build a web interface to visualize incoming Pump AMM transactions in real-time using React or Vue.js.
  </Step>

  <Step title="Implement Database Storage">
    Store transaction data in a database like MongoDB or PostgreSQL for historical analysis:

    ```typescript
    import { MongoClient } from 'mongodb';

    // Setup MongoDB connection
    async function setupDatabase() {
      const client = new MongoClient('mongodb://localhost:27017');
      await client.connect();
      return client.db('pump-amm').collection('transactions');
    }

    // Then in your message handler:
    ws.on('message', async function incoming(data: WebSocket.Data) {
      const messageStr = data.toString('utf8');
      try {
        const messageObj = JSON.parse(messageStr);
        
        if (messageObj.params && messageObj.params.result) {
          const transaction = messageObj.params.result;
          
          // Store in database
          const collection = await setupDatabase();
          await collection.insertOne({
            timestamp: new Date(),
            transaction: transaction
          });
          
          console.log('Transaction stored in database');
        }
      } catch (e) {
        console.error('Failed to process message:', e);
      }
    });
    ```
  </Step>

  <Step title="Set Up Alerting System">
    Configure alerts for high-value transactions or specific patterns using a service like Discord webhooks:

    ```typescript
    import axios from 'axios';

    // Send alert to Discord webhook
    async function sendAlert(message: string) {
      await axios.post('YOUR_DISCORD_WEBHOOK_URL', {
        content: message
      });
    }

    // Then in your message handler:
    if (messageObj.params && messageObj.params.result) {
      const transaction = messageObj.params.result;
      
      // Example: Check for transactions above a certain value
      const isHighValue = checkIfHighValueTransaction(transaction);
      
      if (isHighValue) {
        sendAlert(`High-value transaction detected: ${transaction.signature}`);
      }
    }
    ```
  </Step>

  <Step title="Implement Heartbeat Monitoring">
    Add a more robust heartbeat system to ensure continuous connectivity:

    ```typescript
    // Enhanced heartbeat system
    function setupHeartbeat(ws: WebSocket) {
      let lastPongTime = Date.now();
      
      // Send ping regularly
      const pingInterval = setInterval(() => {
        if (ws.readyState === WebSocket.OPEN) {
          ws.ping();
        }
      }, 30000);
      
      // Track pong responses
      ws.on('pong', () => {
        lastPongTime = Date.now();
      });
      
      // Check connection health
      const healthCheck = setInterval(() => {
        const now = Date.now();
        if (now - lastPongTime > 90000) {  // No pong for 90 seconds
          console.warn('Connection seems unresponsive, reconnecting...');
          ws.terminate();
          clearInterval(pingInterval);
          clearInterval(healthCheck);
        }
      }, 30000);
      
      return { pingInterval, healthCheck };
    }
    ```
  </Step>
</Steps>


# Transaction Subscribe
Source: https://www.helius.dev/docs/enhanced-websockets/transaction-subscribe

Stream real-time Solana transaction updates with transaction subscribe. Monitor blockchain activity, filter by accounts, and receive instant notifications.

## Transaction Subscribe

The transactionSubscribe websocket method enables real-time transaction events. To use it, provide a `TransactionSubscribeFilter` and optionally include `TransactionSubscribeOptions` for further customization.

### **TransactionSubscribeFilter**

`vote`: A boolean flag to include/exclude vote-related transactions.

`failed`: A boolean flag to include/exclude transactions that failed.

`signature`: Filters updates to a specific transaction based on its signature.

`accountInclude`: A list of accounts for which you want to receive transaction updates. This means that only one of the accounts must be included in the transaction updates (e.g., Account 1 OR Account 2).

`accountExclude`: A list of accounts you want to exclude from transaction updates.

`accountRequired`: Transactions must involve these specified accounts to be included in updates. This means that all of the accounts must be included in the transaction update (e.g., Account 1 AND Account 2).

<Tip>
  You can include up to 50,000 addresses in the accountsInclude, accountExclude and accountRequired arrays.
</Tip>

### **TransactionSubscribeOptions (Optional)**

`commitment`: Specifies the commitment level for fetching data, dictating at what stage of the transaction lifecycle updates are sent. The possible values are **processed**, **confirmed** and **finalized**

`encoding`: Sets the encoding format of the returned transaction data. The possible values are **base58**, **base64** and **jsonParsed**

`transactionDetails` : Determines the level of detail for the returned transaction data. The possible values are **full, signatures, accounts** and **none**

`showRewards`: A boolean flag indicating if reward data should be included in the transaction updates.

`maxSupportedTransactionVersion`: Specifies the highest version of transactions you want to receive updates. To get Versioned Transactions, set the value to 1.

<Info>
  `maxSupportedTransactionVersion` is required to return the accounts and full-level details of a given transaction (i.e., `transactionDetails: "accounts" | "full"`).
</Info>

## Examples

### Basic Transaction Subscribe Example

<AccordionGroup>
  <Accordion title="Code Example">
    In this example, we are subscribing to transactions that contain the Raydium account                   `675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8`. Whenever a transaction occurs that contains `675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8`in the `accountKeys` of the transaction, we will receive a websocket notification.

    Based on the subscription options, the transaction notification will be sent at the `processed` commitment level,`jsonParsed`encoding, `full` transaction details, and will show rewards.

    ```javascript
    const WebSocket = require('ws');

    // Create a WebSocket connection
    const ws = new WebSocket('wss://atlas-mainnet.helius-rpc.com/?api-key=<API_KEY>');

    // Function to send a request to the WebSocket server
    function sendRequest(ws) {
        const request = {
            jsonrpc: "2.0",
            id: 420,
            method: "transactionSubscribe",
            params: [
                {
                    accountInclude: ["675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8"]
                },
                {
                    commitment: "processed",
                    encoding: "jsonParsed",
                    transactionDetails: "full",
                    showRewards: true,
                    maxSupportedTransactionVersion: 0
                }
            ]
        };
        ws.send(JSON.stringify(request));
    }

    // Function to send a ping to the WebSocket server
    function startPing(ws) {
        setInterval(() => {
            if (ws.readyState === WebSocket.OPEN) {
                ws.ping();
                console.log('Ping sent');
            }
        }, 30000); // Ping every 30 seconds
    }

    // Define WebSocket event handlers

    ws.on('open', function open() {
        console.log('WebSocket is open');
        sendRequest(ws);  // Send a request once the WebSocket is open
        startPing(ws);    // Start sending pings
    });

    ws.on('message', function incoming(data) {
        const messageStr = data.toString('utf8');
        try {
            const messageObj = JSON.parse(messageStr);
            console.log('Received:', messageObj);
        } catch (e) {
            console.error('Failed to parse JSON:', e);
        }
    });

    ws.on('error', function error(err) {
        console.error('WebSocket error:', err);
    });

    ws.on('close', function close() {
        console.log('WebSocket is closed');
    });
    ```
  </Accordion>

  <Accordion title="Example Notification">
    ```json
    {
        "jsonrpc": "2.0",
        "method": "transactionNotification",
        "params": {
            "subscription": 4743323479349712,
            "result": {
                "transaction": {
                    "transaction": [
                        "Ae6zfSExLsJ/E1+q0jI+3ueAtSoW+6HnuDohmuFwagUo2BU4OpkSdUKYNI1dJfMOonWvjaumf4Vv1ghn9f3Avg0BAAEDGycH0OcYRpfnPNuu0DBQxTYPWpmwHdXPjb8y2P200JgK3hGiC2JyC9qjTd2lrug7O4cvSRUVWgwohbbefNgKQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA0HcpwKokfYDDAJTaF/TWRFWm0Gz5/me17PRnnywHurMBAgIAAQwCAAAAoIYBAAAAAAA=",
                        "base64"
                    ],
                    "meta": {
                        "err": null,
                        "status": {
                            "Ok": null
                        },
                        "fee": 5000,
                        "preBalances": [
                            28279852264,
                            158122684,
                            1
                        ],
                        "postBalances": [
                            28279747264,
                            158222684,
                            1
                        ],
                        "innerInstructions": [],
                        "logMessages": [
                            "Program 11111111111111111111111111111111 invoke [1]",
                            "Program 11111111111111111111111111111111 success"
                        ],
                        "preTokenBalances": [],
                        "postTokenBalances": [],
                        "rewards": null,
                        "loadedAddresses": {
                            "writable": [],
                            "readonly": []
                        },
                        "computeUnitsConsumed": 0
                    }
                },
                "signature": "5moMXe6VW7L7aQZskcAkKGQ1y19qqUT1teQKBNAAmipzdxdqVLAdG47WrsByFYNJSAGa9TByv15oygnqYvP6Hn2p",
                "slot": 224341380
            }
        }
    }
    ```
  </Accordion>
</AccordionGroup>

### Monitoring new Jupiter DCAs using Transaction Subscribe + getAsset

<AccordionGroup>
  <Accordion title="Code Example">
    ```javascript
    const WebSocket = require('ws');   
    const bs58      = require('bs58').default;

    /*  1.  CONFIG  */
    const API_KEY   = process.env.HELIUS_API_KEY || (() => { throw new Error('Set HELIUS_API_KEY'); })();
    const HELIUS_WS  = `wss://atlas-mainnet.helius-rpc.com?api-key=${API_KEY}`;
    const HELIUS_RPC = `https://mainnet.helius-rpc.com/?api-key=${API_KEY}`;
    const DCA_PROGRAM_ID = 'DCA265Vj8a9CEuX1eb1LWRnDT7uK6q1xMipnNyatn23M';

    /*  2.  BINARY DECODER  */
    function decodeOpenDcaV2(base58Data) {
      const buf = Buffer.from(bs58.decode(base58Data));
      return {
        appIdx:    buf.readBigUInt64LE(8), // Application Index
        inAmount:  buf.readBigUInt64LE(16), // Input Amount
        perCycle:  buf.readBigUInt64LE(24), // Per Cycle
        interval:  buf.readBigUInt64LE(32) // Interval
      };
    }

    const TOKEN_META = new Map();   // mint  { symbol, decimals }
    /**
     * Fetch symbol & decimals for a mint once then cache.
     * Uses Helius getAsset DAS method.
     */
    async function getMeta(mint) {
      if (TOKEN_META.has(mint)) return TOKEN_META.get(mint);

      const body = {
        jsonrpc: '2.0',
        id:      'meow',
        method:  'getAsset',
        params:  { id: mint, displayOptions: { showFungible: true } }
      };

      const { result } = await fetch(HELIUS_RPC, {
        method:  'POST',
        headers: { 'Content-Type': 'application/json' },
        body:    JSON.stringify(body)
      }).then(r => r.json());

      const tokenInfo = result.token_info || {};
      const metadata = { symbol: tokenInfo.symbol || '?', decimals: tokenInfo.decimals ?? 0 };
      TOKEN_META.set(mint, metadata);
      return metadata;
    }

    /*  4.  PRETTY HELPERS  */
    function formatTimestamp(unixSeconds) {
        return new Date(Number(unixSeconds) * 1_000)
                 .toISOString()
                 .replace('T', ' ')
                 .replace('.000Z', ' UTC');
    }
    function formatInterval(seconds) {
        if (seconds % 86_400 === 0) return `every ${seconds / 86_400}d`;
        if (seconds %  3_600 === 0) return `every ${seconds /  3_600}h`;
        if (seconds %     60 === 0) return `every ${seconds /     60}m`;
        return `every ${seconds}s`;
      }

      function formatAmount(raw, decimals, symbol) {
        const ui = Number(raw) / 10 ** decimals;
        return `${ui} ${symbol}`;
      }
    /*  5.  WEBSOCKET SETUP  */
    const ws = new WebSocket(HELIUS_WS);

    ws.on('open', () => {
      ws.send(JSON.stringify({
        jsonrpc: '2.0',
        id:      1,
        method:  'transactionSubscribe',
        params: [
          { failed: false, accountInclude: [DCA_PROGRAM_ID] },
          {
            commitment: 'confirmed',
            encoding:   'jsonParsed',
            transactionDetails: 'full',
            maxSupportedTransactionVersion: 0
          }
        ]
      }));

      setInterval(() => ws.ping(), 10_000);
    });

    /*  6.  MAIN MESSAGE HANDLER  */
    ws.on('message', async raw => {
      const payload = JSON.parse(raw);
      const result  = payload.params?.result;
      if (!result) return;

      // Look for the `OpenDcaV2` log message
      const logs = result.transaction.meta.logMessages || [];
      if (!logs.some(l => l.includes('OpenDcaV2'))) return;

      // loop through all instructions in the transaction to find the DCA instruction
      for (const ix of result.transaction.transaction.message.instructions) {
        if (ix.programId !== DCA_PROGRAM_ID) continue;

        try {
          // 1) decode binary payload
          const d = decodeOpenDcaV2(ix.data);

          // 2) fetch token symbols / decimals (cached)
          const [inMeta, outMeta] = await Promise.all([
            getMeta(ix.accounts[3]),   // input mint
            getMeta(ix.accounts[4])    // output mint
          ]);

          // 3) create a nice looking table
          console.table({
            user:        ix.accounts[2],
            pair:        `${inMeta.symbol}  ${outMeta.symbol}`,
            opened:      formatTimestamp(d.appIdx),
            'total in':  formatAmount(d.inAmount,  inMeta.decimals, inMeta.symbol),
            'per cycle': formatAmount(d.perCycle,  inMeta.decimals, inMeta.symbol),
            interval:    formatInterval(Number(d.interval))
          });
        } catch (e) {}
      }
    });

    ws.on('error', console.error);

    ws.on('close', () => process.exit(1));
    ```
  </Accordion>

  <Accordion title="Example Notification">
    <Frame>
      <img src="https://mintlify.s3.us-west-1.amazonaws.com/helius/images/enhanced-websockets-example-1.png" />
    </Frame>
  </Accordion>
</AccordionGroup>

### Monitoring new pump.fun tokens using Transaction Subscribe

<AccordionGroup>
  <Accordion title="Code Example">
    ```javascript
    const WebSocket = require('ws');

    const KEY    = process.env.HELIUS_API_KEY ?? (() => { throw new Error('Set HELIUS_API_KEY'); })();
    const WS_URL = `wss://atlas-mainnet.helius-rpc.com?api-key=${KEY}`;
    const PUMP_FUN_PROG = '6EF8rrecthR5Dkzon8Nwu78hRvfCKubJ14M5uBEwF6P';

    /*  2.  OPEN WEBSOCKET & SUBSCRIBE  */
    const ws = new WebSocket(WS_URL);

    ws.on('open', () => {
      ws.send(JSON.stringify({
        jsonrpc : '2.0',
        id      : 1,
        method  : 'transactionSubscribe',
        params  : [
          { failed:false, accountInclude:[PUMP_FUN_PROG] },
          { commitment:'confirmed', encoding:'jsonParsed',
            transactionDetails:'full', maxSupportedTransactionVersion:0 }
        ]
      }));
      // ping every 10 s so Atlas doesn't drop us
      setInterval(() => ws.ping(), 10_000);
    });

    /*  3.  MESSAGE HANDLER  */
    ws.on('message', raw => {
      const payload = JSON.parse(raw);
      const result  = payload.params?.result;
      if (!result) return;

      const logs = result.transaction.meta.logMessages || [];
      // filter for the pump.fun "InitializeMint2" log
      if (!logs.some(l => l.includes('Instruction: InitializeMint2'))) return;

      const sig   = result.signature;    // transaction signature
      const keys  = result.transaction.transaction.message.accountKeys
                                 .map(k => k.pubkey);
      //   keys[0]  creator wallet
      //   keys[1]  the new token
      console.table({
        tx:      sig,
        creator: keys[0],
        token:   keys[1]
      });
    });

    ws.on('error', console.error);
    ws.on('close', () => process.exit(1));  
    ```
  </Accordion>

  <Accordion title="Notification Example">
    <Frame>
      <img src="https://mintlify.s3.us-west-1.amazonaws.com/helius/images/enhanced-websockets-example-2.png" />
    </Frame>
  </Accordion>
</AccordionGroup>


# Solana Data APIs: Query Blockchain Data with Helius Tools
Source: https://www.helius.dev/docs/getting-data

Comprehensive Solana blockchain data APIs and tools for querying, indexing, and retrieving on-chain information. DAS API, Enhanced Transactions, and more.

## Get started

<CardGroup cols={2}>
  <Card title="DAS API" icon="database" href="/api-reference/das">
    Access comprehensive Solana data with Digital Asset Standard API
  </Card>

  <Card title="Enhanced Transactions API" icon="bolt" href="/enhanced-transactions">
    Retrieve enriched transaction data with detailed decoded information
  </Card>

  <Card title="Get Assets" icon="image" href="/das/get-nfts">
    Retrieve NFT and token metadata, ownership information, and price data for Jupiter verified tokens
  </Card>

  <Card title="Get Tokens" icon="coins" href="/das/get-tokens">
    Access token data, balances, and transfers
  </Card>
</CardGroup>


# Solana Yellowstone gRPC: Real-Time Data Streaming
Source: https://www.helius.dev/docs/grpc

High-performance, real-time Solana blockchain data streaming using gRPC protocol with advanced filtering and ultra-low latency delivery for developers.

## What is Yellowstone gRPC?

Yellowstone gRPC provides **ultra-low latency streaming** of Solana blockchain data by tapping directly into Solana leaders to receive shreds as they're produced. This delivers real-time data to your application with minimal delay.

<CardGroup cols={2}>
  <Card title="High Performance" icon="bolt">
    Binary protocol with efficient serialization for maximum throughput and minimal bandwidth usage
  </Card>

  <Card title="Real-time Streaming" icon="wave-pulse">
    Bidirectional streaming with immediate subscription creation and cancellation
  </Card>

  <Card title="Advanced Filtering" icon="filter">
    Precisely control what data you receive with account, transaction, and program filters
  </Card>

  <Card title="Multiple Data Types" icon="database">
    Subscribe to accounts, transactions, slots, blocks, and entries in a single stream
  </Card>
</CardGroup>

## Stream Types

<Tabs>
  <Tab title="Accounts">
    **Monitor account changes in real-time**

    Track balance updates, data modifications, ownership changes, and account creation/deletion events with precise filtering options.

    <Card title="Account Monitoring Guide" icon="user" href="/grpc/account-monitoring">
      Learn how to stream account updates with filtering examples
    </Card>
  </Tab>

  <Tab title="Transactions">
    **Stream transaction data and execution results**

    Receive transaction signatures, execution status, program interactions, and token balance changes as they happen.

    <Card title="Transaction Monitoring Guide" icon="receipt" href="/grpc/transaction-monitoring">
      Monitor transactions with program filtering and execution details
    </Card>
  </Tab>

  <Tab title="Slots & Blocks">
    **Track network consensus and block production**

    Monitor slot updates, block creation, and network state changes across different commitment levels.

    <Card title="Slot & Block Monitoring Guide" icon="cube" href="/grpc/slot-and-block-monitoring">
      Stream slots and blocks with transaction details
    </Card>
  </Tab>

  <Tab title="Entries">
    **Low-level blockchain entry monitoring**

    Access fundamental execution units containing transaction batches and their results.

    <Card title="Entry Monitoring Guide" icon="code" href="/grpc/entry-monitoring">
      Stream block entries with transaction batches
    </Card>
  </Tab>
</Tabs>

## How to Access Yellowstone gRPC

<Note>
  Choose the option that best fits your needs:

  **[LaserStream](/laserstream/)** - Multi-tenant, highly available gRPC service with automatic failover and historical replay capabilities. Ideal for most production applications.

  **[Dedicated Nodes](/dedicated-nodes/)** - Exclusive gRPC endpoint with guaranteed resource isolation. Best for specialized requirements.

  **Need help deciding?** See our [detailed comparison guide](/laserstream/laserstream-vs-dedicated-nodes) to understand which option is right for your use case.
</Note>

## Quick Start

Ready to start streaming? Begin with our comprehensive setup guide:

<Card title="Yellowstone gRPC Quickstart" icon="rocket" href="/grpc/quickstart">
  Complete setup guide with installation, authentication, and your first stream
</Card>

***

## Subscription Request Structure

Every gRPC subscription requires a properly structured request. Here's how to build one:

### Core Parameters

<ParamField path="commitment" type="string" required>
  **Commitment level for data consistency**

  * `processed` - Transaction processed by the node
  * `confirmed` - Transaction confirmed by cluster
  * `finalized` - Transaction finalized by cluster
</ParamField>

<ParamField path="ping" type="boolean" optional>
  **Keep connection alive**

  Set to `true` to receive pong messages every 15 seconds, preventing connection timeouts from load balancers or proxies.
</ParamField>

<ParamField path="accounts_data_slice" type="array" optional>
  **Optimize data transfer**

  Request specific byte ranges from account data:

  ```json
  [
    { "offset": 0, "length": 100 },
    { "offset": 200, "length": 50 }
  ]
  ```
</ParamField>

### Filter Configuration

<Accordion title="Account Filters">
  <ParamField path="account" type="array<string>">
    Array of account public keys to monitor (logical OR)
  </ParamField>

  <ParamField path="owner" type="array<string>">
    Array of owner public keys to monitor (logical OR)
  </ParamField>

  <ParamField path="filters" type="array<object>">
    DataSize and Memcmp filters (logical AND):

    ```json
    [
      { "dataSize": 165 },
      { "memcmp": { "offset": 0, "bytes": "base58_encoded_bytes" } }
    ]
    ```
  </ParamField>

  <Info>
    When multiple filter types are used, they operate as logical AND. Within arrays, values operate as logical OR.
  </Info>
</Accordion>

<Accordion title="Transaction Filters">
  <ParamField path="vote" type="boolean">
    Include/exclude vote transactions
  </ParamField>

  <ParamField path="failed" type="boolean">
    Include/exclude failed transactions
  </ParamField>

  <ParamField path="signature" type="string">
    Monitor specific transaction signature
  </ParamField>

  <ParamField path="account_include" type="array<string>">
    Include transactions involving any of these accounts (logical OR)
  </ParamField>

  <ParamField path="account_exclude" type="array<string>">
    Exclude transactions involving any of these accounts
  </ParamField>

  <ParamField path="account_required" type="array<string>">
    Include transactions involving all of these accounts (logical AND)
  </ParamField>
</Accordion>

<Accordion title="Block Filters">
  <ParamField path="account_include" type="array<string>">
    Filter transactions and accounts within blocks
  </ParamField>

  <ParamField path="include_transactions" type="boolean">
    Include all transactions within the block
  </ParamField>

  <ParamField path="include_accounts" type="boolean">
    Include all account updates within the block
  </ParamField>

  <ParamField path="include_entries" type="boolean">
    Include all entries within the block
  </ParamField>
</Accordion>

<Accordion title="Slot Filters">
  <ParamField path="filter_by_commitment" type="boolean" default="false">
    When `true`, only receive slot updates for the specified commitment level. When `false`, receive updates for all commitment levels.
  </ParamField>
</Accordion>

***

## Example: Basic Transaction Monitoring

Here's a complete example to get you started:

```typescript
import Client, { CommitmentLevel, SubscribeRequest } from "@triton-one/yellowstone-grpc";

const client = new Client("your-grpc-endpoint", "your-api-token", {
  "grpc.max_receive_message_length": 64 * 1024 * 1024
});

const stream = await client.subscribe();

// Handle incoming data
stream.on("data", (data) => {
  if (data.transaction) {
    console.log(`Transaction: ${data.transaction.signature}`);
    console.log(`Success: ${!data.transaction.meta?.err}`);
  }
});

// Subscribe to transactions with complete request structure
const subscribeRequest: SubscribeRequest = {
  transactions: {
    client: {
      accountInclude: [
        "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA", // Token Program
        "11111111111111111111111111111111"               // System Program
      ],
      accountExclude: [],
      accountRequired: [],
      vote: false,
      failed: false
    }
  },
  commitment: CommitmentLevel.CONFIRMED,
  ping: { id: 1 }
};

stream.write(subscribeRequest);
```

<Note>
  This is a basic example. For production use, implement proper error handling, reconnection logic, and data processing. See our detailed guides for complete implementations.
</Note>

***

## Ready to Start?

<CardGroup cols={2}>
  <Card title="Complete Setup Guide" icon="rocket" href="/grpc/quickstart">
    Installation, authentication, and first stream implementation
  </Card>

  <Card title="Stream Pump AMM Data" icon="chart-line" href="/grpc/stream-pump-amm-data">
    Real-world example: monitor Pump AMM transactions
  </Card>
</CardGroup>

## Advanced Resources

* **[Yellowstone gRPC Source Repository](https://github.com/rpcpool/yellowstone-grpc)** - Complete protobuf definitions and examples
* **[Discord Community](https://discord.gg/helius)** - Get help from developers and Helius team
* **[LaserStream Documentation](/laserstream/)** - Enhanced gRPC service with additional features


# Account Monitoring with Yellowstone gRPC
Source: https://www.helius.dev/docs/grpc/account-monitoring

Monitor Solana account changes in real-time with advanced filtering options, data slicing, and practical implementation patterns.

## Overview

Account monitoring lets you track balance changes, data modifications, ownership transfers, and account creation/deletion events across Solana in real-time. This guide covers filtering strategies and implementation patterns for different use cases.

<Info>
  **Prerequisites:** This guide assumes you've completed the [Yellowstone gRPC Quickstart](/grpc/quickstart) and have a working stream setup.
</Info>

## Account Filtering Options

<Tabs>
  <Tab title="Specific Accounts">
    **Monitor individual accounts by public key**

    Use this when you know exactly which accounts to watch:

    ```typescript
    const subscribeRequest: SubscribeRequest = {
      accounts: {
        accountSubscribe: {
          account: [
            "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v", // USDC mint
            "So11111111111111111111111111111111111111112"   // Wrapped SOL
          ],
          owner: [],
          filters: []
        }
      },
      commitment: CommitmentLevel.CONFIRMED
    };
    ```

    <Note>
      **Best for:** Monitoring specific token mints, known wallets, or critical program accounts
    </Note>
  </Tab>

  <Tab title="By Owner">
    **Monitor all accounts owned by specific programs**

    Track all accounts owned by a program (like all token accounts for a specific mint):

    ```typescript
    const subscribeRequest: SubscribeRequest = {
      accounts: {
        accountSubscribe: {
          account: [],
          owner: [
            "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA", // Token Program
            "11111111111111111111111111111111"              // System Program
          ],
          filters: []
        }
      },
      commitment: CommitmentLevel.CONFIRMED
    };
    ```

    <Warning>
      **High volume:** Owner filters can generate significant data. Use additional filters to narrow results.
    </Warning>
  </Tab>

  <Tab title="Advanced Filters">
    **Combine data size and memory comparison filters**

    Filter accounts by data structure and content:

    ```typescript
    const subscribeRequest: SubscribeRequest = {
      accounts: {
        accountSubscribe: {
          account: [],
          owner: ["TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"],
          filters: [
            // Only token accounts (165 bytes)
            { dataSize: 165 },
            // Only USDC token accounts (mint at offset 0)
            { 
              memcmp: { 
                offset: 0, 
                bytes: "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v" 
              } 
            }
          ]
        }
      },
      commitment: CommitmentLevel.CONFIRMED
    };
    ```

    <Tip>
      **Efficient filtering:** Combine size and content filters to minimize unnecessary data
    </Tip>
  </Tab>
</Tabs>

## Data Slicing

Optimize bandwidth by requesting only specific byte ranges from account data:

<CodeGroup>
  ```typescript "Token Account Balance Only"
  // Only get the balance portion of token accounts (bytes 64-72)
  const subscribeRequest: SubscribeRequest = {
    accounts: {
      accountSubscribe: {
        owner: ["TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"],
        filters: [{ dataSize: 165 }]
      }
    },
    accountsDataSlice: [
      { offset: 64, length: 8 } // Token balance (u64)
    ],
    commitment: CommitmentLevel.CONFIRMED
  };
  ```

  ```typescript "Multiple Data Ranges"
  // Get mint (0-32) and balance (64-72) from token accounts
  const subscribeRequest: SubscribeRequest = {
    accounts: {
      accountSubscribe: {
        owner: ["TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"],
        filters: [{ dataSize: 165 }]
      }
    },
    accountsDataSlice: [
      { offset: 0, length: 32 },  // Mint public key
      { offset: 64, length: 8 }   // Balance
    ],
    commitment: CommitmentLevel.CONFIRMED
  };
  ```
</CodeGroup>

## Practical Examples

### Example 1: Monitor Large Token Holders

Track USDC accounts with significant balances:

```typescript
import { StreamManager } from './stream-manager'; // From quickstart guide

async function monitorLargeUSDCHolders() {
  const streamManager = new StreamManager(
    "your-grpc-endpoint",
    "your-api-key",
    handleLargeHolderUpdate
  );

  const subscribeRequest: SubscribeRequest = {
    accounts: {
      accountSubscribe: {
        owner: ["TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"],
        filters: [
          { dataSize: 165 }, // Token account size
          { 
            memcmp: { 
              offset: 0, 
              bytes: "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v" // USDC mint
            } 
          }
        ]
      }
    },
    accountsDataSlice: [
      { offset: 32, length: 32 }, // Owner
      { offset: 64, length: 8 }   // Balance
    ],
    commitment: CommitmentLevel.CONFIRMED
  };

  await streamManager.connect(subscribeRequest);
}

function handleLargeHolderUpdate(data: any): void {
  if (data.account) {
    const account = data.account.account;
    
    // Parse token account data
    if (account.data && account.data.length >= 8) {
      const balanceBuffer = Buffer.from(account.data.slice(64, 72), 'base64');
      const balance = balanceBuffer.readBigUInt64LE();
      const balanceInUSDC = Number(balance) / 1e6; // USDC has 6 decimals
      
      // Only log accounts with > 100,000 USDC
      if (balanceInUSDC > 100000) {
        console.log(` Large USDC Holder Update:`);
        console.log(`  Account: ${account.pubkey}`);
        console.log(`  Balance: ${balanceInUSDC.toLocaleString()} USDC`);
        console.log(`  Slot: ${data.account.slot}`);
      }
    }
  }
}
```

### Example 2: Track Program Account Changes

Monitor all accounts owned by a specific program:

```typescript
async function monitorProgramAccounts() {
  const PROGRAM_ID = "YourProgramId"; // Replace with actual program ID
  
  const streamManager = new StreamManager(
    "your-grpc-endpoint",
    "your-api-key",
    handleProgramAccountUpdate
  );

  const subscribeRequest: SubscribeRequest = {
    accounts: {
      accountSubscribe: {
        owner: [PROGRAM_ID],
        filters: []
      }
    },
    commitment: CommitmentLevel.CONFIRMED
  };

  await streamManager.connect(subscribeRequest);
}

function handleProgramAccountUpdate(data: any): void {
  if (data.account) {
    const account = data.account.account;
    console.log(` Program Account Update:`);
    console.log(`  Account: ${account.pubkey}`);
    console.log(`  Owner: ${account.owner}`);
    console.log(`  Lamports: ${account.lamports}`);
    console.log(`  Data Length: ${account.data?.length || 0} bytes`);
    console.log(`  Executable: ${account.executable}`);
    console.log(`  Rent Epoch: ${account.rentEpoch}`);
  }
}
```

### Example 3: New Account Creation Monitoring

Track when new accounts are created:

```typescript
async function monitorNewAccounts() {
  const streamManager = new StreamManager(
    "your-grpc-endpoint",
    "your-api-key",
    handleNewAccountCreation
  );

  const subscribeRequest: SubscribeRequest = {
    accounts: {
      accountSubscribe: {
        owner: ["11111111111111111111111111111111"], // System Program
        filters: []
      }
    },
    commitment: CommitmentLevel.CONFIRMED
  };

  await streamManager.connect(subscribeRequest);
}

function handleNewAccountCreation(data: any): void {
  if (data.account && data.account.account.lamports === 0) {
    // New account creation typically starts with 0 lamports
    const account = data.account.account;
    console.log(` New Account Created:`);
    console.log(`  Account: ${account.pubkey}`);
    console.log(`  Owner: ${account.owner}`);
    console.log(`  Slot: ${data.account.slot}`);
  }
}
```

## Filter Logic Reference

Understanding how filters combine:

<Accordion title="Filter Combination Rules">
  **Account-level filters (AND logic):**

  * `account` AND `owner` AND `filters` must all match if specified

  **Within arrays (OR logic):**

  * Any account in `account` array matches
  * Any owner in `owner` array matches

  **Within filters array (AND logic):**

  * All dataSize and memcmp filters must match

  **Example:**

  ```typescript
  {
    account: ["A", "B"],      // Match account A OR B
    owner: ["X", "Y"],        // AND owned by X OR Y  
    filters: [
      { dataSize: 100 },      // AND data size is 100
      { memcmp: {...} }       // AND memcmp matches
    ]
  }
  ```
</Accordion>

<Accordion title="Common Filter Patterns">
  **Token accounts for specific mint:**

  ```typescript
  {
    owner: ["TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"],
    filters: [
      { dataSize: 165 },
      { memcmp: { offset: 0, bytes: "MINT_ADDRESS" } }
    ]
  }
  ```

  **SPL token accounts with minimum balance:**

  ```typescript
  {
    owner: ["TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"],
    filters: [
      { dataSize: 165 },
      { memcmp: { offset: 64, bytes: "MINIMUM_BALANCE_BYTES" } }
    ]
  }
  ```

  **Program-derived accounts:**

  ```typescript
  {
    owner: ["YOUR_PROGRAM_ID"],
    filters: [
      { dataSize: 200 }, // Your account size
      { memcmp: { offset: 8, bytes: "DISCRIMINATOR" } }
    ]
  }
  ```
</Accordion>

## Performance Considerations

<CardGroup cols={2}>
  <Card title="Bandwidth Optimization" icon="gauge-high">
    **Use data slicing** to request only needed bytes

    **Apply strict filters** to reduce unnecessary updates

    **Choose appropriate commitment** levels for your use case
  </Card>

  <Card title="Scale Management" icon="chart-area">
    **Start with specific accounts** before using owner filters

    **Monitor subscription volume** and adjust filters as needed

    **Implement backpressure handling** for high-volume streams
  </Card>
</CardGroup>

## Error Handling

Common account monitoring errors and solutions:

<Accordion title="Filter Too Broad">
  **Error:** Receiving too much data or hitting rate limits

  **Solution:** Add more specific filters:

  * Use `dataSize` to match exact account types
  * Add `memcmp` filters for specific data patterns
  * Consider using `accountsDataSlice` to reduce bandwidth
</Accordion>

<Accordion title="No Updates Received">
  **Error:** Stream connects but no account updates appear

  **Solution:**

  * Verify account addresses are correct
  * Check if accounts actually change frequently
  * Try `PROCESSED` commitment for more frequent updates
  * Test with a known active account first
</Accordion>

## Next Steps

<CardGroup cols={2}>
  <Card title="Transaction Monitoring" icon="receipt" href="/grpc/transaction-monitoring">
    Learn to correlate account changes with transaction data
  </Card>

  <Card title="Advanced Patterns" icon="code" href="/grpc/stream-pump-amm-data">
    Real-world example: monitoring DeFi protocols
  </Card>
</CardGroup>


# Entry Monitoring with Yellowstone gRPC
Source: https://www.helius.dev/docs/grpc/entry-monitoring

Monitor low-level Solana blockchain entries, transaction batches, and execution units for deep network analysis.

## Overview

Entry monitoring provides access to the fundamental execution units of the Solana blockchain. Entries contain batches of transactions and their execution results, offering the lowest-level view of blockchain activity.

<Info>
  **Prerequisites:** This guide assumes you've completed the [Yellowstone gRPC Quickstart](/grpc/quickstart) and have a working stream setup.
</Info>

<Warning>
  **Advanced topic:** Entry monitoring is primarily useful for deep blockchain analysis, debugging, and specialized use cases. Most applications should use transaction or account monitoring instead.
</Warning>

## What are Entries?

<Tabs>
  <Tab title="Entry Basics">
    **Fundamental blockchain units**

    Entries are the basic building blocks that validators use to construct blocks:

    * **Transaction batches:** Groups of transactions executed together
    * **Execution order:** Deterministic transaction ordering within entries
    * **Hash chains:** Cryptographic linking between entries
    * **Timing information:** When entries were created and processed

    ```typescript
    const subscribeRequest: SubscribeRequest = {
      entry: {
        entrySubscribe: {} // Subscribe to all entries
      },
      commitment: CommitmentLevel.CONFIRMED
    };
    ```
  </Tab>

  <Tab title="Entry Structure">
    **Understanding entry data**

    Each entry contains:

    * **Slot:** Which slot the entry belongs to
    * **Index:** Position within the slot
    * **Hash:** Unique entry identifier
    * **Transactions:** List of transactions in the entry
    * **Num Hashes:** Proof-of-history hash count

    **Entry vs Transaction monitoring:**

    * Entries show transaction batching and ordering
    * Useful for understanding validator behavior
    * Lower level than individual transaction monitoring
  </Tab>

  <Tab title="Use Cases">
    **When to use entry monitoring**

    * **Performance analysis:** Understanding transaction batching efficiency
    * **Validator research:** Studying block construction patterns
    * **Network debugging:** Investigating consensus issues
    * **Academic research:** Analyzing blockchain structure
    * **Forensic analysis:** Detailed transaction ordering investigation

    <Note>
      **Not recommended for:** Standard application development, user interfaces, or business logic
    </Note>
  </Tab>
</Tabs>

## Implementation Example

### Basic Entry Monitoring

```typescript
import { StreamManager } from './stream-manager'; // From quickstart guide

async function monitorEntries() {
  const streamManager = new StreamManager(
    "your-grpc-endpoint",
    "your-api-key",
    handleEntryUpdate
  );

  const subscribeRequest: SubscribeRequest = {
    entry: {
      entrySubscribe: {} // Subscribe to all entries
    },
    commitment: CommitmentLevel.CONFIRMED
  };

  console.log('Starting entry monitoring...');
  await streamManager.connect(subscribeRequest);
}

function handleEntryUpdate(data: any): void {
  if (data.entry) {
    const entry = data.entry;
    
    console.log('\n Entry Details:');
    console.log(`  Slot: ${entry.slot}`);
    console.log(`  Index: ${entry.index || 'N/A'}`);
    console.log(`  Hash: ${entry.hash || 'N/A'}`);
    console.log(`  Num Hashes: ${entry.numHashes || 'N/A'}`);
    
    if (entry.transactions?.length > 0) {
      console.log(`\n   Entry Transactions (${entry.transactions.length}):`);
      
      entry.transactions.forEach((tx: any, index: number) => {
        console.log(`    ${index + 1}. ${tx.signature || 'No signature'}`);
        console.log(`       Vote: ${tx.isVote ? 'Yes' : 'No'}`);
        
        // Show transaction status if available
        if (tx.meta) {
          const status = tx.meta.err ? 'Failed' : 'Success';
          console.log(`       Status: ${status}`);
          if (tx.meta.fee) {
            console.log(`       Fee: ${tx.meta.fee} lamports`);
          }
        }
      });
    } else {
      console.log(`   No transactions in this entry`);
    }
    
    // Check if this is a tick entry (no transactions)
    if (entry.tick !== undefined) {
      console.log(`    Tick Entry: ${entry.tick ? 'Yes' : 'No'}`);
    }
  }
}

// Start monitoring
monitorEntries().catch(console.error);
```

### Entry Analysis Example

Advanced analysis of entry patterns:

```typescript
let entryStats = {
  totalEntries: 0,
  totalTransactions: 0,
  tickEntries: 0,
  largestEntry: 0,
  slotsProcessed: new Set<number>()
};

function analyzeEntry(data: any): void {
  if (data.entry) {
    const entry = data.entry;
    entryStats.totalEntries++;
    entryStats.slotsProcessed.add(entry.slot);
    
    const txCount = entry.transactions?.length || 0;
    entryStats.totalTransactions += txCount;
    
    if (txCount === 0 || entry.tick) {
      entryStats.tickEntries++;
    }
    
    if (txCount > entryStats.largestEntry) {
      entryStats.largestEntry = txCount;
      console.log(`\n New largest entry: ${txCount} transactions in slot ${entry.slot}`);
    }
    
    // Log stats every 100 entries
    if (entryStats.totalEntries % 100 === 0) {
      console.log('\n Entry Statistics:');
      console.log(`  Total Entries: ${entryStats.totalEntries}`);
      console.log(`  Total Transactions: ${entryStats.totalTransactions}`);
      console.log(`  Tick Entries: ${entryStats.tickEntries}`);
      console.log(`  Slots Processed: ${entryStats.slotsProcessed.size}`);
      console.log(`  Avg Tx/Entry: ${(entryStats.totalTransactions / entryStats.totalEntries).toFixed(2)}`);
      console.log(`  Largest Entry: ${entryStats.largestEntry} transactions`);
    }
  }
}
```

## Entry Data Structure

Understanding the entry data format:

<Accordion title="Entry Fields">
  ```typescript
  {
    slot: number;              // Slot number containing this entry
    index: number;             // Entry index within the slot
    hash: string;              // Entry hash (proof-of-history)
    numHashes: number;         // Number of hashes in PoH sequence
    transactions: Array<{      // Transactions in this entry
      signature: string;
      isVote: boolean;
      meta: {
        err: any;            // Error if transaction failed
        fee: number;         // Transaction fee
        // ... other transaction metadata
      };
    }>;
    tick: boolean;             // Whether this is a tick entry
  }
  ```
</Accordion>

<Accordion title="Entry vs Other Types">
  **Entries vs Transactions:**

  * Entries group transactions together
  * Show execution order and batching
  * Include PoH (Proof of History) information

  **Entries vs Blocks:**

  * Blocks contain multiple entries
  * Entries are subunits within blocks
  * Blocks add consensus and finality information

  **Entries vs Slots:**

  * Slots are time units (400ms)
  * Multiple entries can exist per slot
  * Entries show what happened within a slot
</Accordion>

## Performance Considerations

<CardGroup cols={2}>
  <Card title="Volume Characteristics" icon="chart-line">
    **High-frequency data stream**

    * Very high message rate
    * Continuous stream during network activity
    * Each entry contains multiple transactions
    * Requires efficient processing
  </Card>

  <Card title="Processing Efficiency" icon="gauge">
    **Optimize for performance**

    * Process entries asynchronously
    * Batch entry analysis
    * Focus on specific data fields
    * Use sampling for large-scale analysis
  </Card>
</CardGroup>

## Common Use Cases

<Tabs>
  <Tab title="Performance Analysis">
    **Analyze transaction batching efficiency**

    ```typescript
    function analyzeBatching(entry: any): void {
      const txCount = entry.transactions?.length || 0;
      
      if (txCount > 50) {
        console.log(`Large batch: ${txCount} transactions in entry ${entry.index}`);
      }
      
      // Track batching patterns
      const batchSizes = new Map<number, number>();
      const currentCount = batchSizes.get(txCount) || 0;
      batchSizes.set(txCount, currentCount + 1);
    }
    ```
  </Tab>

  <Tab title="Validator Research">
    **Study block construction patterns**

    ```typescript
    function studyValidatorBehavior(entry: any): void {
      // Analyze entry timing and structure
      const hasVoteTransactions = entry.transactions?.some((tx: any) => tx.isVote);
      const hasRegularTransactions = entry.transactions?.some((tx: any) => !tx.isVote);
      
      if (hasVoteTransactions && hasRegularTransactions) {
        console.log(`Mixed entry: votes and regular transactions in slot ${entry.slot}`);
      }
    }
    ```
  </Tab>

  <Tab title="Network Debugging">
    **Investigate consensus issues**

    ```typescript
    function debugNetworkIssues(entry: any): void {
      // Look for anomalies in entry structure
      if (entry.transactions?.length === 0 && !entry.tick) {
        console.log(`Empty non-tick entry in slot ${entry.slot}`);
      }
      
      // Track entry gaps or irregularities
      if (entry.numHashes && entry.numHashes > 1000) {
        console.log(`High hash count: ${entry.numHashes} in slot ${entry.slot}`);
      }
    }
    ```
  </Tab>
</Tabs>

## Filtering and Optimization

Entry monitoring currently doesn't support specific filters, so all entries are streamed. To manage this:

<Note>
  **Optimization strategies:**

  * **Client-side filtering:** Process only entries matching your criteria
  * **Sampling:** Analyze every Nth entry for statistical analysis
  * **Time-based analysis:** Focus on specific time periods
  * **Slot-based filtering:** Only process entries from certain slots
  * **Transaction type filtering:** Focus on entries with specific transaction types
</Note>

Example client-side filtering:

```typescript
function handleFilteredEntries(data: any): void {
  if (data.entry) {
    const entry = data.entry;
    
    // Only process entries with transactions
    if (entry.transactions?.length > 0) {
      // Only process entries with non-vote transactions
      const hasNonVoteTransactions = entry.transactions.some((tx: any) => !tx.isVote);
      
      if (hasNonVoteTransactions) {
        processImportantEntry(entry);
      }
    }
  }
}
```

## Best Practices

<Accordion title="When to Use Entry Monitoring">
  **Appropriate use cases:**

  * Deep blockchain analysis and research
  * Validator performance studies
  * Network debugging and forensics
  * Academic blockchain research
  * Understanding PoH mechanics

  **When NOT to use:**

  * Standard application development
  * User-facing features
  * Business logic implementation
  * Real-time trading applications
</Accordion>

<Accordion title="Performance Guidelines">
  **Handle high-volume data:**

  * Implement efficient data processing
  * Use asynchronous processing patterns
  * Consider data sampling for analysis
  * Monitor memory usage and cleanup
  * Implement backpressure handling
</Accordion>

<Accordion title="Analysis Techniques">
  **Effective entry analysis:**

  * Focus on specific metrics
  * Use statistical sampling
  * Implement rolling averages
  * Track patterns over time
  * Correlate with other blockchain data
</Accordion>

## Troubleshooting

<Accordion title="High Data Volume">
  **Issue:** Overwhelming entry stream volume

  **Solutions:**

  * Implement client-side filtering
  * Use data sampling techniques
  * Process entries asynchronously
  * Monitor system resources
  * Consider alternative monitoring approaches
</Accordion>

<Accordion title="Missing Context">
  **Issue:** Need additional transaction context

  **Solutions:**

  * Combine with transaction monitoring
  * Cross-reference with account updates
  * Use block monitoring for broader context
  * Maintain local state tracking
</Accordion>

## Next Steps

<CardGroup cols={2}>
  <Card title="Complete Your Learning" icon="graduation-cap" href="/grpc/stream-pump-amm-data">
    Advanced real-world example: Stream Pump AMM data
  </Card>

  <Card title="Explore Other Monitoring" icon="receipt" href="/grpc/transaction-monitoring">
    Go back to transaction monitoring for practical applications
  </Card>
</CardGroup>

<Note>
  **Remember:** Entry monitoring is a specialized tool for advanced blockchain analysis. For most applications, transaction, account, or block monitoring will be more appropriate and efficient.
</Note>


# Solana Yellowstone gRPC Quickstart: Real-Time Data Streaming
Source: https://www.helius.dev/docs/grpc/quickstart

Complete setup guide for streaming real-time Solana data with Yellowstone gRPC. From installation to your first working stream with auto-reconnection.

## What You'll Build

By the end of this guide, you'll have a working gRPC stream that monitors Solana account updates in real-time with automatic reconnection and error handling.

<Steps>
  <Step title="Choose Your Access Method">
    Select how you want to access Yellowstone gRPC:

    <CardGroup cols={2}>
      <Card title="LaserStream" icon="rocket">
        **Recommended for most users**

        * Multi-tenant, highly available
        * Automatic failover and backfill
        * Quick setup with API key
        * Professional plan required

        [Get LaserStream Access ](/laserstream/)
      </Card>

      <Card title="Dedicated Nodes" icon="server">
        **For high-volume or custom needs**

        * Exclusive gRPC endpoint
        * Guaranteed resources

        [Get Dedicated Node ](/dedicated-nodes/)
      </Card>
    </CardGroup>
  </Step>

  <Step title="Set Up Your Environment">
    Create a new project and install dependencies:

    <Tabs>
      <Tab title="TypeScript/JavaScript">
        ```bash
        mkdir solana-grpc-stream
        cd solana-grpc-stream
        npm init -y
        npm install @triton-one/yellowstone-grpc bs58
        npm install typescript ts-node @types/node --save-dev
        npx tsc --init
        ```
      </Tab>

      <Tab title="Rust">
        ```bash
        cargo new solana-grpc-stream
        cd solana-grpc-stream
        ```

        Add to `Cargo.toml`:

        ```toml
        [dependencies]
        yellowstone-grpc-client = "1.13.0"
        yellowstone-grpc-proto = "1.13.0"
        tokio = { version = "1.0", features = ["full"] }
        anyhow = "1.0"
        futures = "0.3"
        tonic = "0.10"
        ```
      </Tab>

      <Tab title="Go">
        ```bash
        mkdir solana-grpc-stream
        cd solana-grpc-stream
        go mod init solana-grpc-stream
        go get github.com/rpcpool/yellowstone-grpc/examples/golang@latest
        go get google.golang.org/grpc@v1.67.1
        ```
      </Tab>
    </Tabs>
  </Step>

  <Step title="Get Your Credentials">
    Obtain your gRPC endpoint and authentication:

    <Tabs>
      <Tab title="LaserStream">
        1. Sign up for a Professional plan at [dashboard.helius.dev](https://dashboard.helius.dev)
        2. Get your API key from the dashboard
        3. Choose your regional endpoint:

        **Mainnet Endpoints:**

        * US East: `https://laserstream-mainnet-ewr.helius-rpc.com`
        * US West: `https://laserstream-mainnet-slc.helius-rpc.com`
        * Europe: `https://laserstream-mainnet-fra.helius-rpc.com`
        * Asia: `https://laserstream-mainnet-tyo.helius-rpc.com`

        **Devnet:** `https://laserstream-devnet-ewr.helius-rpc.com`
      </Tab>

      <Tab title="Dedicated Nodes">
        1. Order a dedicated node from [dashboard.helius.dev](https://dashboard.helius.dev/dedicated-nodes)
        2. Once provisioned, you'll receive:
           * Your gRPC endpoint (typically `your-node.rpc.helius.dev:2053`)
           * Your authentication token
      </Tab>
    </Tabs>
  </Step>

  <Step title="Create Your First Stream">
    Create a robust stream manager with the following complete example:

    <Tabs>
      <Tab title="TypeScript">
        Create `stream-manager.ts`:

        ```typescript
        import Client, { CommitmentLevel, SubscribeRequest } from "@triton-one/yellowstone-grpc";
        import * as bs58 from 'bs58';

        export class StreamManager {
          private client: Client;
          private stream: any;
          private isConnected = false;
          private reconnectAttempts = 0;
          private readonly maxReconnectAttempts = 10;
          private readonly baseReconnectDelay = 1000; // 1 second

          constructor(
            private endpoint: string,
            private apiKey: string,
            private onData: (data: any) => void,
            private onError?: (error: any) => void
          ) {
            this.client = new Client(endpoint, apiKey, {
              "grpc.max_receive_message_length": 64 * 1024 * 1024
            });
          }

          async connect(subscribeRequest: SubscribeRequest): Promise<void> {
            try {
              console.log(`Connecting to ${this.endpoint}...`);
              this.stream = await this.client.subscribe();
              this.isConnected = true;
              this.reconnectAttempts = 0;

              // Set up event handlers
              this.stream.on("data", this.handleData.bind(this));
              this.stream.on("error", this.handleStreamError.bind(this));
              this.stream.on("end", () => this.handleDisconnect(subscribeRequest));
              this.stream.on("close", () => this.handleDisconnect(subscribeRequest));

              // Send subscription request
              await this.writeRequest(subscribeRequest);
              
              // Start keepalive
              this.startKeepalive();
              
              console.log(" Connected and subscribed successfully");
            } catch (error) {
              console.error("Connection failed:", error);
              await this.reconnect(subscribeRequest);
            }
          }

          private async writeRequest(request: SubscribeRequest): Promise<void> {
            return new Promise((resolve, reject) => {
              this.stream.write(request, (err: any) => {
                if (err) reject(err);
                else resolve();
              });
            });
          }

          private handleData(data: any): void {
            try {
              // Convert buffers to readable format
              const processedData = this.processBuffers(data);
              this.onData(processedData);
            } catch (error) {
              console.error("Error processing data:", error);
            }
          }

          private processBuffers(obj: any): any {
            if (!obj) return obj;
            
            if (Buffer.isBuffer(obj) || obj instanceof Uint8Array) {
              return bs58.default.encode(obj);
            }
            
            if (Array.isArray(obj)) {
              return obj.map(item => this.processBuffers(item));
            }
            
            if (typeof obj === 'object') {
              return Object.fromEntries(
                Object.entries(obj).map(([k, v]) => [k, this.processBuffers(v)])
              );
            }
            
            return obj;
          }

          private handleStreamError(error: any): void {
            console.error("Stream error:", error);
            this.isConnected = false;
            if (this.onError) this.onError(error);
          }

          private async handleDisconnect(subscribeRequest: SubscribeRequest): Promise<void> {
            if (this.isConnected) {
              console.log("Stream disconnected, attempting to reconnect...");
              this.isConnected = false;
              await this.reconnect(subscribeRequest);
            }
          }

          private async reconnect(subscribeRequest: SubscribeRequest): Promise<void> {
            if (this.reconnectAttempts >= this.maxReconnectAttempts) {
              console.error("Max reconnection attempts reached. Giving up.");
              return;
            }

            this.reconnectAttempts++;
            const delay = this.baseReconnectDelay * Math.pow(2, Math.min(this.reconnectAttempts - 1, 5));
            
            console.log(`Reconnect attempt ${this.reconnectAttempts}/${this.maxReconnectAttempts} in ${delay}ms...`);
            
            setTimeout(() => {
              this.connect(subscribeRequest).catch(console.error);
            }, delay);
          }

          private startKeepalive(): void {
            setInterval(() => {
              if (this.isConnected) {
                const pingRequest: SubscribeRequest = {
                  ping: { id: Date.now() },
                  accounts: {},
                  accountsDataSlice: [],
                  transactions: {},
                  slots: {},
                  blocks: {},
                  blocksMeta: {},
                  entry: {},
                  transactionsStatus: {}
                };
                
                this.writeRequest(pingRequest).catch(console.error);
              }
            }, 30000); // 30 seconds
          }

          disconnect(): void {
            if (this.stream) {
              this.stream.end();
            }
            this.client.close();
            this.isConnected = false;
          }
        }
        ```

        Create `main.ts`:

        ```typescript
        import { StreamManager } from './stream-manager';
        import { CommitmentLevel, SubscribeRequest } from "@triton-one/yellowstone-grpc";

        // Configuration
        const ENDPOINT = "your-grpc-endpoint"; // LaserStream or Dedicated Node endpoint
        const API_KEY = "your-api-key";

        // USDC Token Mint for example
        const USDC_MINT = "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v";

        async function main() {
          const streamManager = new StreamManager(
            ENDPOINT,
            API_KEY,
            handleAccountUpdate,
            handleError
          );

          // Subscribe to USDC mint account updates
          const subscribeRequest: SubscribeRequest = {
            accounts: {
              accountSubscribe: {
                account: [USDC_MINT],
                owner: [],
                filters: []
              }
            },
            accountsDataSlice: [],
            commitment: CommitmentLevel.CONFIRMED,
            slots: {},
            transactions: {},
            transactionsStatus: {},
            blocks: {},
            blocksMeta: {},
            entry: {}
          };

          console.log(" Starting USDC mint account monitoring...");
          await streamManager.connect(subscribeRequest);

          // Handle graceful shutdown
          process.on('SIGINT', () => {
            console.log('\n Shutting down...');
            streamManager.disconnect();
            process.exit(0);
          });
        }

        function handleAccountUpdate(data: any): void {
          if (data.account) {
            const account = data.account.account;
            console.log('\n Account Update:');
            console.log(`  Account: ${account.pubkey}`);
            console.log(`  Owner: ${account.owner}`);
            console.log(`  Lamports: ${account.lamports}`);
            console.log(`  Data Length: ${account.data?.length || 0} bytes`);
            console.log(`  Slot: ${data.account.slot}`);
            console.log(`  Timestamp: ${new Date().toISOString()}`);
          }
          
          if (data.pong) {
            console.log(` Keepalive pong received (id: ${data.pong.id})`);
          }
        }

        function handleError(error: any): void {
          console.error(' Stream error:', error.message);
        }

        main().catch(console.error);
        ```

        Run your stream:

        ```bash
        npx ts-node main.ts
        ```
      </Tab>

      <Tab title="Rust">
        Create `src/main.rs`:

        ```rust
        use yellowstone_grpc_client::GeyserGrpcClient;
        use yellowstone_grpc_proto::prelude::*;
        use futures::StreamExt;
        use std::collections::HashMap;
        use tokio::time::{sleep, Duration};

        #[tokio::main]
        async fn main() -> anyhow::Result<()> {
            let endpoint = "your-grpc-endpoint"; // Replace with your endpoint
            let token = Some("your-api-key".to_string()); // Replace with your API key
            
            let mut client = GeyserGrpcClient::connect(endpoint, token, None).await?;
            
            // USDC mint account
            let usdc_mint = "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v";
            
            let mut accounts = HashMap::new();
            accounts.insert(
                "usdc_mint".to_string(),
                SubscribeRequestFilterAccounts {
                    account: vec![usdc_mint.to_string()],
                    owner: vec![],
                    filters: vec![],
                }
            );
            
            let mut stream = client.subscribe_once(
                accounts,
                HashMap::new(), // slots
                HashMap::new(), // transactions
                HashMap::new(), // blocks
                HashMap::new(), // blocks_meta
                None, // commitment
                HashMap::new(), // accounts_data_slice
                Some(CommitmentLevel::Confirmed),
                HashMap::new(), // entry
            ).await?;

            println!(" Connected! Monitoring USDC mint account...");
            
            while let Some(message) = stream.next().await {
                match message {
                    Ok(msg) => {
                        if let Some(account) = msg.update_oneof {
                            match account {
                                subscribe_update::UpdateOneof::Account(account_update) => {
                                    println!("\n Account Update:");
                                    println!("  Account: {}", account_update.account.as_ref()
                                        .map(|a| &a.pubkey).unwrap_or(&"N/A".to_string()));
                                    println!("  Lamports: {}", account_update.account.as_ref()
                                        .map(|a| a.lamports).unwrap_or(0));
                                    println!("  Slot: {}", account_update.slot);
                                }
                                _ => {} // Handle other update types as needed
                            }
                        }
                    }
                    Err(error) => {
                        eprintln!(" Stream error: {}", error);
                        sleep(Duration::from_secs(1)).await;
                    }
                }
            }
            
            Ok(())
        }
        ```

        Run your stream:

        ```bash
        cargo run
        ```
      </Tab>

      <Tab title="Go">
        Create `main.go`:

        ```go
        package main

        import (
            "context"
            "fmt"
            "log"
            "time"

            "github.com/rpcpool/yellowstone-grpc/examples/golang/pkg/grpc"
            pb "github.com/rpcpool/yellowstone-grpc/examples/golang/pkg/proto"
            "google.golang.org/grpc/metadata"
        )

        func main() {
            endpoint := "your-grpc-endpoint" // Replace with your endpoint
            apiKey := "your-api-key"         // Replace with your API key
            
            client, err := grpc.NewGrpcConnection(context.Background(), endpoint)
            if err != nil {
                log.Fatalf("Failed to connect: %v", err)
            }
            defer client.Close()
            
            // Add authentication
            ctx := metadata.AppendToOutgoingContext(context.Background(), "x-token", apiKey)
            
            // USDC mint account
            usdcMint := "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"
            
            stream, err := client.Subscribe(ctx)
            if err != nil {
                log.Fatalf("Failed to subscribe: %v", err)
            }
            
            // Send subscription request
            request := &pb.SubscribeRequest{
                Accounts: map[string]*pb.SubscribeRequestFilterAccounts{
                    "usdc_mint": {
                        Account: []string{usdcMint},
                        Owner:   []string{},
                        Filters: []*pb.SubscribeRequestFilterAccountsFilter{},
                    },
                },
                Commitment: pb.CommitmentLevel_CONFIRMED,
            }
            
            if err := stream.Send(request); err != nil {
                log.Fatalf("Failed to send request: %v", err)
            }
            
            fmt.Println(" Connected! Monitoring USDC mint account...")
            
            for {
                response, err := stream.Recv()
                if err != nil {
                    log.Printf(" Stream error: %v", err)
                    time.Sleep(time.Second)
                    continue
                }
                
                if account := response.GetAccount(); account != nil {
                    fmt.Printf("\n Account Update:\n")
                    fmt.Printf("  Account: %s\n", account.Account.Pubkey)
                    fmt.Printf("  Lamports: %d\n", account.Account.Lamports)
                    fmt.Printf("  Slot: %d\n", account.Slot)
                    fmt.Printf("  Timestamp: %s\n", time.Now().Format(time.RFC3339))
                }
            }
        }
        ```

        Run your stream:

        ```bash
        go run main.go
        ```
      </Tab>
    </Tabs>
  </Step>

  <Step title="Test Your Stream">
    Run your application and verify it's working:

    1. **Start your stream** using the command for your language
    2. **Look for connection confirmation** in the console
    3. **Wait for account updates** - you should see periodic updates to the USDC mint account
    4. **Test reconnection** by temporarily disconnecting your internet
    5. **Verify keepalive** by watching for pong messages every 30 seconds

    **Expected output:**

    ```
     Connected! Monitoring USDC mint account...
     Connected and subscribed successfully
     Keepalive pong received (id: 1703123456789)

     Account Update:
      Account: EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v
      Owner: TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb
      Lamports: 1461600
      Data Length: 82 bytes
      Slot: 275123456
      Timestamp: 2024-01-15T10:30:45.123Z
    ```
  </Step>
</Steps>

## What's Next?

Now that you have a working gRPC stream, explore these monitoring guides:

<CardGroup cols={2}>
  <Card title="Account Monitoring" icon="user" href="/grpc/account-monitoring">
    Advanced account filtering and data slicing techniques
  </Card>

  <Card title="Transaction Monitoring" icon="receipt" href="/grpc/transaction-monitoring">
    Stream transactions with program filtering and execution details
  </Card>

  <Card title="Slot & Block Monitoring" icon="cube" href="/grpc/slot-and-block-monitoring">
    Monitor network consensus and block production
  </Card>

  <Card title="Stream Pump AMM Data" icon="chart-line" href="/grpc/stream-pump-amm-data">
    Real-world example: monitor DeFi protocol data
  </Card>
</CardGroup>

## Troubleshooting

<Accordion title="Connection Issues">
  **Symptoms:** Connection timeouts, authentication errors

  **Solutions:**

  * Verify your endpoint URL and API key
  * Check if your plan includes gRPC access
  * Ensure you're using the correct port (typically 2053 for Dedicated Nodes)
  * For LaserStream, make sure you have a Professional plan
</Accordion>

<Accordion title="No Data Received">
  **Symptoms:** Stream connects but no account updates appear

  **Solutions:**

  * USDC mint updates are infrequent - try monitoring a more active account
  * Check your commitment level (try `PROCESSED` for more frequent updates)
  * Verify your account filter configuration
  * Monitor a token account instead of the mint for more activity
</Accordion>

<Accordion title="Stream Disconnections">
  **Symptoms:** Frequent disconnections, reconnection loops

  **Solutions:**

  * Implement exponential backoff (included in examples above)
  * Check network stability
  * Ensure keepalive pings are working (every 30 seconds)
  * Monitor server-side rate limits
</Accordion>

## Best Practices

<Note>
  **Production Readiness Checklist:**

  *  Implement exponential backoff for reconnections
  *  Use keepalive pings every 30 seconds
  *  Handle all stream events (data, error, end, close)
  *  Process data asynchronously to avoid blocking
  *  Monitor connection health and alert on failures
  *  Use appropriate commitment levels for your use case
  *  Filter data as specifically as possible to reduce bandwidth
</Note>


# Slot & Block Monitoring with Yellowstone gRPC
Source: https://www.helius.dev/docs/grpc/slot-and-block-monitoring

Monitor Solana network consensus, block production, and network state changes with real-time slot and block streaming.

## Overview

Slot and block monitoring provides insights into Solana's network consensus, block production timing, and network health. Track slot progression, block finalization, and network performance metrics in real-time.

<Info>
  **Prerequisites:** This guide assumes you've completed the [Yellowstone gRPC Quickstart](/grpc/quickstart) and have a working stream setup.
</Info>

## Monitoring Types

<Tabs>
  <Tab title="Slot Updates">
    **Track network consensus progression**

    Monitor slot advancement across different commitment levels:

    ```typescript
    const subscribeRequest: SubscribeRequest = {
      slots: {
        slotSubscribe: {
          filterByCommitment: false // Receive all commitment levels
        }
      },
      commitment: CommitmentLevel.CONFIRMED
    };
    ```

    **Slot data includes:**

    * Slot number
    * Parent slot
    * Commitment status (processed, confirmed, finalized)
    * Leader information

    <Note>
      **Best for:** Network health monitoring, slot timing analysis, consensus tracking
    </Note>
  </Tab>

  <Tab title="Block Data">
    **Monitor complete block information**

    Stream full blocks with transactions and account updates:

    ```typescript
    const subscribeRequest: SubscribeRequest = {
      blocks: {
        blockSubscribe: {
          accountInclude: [], // All accounts
          includeTransactions: true,
          includeAccounts: true,
          includeEntries: false
        }
      },
      commitment: CommitmentLevel.CONFIRMED
    };
    ```

    **Block data includes:**

    * Block metadata
    * All transactions
    * Account updates
    * Block timing

    <Warning>
      **High volume:** Full block streams generate significant data. Use filters to reduce volume.
    </Warning>
  </Tab>

  <Tab title="Block Metadata">
    **Lightweight block information**

    Get block metadata without transaction details:

    ```typescript
    const subscribeRequest: SubscribeRequest = {
      blocksMeta: {
        blockMetaSubscribe: {}
      },
      commitment: CommitmentLevel.CONFIRMED
    };
    ```

    **Metadata includes:**

    * Block hash and parent hash
    * Slot number
    * Block height
    * Transaction count
    * Block rewards

    <Tip>
      **Efficient:** Lower bandwidth alternative to full block streaming
    </Tip>
  </Tab>
</Tabs>

## Practical Examples

### Example 1: Network Health Monitor

Track slot progression and identify network issues:

```typescript
import { StreamManager } from './stream-manager'; // From quickstart guide

async function monitorNetworkHealth() {
  const streamManager = new StreamManager(
    "your-grpc-endpoint",
    "your-api-key",
    handleNetworkHealth
  );

  const subscribeRequest: SubscribeRequest = {
    slots: {
      slotSubscribe: {
        filterByCommitment: false // Track all commitment levels
      }
    },
    commitment: CommitmentLevel.PROCESSED
  };

  await streamManager.connect(subscribeRequest);
}

let lastSlot = 0;
let lastTimestamp = Date.now();
const slotTimes: number[] = [];

function handleNetworkHealth(data: any): void {
  if (data.slot) {
    const slot = data.slot;
    const currentTime = Date.now();
    
    console.log(`\n Slot Update:`);
    console.log(`  Slot: ${slot.slot}`);
    console.log(`  Parent: ${slot.parentSlot}`);
    console.log(`  Status: ${slot.status}`);
    
    // Calculate slot timing
    if (lastSlot > 0) {
      const slotDiff = slot.slot - lastSlot;
      const timeDiff = currentTime - lastTimestamp;
      
      if (slotDiff === 1) {
        // Normal slot progression
        const slotTime = timeDiff;
        slotTimes.push(slotTime);
        
        // Keep last 100 slot times for analysis
        if (slotTimes.length > 100) {
          slotTimes.shift();
        }
        
        const avgSlotTime = slotTimes.reduce((a, b) => a + b, 0) / slotTimes.length;
        
        console.log(`  Slot Time: ${slotTime}ms`);
        console.log(`  Avg Slot Time: ${avgSlotTime.toFixed(1)}ms`);
        
        // Alert on slow slots
        if (slotTime > 800) {
          console.log(`    SLOW SLOT: ${slotTime}ms (normal ~400ms)`);
        }
      } else if (slotDiff > 1) {
        console.log(`    SKIPPED ${slotDiff - 1} SLOTS`);
      }
    }
    
    lastSlot = slot.slot;
    lastTimestamp = currentTime;
  }
}
```

### Example 2: Block Production Monitor

Track block production and transaction volume:

```typescript
async function monitorBlockProduction() {
  const streamManager = new StreamManager(
    "your-grpc-endpoint",
    "your-api-key",
    handleBlockProduction
  );

  const subscribeRequest: SubscribeRequest = {
    blocksMeta: {
      blockMetaSubscribe: {}
    },
    commitment: CommitmentLevel.CONFIRMED
  };

  await streamManager.connect(subscribeRequest);
}

function handleBlockProduction(data: any): void {
  if (data.blockMeta) {
    const blockMeta = data.blockMeta;
    
    console.log(`\n Block Produced:`);
    console.log(`  Slot: ${blockMeta.slot}`);
    console.log(`  Block Height: ${blockMeta.blockHeight}`);
    console.log(`  Block Hash: ${blockMeta.blockhash}`);
    console.log(`  Parent Hash: ${blockMeta.parentBlockhash}`);
    console.log(`  Transactions: ${blockMeta.transactionCount}`);
    console.log(`  Block Time: ${new Date(blockMeta.blockTime * 1000).toISOString()}`);
    
    if (blockMeta.rewards?.length > 0) {
      console.log(`  Rewards:`);
      blockMeta.rewards.forEach((reward: any) => {
        console.log(`    ${reward.pubkey}: ${reward.lamports} lamports (${reward.rewardType})`);
      });
    }
    
    // Alert on high transaction count
    if (blockMeta.transactionCount > 3000) {
      console.log(`   HIGH ACTIVITY: ${blockMeta.transactionCount} transactions`);
    }
  }
}
```

### Example 3: Filtered Block Monitor

Monitor blocks containing specific program activity:

```typescript
async function monitorDEXBlocks() {
  const streamManager = new StreamManager(
    "your-grpc-endpoint",
    "your-api-key",
    handleDEXBlock
  );

  const subscribeRequest: SubscribeRequest = {
    blocks: {
      blockSubscribe: {
        accountInclude: [
          "9WzDXwBbmkg8ZTbNMqUxvQRAyrZzDsGYdLVL9zYtAWWM", // Raydium V4
          "JUP6LkbZbjS1jKKwapdHNy74zcZ3tLUZoi5QNyVTaV4"   // Jupiter
        ],
        includeTransactions: true,
        includeAccounts: false,
        includeEntries: false
      }
    },
    commitment: CommitmentLevel.CONFIRMED
  };

  await streamManager.connect(subscribeRequest);
}

function handleDEXBlock(data: any): void {
  if (data.block) {
    const block = data.block;
    
    console.log(`\n DEX Activity Block:`);
    console.log(`  Slot: ${block.slot}`);
    console.log(`  Block Hash: ${block.blockhash}`);
    console.log(`  Total Transactions: ${block.transactions?.length || 0}`);
    
    if (block.transactions) {
      let dexTxCount = 0;
      let totalFees = 0;
      
      block.transactions.forEach((tx: any) => {
        if (tx.meta && !tx.meta.err) {
          dexTxCount++;
          totalFees += tx.meta.fee || 0;
        }
      });
      
      console.log(`  DEX Transactions: ${dexTxCount}`);
      console.log(`  Total Fees: ${(totalFees / 1e9).toFixed(4)} SOL`);
      console.log(`  Avg Fee: ${(totalFees / dexTxCount / 1e9).toFixed(6)} SOL`);
    }
  }
}
```

## Data Structures

Understanding slot and block data formats:

<Accordion title="Slot Data Structure">
  ```typescript
  {
    slot: number;           // Current slot number
    parentSlot: number;     // Parent slot number  
    status: string;         // "processed", "confirmed", "finalized"
  }
  ```

  **Slot progression:** Each slot represents \~400ms of network time

  **Commitment levels:**

  * **Processed:** Initial slot processing
  * **Confirmed:** Supermajority confirmation
  * **Finalized:** Irreversible finalization
</Accordion>

<Accordion title="Block Metadata Structure">
  ```typescript
  {
    slot: number;
    blockHeight: number;
    blockhash: string;
    parentBlockhash: string;
    blockTime: number;      // Unix timestamp
    transactionCount: number;
    rewards: Array<{
      pubkey: string;
      lamports: number;
      rewardType: string;   // "fee", "rent", "voting", "staking"
    }>;
  }
  ```

  **Block time:** Estimated time when the block was produced

  **Rewards:** Validator rewards for block production
</Accordion>

<Accordion title="Full Block Structure">
  ```typescript
  {
    slot: number;
    parentSlot: number;
    blockhash: string;
    previousBlockhash: string;
    transactions: Transaction[];  // Full transaction data
    accounts: AccountUpdate[];    // Account state changes
    entries: Entry[];            // Block entries (if included)
  }
  ```

  **Size warning:** Full blocks can be several MB with all transactions and accounts
</Accordion>

## Performance Considerations

<CardGroup cols={2}>
  <Card title="Slot Monitoring" icon="clock">
    **Lightweight and efficient**

    * Very low bandwidth usage
    * Real-time network health insights
    * Minimal processing overhead
    * Good for monitoring dashboards
  </Card>

  <Card title="Block Metadata" icon="info">
    **Balanced approach**

    * Moderate bandwidth usage
    * Block-level insights without full data
    * Transaction counts and timing
    * Suitable for analytics
  </Card>

  <Card title="Full Blocks" icon="database">
    **High volume data**

    * High bandwidth requirements
    * Complete transaction data
    * Requires robust processing
    * Use filters to reduce volume
  </Card>

  <Card title="Filtered Blocks" icon="filter">
    **Optimized streaming**

    * Use accountInclude filters
    * Disable unnecessary data (entries, accounts)
    * Focus on specific programs
    * Balance detail with performance
  </Card>
</CardGroup>

## Use Cases

<Tabs>
  <Tab title="Network Monitoring">
    **Track network health and performance**

    * Slot timing analysis
    * Network congestion detection
    * Consensus monitoring
    * Validator performance

    ```typescript
    // Monitor slot timing deviations
    const targetSlotTime = 400; // ms
    const tolerance = 200; // ms

    if (Math.abs(slotTime - targetSlotTime) > tolerance) {
      console.log(`Network performance issue detected`);
    }
    ```
  </Tab>

  <Tab title="Analytics & Metrics">
    **Collect blockchain analytics data**

    * Transaction volume tracking
    * Fee analysis
    * Block size metrics
    * Activity patterns

    ```typescript
    // Track daily transaction volumes
    const dailyStats = {
      date: new Date().toDateString(),
      totalTransactions: 0,
      totalFees: 0,
      blockCount: 0
    };
    ```
  </Tab>

  <Tab title="Application Synchronization">
    **Keep applications in sync with network**

    * Slot-based updates
    * Block confirmations
    * Network state tracking
    * Timing synchronization

    ```typescript
    // Update application state on finalized slots
    if (data.slot && data.slot.status === 'finalized') {
      updateApplicationState(data.slot.slot);
    }
    ```
  </Tab>
</Tabs>

## Error Handling

Common issues and solutions:

<Accordion title="Missing Slots">
  **Issue:** Gaps in slot progression

  **Causes:**

  * Network connectivity issues
  * Validator downtime
  * Client processing delays

  **Solutions:**

  * Track slot gaps and alert
  * Implement catch-up logic
  * Monitor connection health
</Accordion>

<Accordion title="High Volume">
  **Issue:** Too much block data

  **Solutions:**

  * Use block metadata instead of full blocks
  * Apply account filters to reduce data
  * Disable unnecessary inclusions (entries, accounts)
  * Process data asynchronously
</Accordion>

<Accordion title="Timing Issues">
  **Issue:** Inconsistent slot timing

  **Analysis:**

  * Calculate moving averages
  * Track timing deviations
  * Monitor network health metrics
  * Correlate with validator performance
</Accordion>

## Best Practices

<Note>
  **Production Guidelines:**

  * **Start with metadata** - Use block metadata before full blocks
  * **Apply filters** - Use accountInclude to reduce irrelevant data
  * **Monitor timing** - Track slot progression for network health
  * **Handle gaps** - Implement logic for missing slots/blocks
  * **Process async** - Don't block stream processing with heavy computations
  * **Use appropriate commitment** - Match commitment level to your needs
</Note>

## Next Steps

<CardGroup cols={2}>
  <Card title="Entry Monitoring" icon="code" href="/grpc/entry-monitoring">
    Learn about low-level blockchain entry monitoring
  </Card>

  <Card title="Advanced Patterns" icon="chart-line" href="/grpc/stream-pump-amm-data">
    Real-world example: monitoring Pump AMM data
  </Card>
</CardGroup>


# Solana Pump AMM Data Streaming: gRPC Guide
Source: https://www.helius.dev/docs/grpc/stream-pump-amm-data

Complete real-world example of monitoring Solana Pump.fun AMM data using Yellowstone gRPC. Track token launches, prices, and trading activity in real-time.

## Overview

This comprehensive example demonstrates how to build a production-ready Pump.fun AMM monitoring system using Yellowstone gRPC. You'll learn to track token launches, price movements, trading activity, and market analytics in real-time.

<Info>
  **Prerequisites:** This guide builds on concepts from [Account Monitoring](/grpc/account-monitoring), [Transaction Monitoring](/grpc/transaction-monitoring), and assumes familiarity with Pump.fun's architecture.
</Info>

## What We'll Build

<CardGroup cols={2}>
  <Card title="Token Launch Monitor" icon="rocket">
    **Real-time token discovery**

    * New token creation detection
    * Initial liquidity tracking
    * Metadata extraction
    * Launch metrics
  </Card>

  <Card title="Trading Activity Stream" icon="chart-line">
    **Live trading data**

    * Buy/sell transaction parsing
    * Price calculation
    * Volume tracking
    * Whale activity detection
  </Card>

  <Card title="Market Analytics" icon="calculator">
    **Advanced metrics**

    * Market cap calculations
    * Liquidity depth analysis
    * Trading patterns
    * Performance indicators
  </Card>

  <Card title="Alert System" icon="bell">
    **Smart notifications**

    * Price movement alerts
    * High-volume trading
    * New token launches
    * Unusual activity detection
  </Card>
</CardGroup>

## Architecture Overview

Our monitoring system will use multiple gRPC streams for comprehensive coverage:

```typescript
// Multi-stream architecture for comprehensive monitoring
const monitoringSystem = {
  accounts: {
    // Monitor Pump program state changes
    pumpProgram: "6EF8rrecthR5Dkzon8Nwu78hRvfCKubJ14M5uBEwF6P",
    // Bonding curve accounts for active tokens
    bondingCurves: [] // Dynamic list
  },
  transactions: {
    // All Pump program interactions
    programTransactions: true,
    // System program for SOL transfers
    systemProgram: true,
    // Token program for SPL token operations
    tokenProgram: true
  }
};
```

## Core Implementation

### 1. Stream Manager with Multi-Stream Support

```typescript
import Client, { CommitmentLevel, SubscribeRequest } from "@triton-one/yellowstone-grpc";
// Note: Use the StreamManager class from the quickstart guide

class PumpMonitoringSystem {
  private streamManager: StreamManager;
  private analytics: PumpAnalytics;

  constructor(endpoint: string, apiKey: string) {
    this.streamManager = new StreamManager(
      endpoint,
      apiKey,
      this.handleUpdate.bind(this),
      this.handleError.bind(this)
    );
    this.analytics = new PumpAnalytics();
  }

  async start(): Promise<void> {
    // Start multiple streams for comprehensive monitoring
    await Promise.all([
      this.startAccountMonitoring(),
      this.startTransactionMonitoring()
    ]);
  }

  private async startAccountMonitoring(): Promise<void> {
    const subscribeRequest: SubscribeRequest = {
      accounts: {
        pumpAccounts: {
          account: [],
          owner: ["6EF8rrecthR5Dkzon8Nwu78hRvfCKubJ14M5uBEwF6P"], // Pump program
          filters: [
            // TODO: Add specific filters based on actual Pump.fun account structure
          ]
        }
      },
      commitment: CommitmentLevel.CONFIRMED,
      ping: { id: 1 }
    };

    await this.streamManager.connect(subscribeRequest);
  }

  private async startTransactionMonitoring(): Promise<void> {
    const subscribeRequest: SubscribeRequest = {
      transactions: {
        pumpTransactions: {
          accountInclude: ["6EF8rrecthR5Dkzon8Nwu78hRvfCKubJ14M5uBEwF6P"],
          accountExclude: [],
          accountRequired: [],
          vote: false,
          failed: false
        }
      },
      commitment: CommitmentLevel.CONFIRMED,
      ping: { id: 1 }
    };

    await this.streamManager.connect(subscribeRequest);
  }

  private handleUpdate(data: any): void {
    if (data.account) {
      this.handleAccountUpdate(data.account);
    }
    
    if (data.transaction) {
      this.handleTransactionUpdate(data.transaction);
    }
  }

  private handleAccountUpdate(accountData: any): void {
    try {
      const account = accountData.account;
      
      console.log('Account update received:', {
        pubkey: account.pubkey,
        owner: account.account.owner,
        dataLength: account.account.data?.length || 0
      });
      
      // TODO: Implement account data parsing based on Pump.fun's account structure
    } catch (error) {
      console.error('Error processing account update:', error);
    }
  }

  private handleTransactionUpdate(transactionData: any): void {
    try {
      const tx = transactionData.transaction;
      
      if (tx.meta?.err) {
        return; // Skip failed transactions
      }

      // Parse transaction for Pump operations
      const pumpOperation = PumpTransactionParser.parsePumpTransaction(tx);
      
      if (pumpOperation) {
        this.analytics.processPumpOperation(pumpOperation, tx);
      }
    } catch (error) {
      console.error('Error processing transaction update:', error);
    }
  }

  private handleError(error: any): void {
    console.error('Stream error:', error);
    // Implement error recovery logic
  }

  generateDailyReport(): void {
    this.analytics.generateDailyReport();
  }

  disconnect(): void {
    // Disconnect stream manager
    if (this.streamManager) {
      this.streamManager.disconnect();
    }
  }
}
```

### 2. Transaction Analysis Approach

**Important:** This example demonstrates the gRPC streaming concepts. For production Pump.fun monitoring, you'll need to research and implement the actual instruction parsing based on the program's documentation or IDL.

```typescript
// This demonstrates the structure - implement actual parsing based on Pump.fun's program
interface PumpOperation {
  type: string;
  user: string;
  signature: string;
  timestamp: number;
}

class PumpTransactionParser {
  private static PUMP_PROGRAM_ID = "6EF8rrecthR5Dkzon8Nwu78hRvfCKubJ14M5uBEwF6P";

  static parsePumpTransaction(tx: any): PumpOperation | null {
    try {
      const message = tx.transaction?.message;
      if (!message) return null;

      // Check if transaction involves Pump program
      const hasPumpProgram = message.instructions?.some((ix: any) => {
        const programId = message.accountKeys[ix.programIdIndex];
        return programId === this.PUMP_PROGRAM_ID;
      });

      if (!hasPumpProgram) return null;

      // Return basic transaction info - implement actual parsing here
      return {
        type: 'pump_transaction', // Determine actual operation type
        user: message.accountKeys[0], // Fee payer
        signature: tx.signature,
        timestamp: Date.now()
      };
    } catch (error) {
      console.error('Error parsing Pump transaction:', error);
      return null;
    }
  }

  // TODO: Implement metadata extraction based on actual Pump.fun transaction structure
}
}
```

### 3. Basic Analytics Structure

```typescript
class PumpAnalytics {
  private operations: PumpOperation[] = [];

  processPumpOperation(operation: PumpOperation, tx: any): void {
    // Store the operation
    this.operations.push(operation);
    
    console.log(`\n PUMP OPERATION DETECTED`);
    console.log(`  Type: ${operation.type}`);
    console.log(`  User: ${operation.user}`);
    console.log(`  Signature: ${operation.signature}`);
    console.log(`  Timestamp: ${new Date(operation.timestamp).toISOString()}`);
    
    // TODO: Implement specific operation handling based on actual Pump.fun data structure
  }

  generateDailyReport(): void {
    const oneDayAgo = Date.now() - 24 * 60 * 60 * 1000;
    const recentOperations = this.operations.filter(op => op.timestamp > oneDayAgo);

    console.log(`\n DAILY PUMP REPORT`);
    console.log(`  Total Operations: ${recentOperations.length}`);
    console.log(`  Unique Users: ${new Set(recentOperations.map(op => op.user)).size}`);
    
    // Group by operation type
    const typeCount = recentOperations.reduce((acc, op) => {
      acc[op.type] = (acc[op.type] || 0) + 1;
      return acc;
    }, {} as Record<string, number>);
    
    console.log(`\n   Operations by Type:`);
    Object.entries(typeCount).forEach(([type, count]) => {
      console.log(`    ${type}: ${count}`);
    });
  }
}
```

### 4. Complete System Integration

```typescript
// Main application entry point
async function main() {
  const pumpMonitor = new PumpMonitoringSystem(
    "your-grpc-endpoint",
    "your-api-key"
  );

  console.log(' Starting Pump.fun monitoring system...');
  console.log(' Monitoring: Token launches, trades, and market data');
  console.log(' Alerts: Large trades, price movements, new launches\n');

  // Start the monitoring system
  await pumpMonitor.start();

  // Generate reports periodically
  setInterval(() => {
    pumpMonitor.generateDailyReport();
  }, 60 * 60 * 1000); // Every hour

  // Graceful shutdown
  process.on('SIGINT', () => {
    console.log('\n Shutting down Pump monitor...');
    pumpMonitor.disconnect();
    process.exit(0);
  });

  console.log(' Pump.fun monitoring system is running!');
  console.log('Press Ctrl+C to stop\n');
}

main().catch(console.error);
```

## Key Features Demonstrated

<Tabs>
  <Tab title="Multi-Stream Coordination">
    **Combining multiple data sources**

    * Account monitoring for state changes
    * Transaction monitoring for operations
    * Coordinated data processing
    * Real-time synchronization
  </Tab>

  <Tab title="Advanced Parsing">
    **Complex transaction analysis**

    * Instruction discriminator matching
    * Balance change analysis
    * Metadata extraction
    * Error handling and validation
  </Tab>

  <Tab title="Market Analytics">
    **Real-time market metrics**

    * Price calculation and tracking
    * Volume aggregation
    * Market cap estimation
    * Performance analytics
  </Tab>

  <Tab title="Alert System">
    **Intelligent notifications**

    * Event-driven alerts
    * Threshold-based triggers
    * Multi-channel notifications
    * Alert prioritization
  </Tab>
</Tabs>

## Production Considerations

<CardGroup cols={2}>
  <Card title="Performance Optimization" icon="gauge-high">
    **Handle high-volume data**

    * Implement connection pooling
    * Use efficient data structures
    * Process updates asynchronously
    * Monitor memory usage
    * Implement circuit breakers
  </Card>

  <Card title="Data Persistence" icon="database">
    **Reliable data storage**

    * Database integration
    * Backup and recovery
    * Data archival strategies
    * Consistency guarantees
    * Query optimization
  </Card>

  <Card title="Monitoring & Alerting" icon="chart-line">
    **System observability**

    * Application metrics
    * Health check endpoints
    * Error tracking
    * Performance monitoring
    * Alert fatigue prevention
  </Card>

  <Card title="Scalability" icon="arrow-trend-up">
    **Growth planning**

    * Horizontal scaling patterns
    * Load balancing strategies
    * Resource optimization
    * Bottleneck identification
    * Capacity planning
  </Card>
</CardGroup>

## Best Practices Applied

<Note>
  **Production-Ready Patterns:**

  *  **Robust error handling** - Graceful failure recovery
  *  **Data validation** - Input sanitization and verification
  *  **Performance optimization** - Efficient processing patterns
  *  **Monitoring integration** - Comprehensive observability
  *  **Modular architecture** - Maintainable code structure
  *  **Configuration management** - Environment-specific settings
  *  **Testing strategies** - Unit and integration tests
  *  **Documentation** - Clear API and usage documentation
</Note>

## Extending the System

This example provides a foundation for building more advanced features:

<Accordion title="Enhanced Analytics">
  * Technical analysis indicators
  * Market sentiment analysis
  * Correlation analysis between tokens
  * Liquidity depth tracking
  * Arbitrage opportunity detection
</Accordion>

<Accordion title="Advanced Alerts">
  * Machine learning-based anomaly detection
  * Custom alert conditions
  * Multi-channel notifications (Discord, Telegram, etc.)
  * Alert backtesting and optimization
  * Risk management triggers
</Accordion>

<Accordion title="Data Visualization">
  * Real-time dashboards
  * Price charts and technical indicators
  * Market heat maps
  * Trading activity visualizations
  * Performance analytics
</Accordion>

## Conclusion

This comprehensive example demonstrates how to build a production-ready monitoring system using Yellowstone gRPC. The techniques shown here - multi-stream coordination, advanced transaction parsing, real-time analytics, and intelligent alerting - can be applied to monitor any Solana protocol or application.

The key to success with gRPC monitoring is:

1. **Understanding your data needs** - Choose the right monitoring types
2. **Efficient processing** - Handle high-volume streams effectively
3. **Robust error handling** - Build resilient systems
4. **Meaningful analytics** - Extract actionable insights from raw data
5. **Continuous optimization** - Monitor and improve performance

With these foundations, you can build sophisticated monitoring and analytics systems for any Solana application.

<CardGroup cols={2}>
  <Card title="Start Building" icon="rocket" href="/grpc/quickstart">
    Return to the quickstart to begin your own project
  </Card>

  <Card title="Get Support" icon="headset" href="/support">
    Need help? Contact our support team
  </Card>
</CardGroup>


# Transaction Monitoring with Yellowstone gRPC
Source: https://www.helius.dev/docs/grpc/transaction-monitoring

Stream Solana transactions in real-time with program filtering, execution details, and token balance change tracking.

## Overview

Transaction monitoring enables you to track transaction execution, success/failure status, program interactions, and token balance changes across Solana in real-time. This guide covers filtering strategies and practical implementations for different transaction monitoring use cases.

<Info>
  **Prerequisites:** This guide assumes you've completed the [Yellowstone gRPC Quickstart](/grpc/quickstart) and have a working stream setup.
</Info>

## Transaction Filtering Options

<Tabs>
  <Tab title="Program Filtering">
    **Monitor transactions involving specific programs**

    Track all transactions that interact with your programs:

    ```typescript
    const subscribeRequest: SubscribeRequest = {
      transactions: {
        client: {
          accountInclude: [
            "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA", // Token Program
            "11111111111111111111111111111111",              // System Program
            "675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8"  // Your program
          ],
          accountExclude: [],
          accountRequired: [],
          vote: false,
          failed: false
        }
      },
      commitment: CommitmentLevel.CONFIRMED
    };
    ```

    <Note>
      **Best for:** Program-specific monitoring, DeFi protocol tracking, smart contract interactions
    </Note>
  </Tab>

  <Tab title="Account-Specific">
    **Monitor transactions affecting specific accounts**

    Track transactions that modify specific accounts:

    ```typescript
    const subscribeRequest: SubscribeRequest = {
      transactions: {
        client: {
          accountInclude: [
            "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v", // USDC mint
            "YourWalletAddress"                                // Your wallet
          ],
          vote: false,
          failed: true // Include failures to track errors
        }
      },
      commitment: CommitmentLevel.CONFIRMED
    };
    ```

    <Tip>
      **Use case:** Wallet monitoring, token mint tracking, specific account activity
    </Tip>
  </Tab>

  <Tab title="Advanced Filtering">
    **Combine multiple filter criteria**

    Use required accounts and exclusions for precise filtering:

    ```typescript
    const subscribeRequest: SubscribeRequest = {
      transactions: {
        client: {
          accountInclude: ["TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"],
          accountRequired: ["YourProgramId"], // Must include this program
          accountExclude: ["VoteProgram"],     // Exclude vote-related txs
          vote: false,
          failed: false
        }
      },
      commitment: CommitmentLevel.CONFIRMED
    };
    ```

    <Warning>
      **Filter logic:** accountInclude (OR) AND accountRequired (AND) AND NOT accountExclude
    </Warning>
  </Tab>
</Tabs>

## Practical Examples

### Example 1: Monitor DEX Transactions

Track all transactions involving popular DEX programs:

```typescript
import { StreamManager } from './stream-manager'; // From quickstart guide

async function monitorDEXTransactions() {
  const streamManager = new StreamManager(
    "your-grpc-endpoint",
    "your-api-key",
    handleDEXTransaction
  );

  const subscribeRequest: SubscribeRequest = {
    transactions: {
      client: {
        accountInclude: [
          "9WzDXwBbmkg8ZTbNMqUxvQRAyrZzDsGYdLVL9zYtAWWM", // Raydium V4
          "675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8", // Raydium V5
          "CAMMCzo5YL8w4VFF8KVHrK22GGUQpMpTFb6xRmpLFGNnSm", // Raydium CLMM
          "JUP6LkbZbjS1jKKwapdHNy74zcZ3tLUZoi5QNyVTaV4"   // Jupiter
        ],
        vote: false,
        failed: false
      }
    },
    commitment: CommitmentLevel.CONFIRMED
  };

  await streamManager.connect(subscribeRequest);
}

function handleDEXTransaction(data: any): void {
  if (data.transaction?.transaction) {
    const tx = data.transaction.transaction;
    console.log(`\n DEX Transaction:`);
    console.log(`  Signature: ${tx.signature}`);
    console.log(`  Slot: ${data.transaction.slot}`);
    console.log(`  Status: ${tx.meta?.err ? 'Failed' : 'Success'}`);
    console.log(`  Fee: ${tx.meta?.fee || 0} lamports`);
    console.log(`  Compute Units: ${tx.meta?.computeUnitsConsumed || 0}`);
    
    // Show token balance changes
    if (tx.meta?.preTokenBalances?.length > 0) {
      console.log(`  Token Balance Changes:`);
      tx.meta.preTokenBalances.forEach((preBalance: any, index: number) => {
        const postBalance = tx.meta.postTokenBalances[index];
        if (preBalance && postBalance) {
          const change = postBalance.uiTokenAmount.uiAmount - preBalance.uiTokenAmount.uiAmount;
          if (change !== 0) {
            console.log(`    ${preBalance.mint}: ${change > 0 ? '+' : ''}${change}`);
          }
        }
      });
    }
  }
}
```

### Example 2: Monitor Failed Transactions

Track failed transactions to identify issues:

```typescript
async function monitorFailedTransactions() {
  const streamManager = new StreamManager(
    "your-grpc-endpoint",
    "your-api-key",
    handleFailedTransaction
  );

  const subscribeRequest: SubscribeRequest = {
    transactions: {
      client: {
        accountInclude: ["YourProgramId"], // Your program
        vote: false,
        failed: true // Only failed transactions
      }
    },
    commitment: CommitmentLevel.CONFIRMED
  };

  await streamManager.connect(subscribeRequest);
}

function handleFailedTransaction(data: any): void {
  if (data.transaction?.transaction?.meta?.err) {
    const tx = data.transaction.transaction;
    console.log(`\n Failed Transaction:`);
    console.log(`  Signature: ${tx.signature}`);
    console.log(`  Slot: ${data.transaction.slot}`);
    console.log(`  Error: ${JSON.stringify(tx.meta.err)}`);
    console.log(`  Fee: ${tx.meta.fee} lamports`);
    console.log(`  Compute Units: ${tx.meta.computeUnitsConsumed || 0}`);
    
    // Log instruction details for debugging
    if (tx.transaction?.message?.instructions) {
      console.log(`  Instructions:`);
      tx.transaction.message.instructions.forEach((inst: any, i: number) => {
        console.log(`    ${i}: Program ${inst.programIdIndex}, Data: ${inst.data}`);
      });
    }
  }
}
```

### Example 3: Monitor High-Value Transactions

Track transactions with significant SOL transfers:

```typescript
async function monitorHighValueTransactions() {
  const streamManager = new StreamManager(
    "your-grpc-endpoint",
    "your-api-key",
    handleHighValueTransaction
  );

  const subscribeRequest: SubscribeRequest = {
    transactions: {
      client: {
        accountInclude: ["11111111111111111111111111111111"], // System Program
        vote: false,
        failed: false
      }
    },
    commitment: CommitmentLevel.CONFIRMED
  };

  await streamManager.connect(subscribeRequest);
}

function handleHighValueTransaction(data: any): void {
  if (data.transaction?.transaction?.meta) {
    const tx = data.transaction.transaction;
    const preBalances = tx.meta.preBalances || [];
    const postBalances = tx.meta.postBalances || [];
    
    // Calculate largest balance change
    let maxChange = 0;
    preBalances.forEach((preBalance: number, index: number) => {
      const postBalance = postBalances[index] || 0;
      const change = Math.abs(postBalance - preBalance);
      maxChange = Math.max(maxChange, change);
    });
    
    // Only log transactions with > 10 SOL moved
    const changeInSOL = maxChange / 1e9;
    if (changeInSOL > 10) {
      console.log(`\n High-Value Transaction:`);
      console.log(`  Signature: ${tx.signature}`);
      console.log(`  Slot: ${data.transaction.slot}`);
      console.log(`  Max SOL Transfer: ${changeInSOL.toFixed(2)} SOL`);
      console.log(`  Fee: ${tx.meta.fee / 1e9} SOL`);
      console.log(`  Accounts: ${tx.transaction?.message?.accountKeys?.length || 0}`);
    }
  }
}
```

## Transaction Data Structure

Understanding the transaction data structure helps extract relevant information:

<Accordion title="Transaction Message Structure">
  **Core transaction data:**

  ```typescript
  {
    signature: string;
    isVote: boolean;
    transaction: {
      message: {
        accountKeys: string[];        // All accounts involved
        instructions: Instruction[];  // Program instructions
        recentBlockhash: string;     // Recent blockhash used
      };
      signatures: string[];          // Transaction signatures
    };
    meta: {
      err: any;                      // Error details if failed
      fee: number;                   // Transaction fee in lamports
      computeUnitsConsumed: number;  // Compute units used
      preBalances: number[];         // Account balances before
      postBalances: number[];        // Account balances after
      preTokenBalances: TokenBalance[];
      postTokenBalances: TokenBalance[];
      logMessages: string[];         // Program log messages
    };
  }
  ```
</Accordion>

<Accordion title="Token Balance Changes">
  **Token balance structure:**

  ```typescript
  {
    accountIndex: number;
    mint: string;                   // Token mint address
    owner: string;                  // Account owner
    uiTokenAmount: {
      amount: string;               // Raw token amount
      decimals: number;             // Token decimals
      uiAmount: number;             // Human-readable amount
      uiAmountString: string;       // String representation
    };
  }
  ```
</Accordion>

<Accordion title="Instruction Details">
  **Program instruction structure:**

  ```typescript
  {
    programIdIndex: number;         // Index in accountKeys array
    accounts: number[];             // Account indices involved
    data: string;                   // Instruction data (base58)
  }
  ```
</Accordion>

## Filter Logic Reference

<CardGroup cols={2}>
  <Card title="Include Logic (OR)" icon="plus">
    **accountInclude:** Transaction must involve ANY of these accounts

    **Example:** `["A", "B"]` matches transactions involving account A OR account B
  </Card>

  <Card title="Required Logic (AND)" icon="check">
    **accountRequired:** Transaction must involve ALL of these accounts

    **Example:** `["A", "B"]` matches transactions involving account A AND account B
  </Card>

  <Card title="Exclude Logic (NOT)" icon="minus">
    **accountExclude:** Transaction must NOT involve any of these accounts

    **Example:** `["A", "B"]` excludes transactions involving account A or account B
  </Card>

  <Card title="Combined Logic" icon="code">
    **Final filter:** `(accountInclude OR empty) AND (accountRequired AND all) AND NOT (accountExclude OR any)`
  </Card>
</CardGroup>

## Performance Considerations

<Tabs>
  <Tab title="Volume Management">
    **Transaction streams can be high-volume**

    * Start with specific program filters
    * Use commitment levels appropriately
    * Monitor your processing capacity
    * Implement backpressure handling

    ```typescript
    // Rate limiting example
    let transactionCount = 0;
    const startTime = Date.now();

    function handleTransaction(data: any): void {
      transactionCount++;
      
      if (transactionCount % 100 === 0) {
        const elapsed = (Date.now() - startTime) / 1000;
        const rate = transactionCount / elapsed;
        console.log(`Processing ${rate.toFixed(1)} tx/sec`);
      }
      
      // Your transaction processing logic
    }
    ```
  </Tab>

  <Tab title="Data Processing">
    **Optimize data extraction**

    * Process data asynchronously
    * Extract only needed fields
    * Use efficient data structures
    * Consider batching updates

    ```typescript
    // Efficient data extraction
    function extractTransactionData(tx: any) {
      return {
        signature: tx.signature,
        slot: tx.slot,
        success: !tx.meta?.err,
        fee: tx.meta?.fee || 0,
        computeUnits: tx.meta?.computeUnitsConsumed || 0,
        tokenChanges: extractTokenChanges(tx.meta)
      };
    }
    ```
  </Tab>
</Tabs>

## Error Handling

Common transaction monitoring errors and solutions:

<Accordion title="Too Many Transactions">
  **Error:** Overwhelming transaction volume

  **Solutions:**

  * Add more specific filters (accountRequired, accountExclude)
  * Use higher commitment levels to reduce volume
  * Implement sampling or rate limiting
  * Process transactions asynchronously
</Accordion>

<Accordion title="Missing Transactions">
  **Error:** Expected transactions not appearing

  **Solutions:**

  * Verify program addresses are correct
  * Check if transactions actually occur
  * Try PROCESSED commitment for faster updates
  * Ensure filters aren't too restrictive
</Accordion>

<Accordion title="Parse Errors">
  **Error:** Cannot parse transaction data

  **Solutions:**

  * Handle missing fields gracefully
  * Validate data structure before processing
  * Log problematic transactions for debugging
  * Use try-catch blocks around parsing logic
</Accordion>

## Next Steps

<CardGroup cols={2}>
  <Card title="Slot & Block Monitoring" icon="cube" href="/grpc/slot-and-block-monitoring">
    Learn to monitor network consensus and block production
  </Card>

  <Card title="Advanced Patterns" icon="chart-line" href="/grpc/stream-pump-amm-data">
    Real-world example: monitoring Pump AMM data
  </Card>
</CardGroup>


# Welcome to Helius
Source: https://www.helius.dev/docs/index

The high-performance Solana development platform built for builders who demand excellence. Fast, reliable infrastructure that scales with your ambitions.

We're building the infrastructure for the world's first global financial computer. Whether you're building the next DeFi protocol, creating innovative NFT experiences, or pioneering entirely new financial primitives, Helius gives you the tools to turn ambitious ideas into reality. We don't settle for "good enough"we build infrastructure that entire markets depend on.

![Helius Hero](https://mintlify.s3.us-west-1.amazonaws.com/helius/images/hero-light.png)

## Start Building with Helius

Helius provides the infrastructure and APIs you need to build world-class applications on Solana. From your first API call to scaling to millions of users, we've got you covered.

<CardGroup cols={3}>
  <Card title="Quick Start" icon="bolt" href="/quickstart">
    Make your first API call in minutes and start building with Helius.
  </Card>

  <Card title="Plans & Pricing" icon="file-code" href="/billing/plans-and-rate-limits">
    Transparent pricing that scales with your success. No hidden fees.
  </Card>

  <Card title="API Reference" icon="code" href="/api-reference">
    Complete documentation for all Helius APIs and developer tools.
  </Card>
</CardGroup>

## AI-Powered Documentation

Get instant answers and navigate our documentation with AI assistance. Ask questions in natural language and get precise, contextual responses about Helius APIs, features, and best practices.

<video controls className="w-full aspect-video" src="https://mintlify.s3.us-west-1.amazonaws.com/helius/images/helius-ai.mp4" />

<Note>
  **Smart Navigation**: Use AI to quickly find the information you need, get code examples, and understand complex concepts. Available throughout our documentation.
</Note>

## High-Performance RPC Infrastructure

<CardGroup cols={2}>
  <Card title="Solana RPC Nodes" icon="server" href="/rpc/overview">
    Lightning-fast RPC nodes. Built for applications
    where performance matters.
  </Card>

  <Card title="Dedicated Nodes" icon="server" href="/dedicated-nodes">
    Private infrastructure with no rate limits.
  </Card>
</CardGroup>

## Real-Time Data Streaming

<CardGroup cols={2}>
  <Card title="LaserStream gRPC" icon="bolt" href="/laserstream/grpc">
    Ultra-low latency data streaming built for high-frequency applications.
    Get blockchain data faster than anyone else.
  </Card>

  <Card title="Enhanced WebSockets" icon="wand-sparkles" href="/enhanced-websockets">
    Advanced WebSocket APIs with powerful filtering and granular
    subscription controls.
  </Card>

  <Card title="Standard WebSockets" icon="signal-stream" href="/rpc/websocket">
    Battle-tested WebSocket connections for account and transaction
    monitoring at scale.
  </Card>

  <Card title="Webhooks" icon="webhook" href="/webhooks">
    Custom notifications for on-chain events. Automate your workflows
    and respond to transactions instantly.
  </Card>
</CardGroup>

## Powerful Solana APIs

<CardGroup cols={2}>
  <Card title="Digital Asset Standard (DAS)" icon="hexagon-image" href="/api-reference/das">
    The most comprehensive NFT and token API on Solana. Query, search,
    and manage digital assets with ease.
  </Card>

  <Card title="Priority Fee API" icon="star" href="/priority-fee-api">
    Smart fee estimation that saves you money. Get accurate priority fees
    based on real-time network conditions.
  </Card>

  <Card title="Enhanced Transactions" icon="receipt" href="/enhanced-transactions">
    Rich transaction data with decoded instructions, token transfers,
    and human-readable formats.
  </Card>

  <Card title="ZK Compression" icon="compress" href="/zk-compression/introduction">
    Dramatically reduce storage costs with compressed NFTs and tokens.
    Scale your application without breaking the bank.
  </Card>
</CardGroup>

## Flexible Billing & Enterprise Solutions

<CardGroup cols={3}>
  <Card title="Transparent Pricing" icon="credit-card" href="/billing/plans-and-rate-limits">
    Fair pricing that grows with you. From free tier to enterprise,
    we've got the right plan.
  </Card>

  <Card title="Auto-scaling" icon="scale-balanced" href="/billing/autoscaling">
    Never worry about hitting limits. Automatic scaling ensures your
    application never goes down.
  </Card>

  <Card title="Enterprise Sales" icon="headset" href="https://form.typeform.com/to/KiacmxpZ">
    Building something big? Let's discuss custom solutions and
    enterprise pricing.
  </Card>
</CardGroup>

## Developer Tools & Resources

<CardGroup cols={2}>
  <Card title="ORB Explorer" icon="circle-dashed" href="https://orb.helius.dev">
    The most intuitive Solana blockchain explorer. Visualize transactions,
    accounts, and programs clearly.
  </Card>

  <Card title="Developer Blog" icon="newspaper" href="https://www.helius.dev/blog/?category=development">
    In-depth tutorials and insights from the Helius team. Learn advanced
    Solana development techniques.
  </Card>
</CardGroup>

## Get Support When You Need It

<CardGroup cols={2}>
  <Card title="Developer Community" icon="discord" href="https://discord.com/invite/6GXdee3gBj">
    Join thousands of developers building on Solana. Share knowledge,
    get help, and connect with peers.
  </Card>

  <Card title="Direct Support" icon="headset" href="https://dashboard.helius.dev/support">
    Get help directly from the Helius team. Available to Developer plan
    subscribers and above.
  </Card>
</CardGroup>


# LaserStream
Source: https://www.helius.dev/docs/laserstream

Next-generation Solana data streaming with ultra-low latency, historical replay, and multi-node reliability. Purpose-built for high-performance applications.

<Info>
  **Professional Plan Required**: LaserStream is available for Professional plan subscribers. [Upgrade your plan](https://dashboard.helius.dev/) to access LaserStream's enhanced streaming capabilities.
</Info>

## What is LaserStream?

LaserStream is a next-generation streaming service **purpose-built for developers who need reliable, low-latency Solana data**. It delivers on-chain events (transactions, slots, blocks, accounts, and more) directly to your application with industry-leading reliability, performance, and flexibility. Similar to our gRPC offerings, LaserStream nodes tap directly into Solana leaders to receive shreds as they're produced, delivering ultra-low latency data to your application.

Unlike standard Solana RPC nodes, LaserStream is specifically designed for streaming use cases, offering features not available in conventional node setups:

<CardGroup cols={2}>
  <Card title="Historical Replay" icon="clock-rotate-left">
    Automatically backfill missed data by specifying a starting slot, ensuring data continuity even after disconnections.
  </Card>

  <Card title="Multi-Node Reliability" icon="server">
    Stream from multiple aggregated nodes simultaneously, eliminating single points of failure and ensuring maximum uptime.
  </Card>

  <Card title="High Performance" icon="bolt">
    Purpose-built for streaming with optimized connection handling, reducing latency and improving throughput compared to standard connections.
  </Card>

  <Card title="Protocol Flexibility" icon="shuffle">
    Choose your preferred protocol to match your application's needs and environment requirements.
  </Card>
</CardGroup>

## Easy Migration

<Note>
  **Drop-in Replacement**: LaserStream gRPC is designed as a seamless drop-in replacement for your existing gRPC setup. Simply change your endpoint and API token, and your application will work with LaserStream immediately.
</Note>

### Using Existing gRPC Code

If you already use Yellowstone gRPC, migrating to LaserStream is as simple as:

```typescript
// Before: Using standard Yellowstone gRPC
const connection = new GeyserConnection(
  "your-current-endpoint.com",
  { token: "your-current-token" }
);

// After: Using LaserStream (just change endpoint and token)
const connection = new GeyserConnection(
  "https://laserstream-mainnet-ewr.helius-rpc.com", // Choose your closest region
  { token: "your-helius-api-key" }
);
```

### Enhanced Experience with the LaserStream SDK

While LaserStream works with your existing code, we highly recommend using our [LaserStream SDK](https://github.com/helius-labs/laserstream-sdk) for enhanced capabilities:

```typescript
// Using the dedicated LaserStream SDK
import { subscribe, CommitmentLevel, LaserstreamConfig } from 'helius-laserstream';

const config = {
  apiKey: "your-helius-api-key",
  endpoint: "https://laserstream-mainnet-ewr.helius-rpc.com" // Choose your closest region
};

// The SDK automatically handles:
// - Connection management
// - Reconnection with backoff
// - Historical replay after disconnects
// - Subscription management
await subscribe(config, subscriptionRequest, handleData, handleError);
```

## Key Features

### Automatic Reconnection & Catch-up

The [LaserStream SDK](https://github.com/helius-labs/laserstream-sdk) automatically handles dropped connections, network issues, and data gaps. When a reconnection occurs, the SDK automatically:

* Reconnects with minimal delay
* Re-streams any data that was missed during the downtime
* Continues streaming without intervention

### Multi-Protocol Support

LaserStream is designed with multi-protocol support in mind:

| Protocol      | Status         | Best For                                       | Features                                                              | Implementation                                  |
| ------------- | -------------- | ---------------------------------------------- | --------------------------------------------------------------------- | ----------------------------------------------- |
| **gRPC**      |  Available    | Backend services, high-throughput applications | Highest performance, binary protocol, bi-directional streaming        | Via LaserStream SDK or Yellowstone              |
| **WebSocket** |  Coming soon | Frontend applications, browser clients         | JSON-based, widely supported in browsers, familiar for web developers | Standard WebSocket clients (e.g., `ws` library) |

<Note>
  **WebSocket support is coming soon!** Currently, LaserStream is available only via gRPC. WebSocket integration is under active development and will be available in a future update.
</Note>

### Advanced Filtering

LaserStream supports sophisticated filtering options:

* **Account Filtering**: Include, exclude, or require specific accounts
* **Transaction Types**: Filter by transaction status, vote transactions, etc.
* **Commitment Levels**: Choose from processed, confirmed, or finalized
* **Data Content**: Request specific data fields or full data

### Extreme Scalability

* **Load Balancing**: Connections distributed across multiple nodes
* **Auto-scaling**: Backend resources scale to match demand
* **Efficient Routing**: Requests automatically routed to the most responsive node

## Endpoints & Regions

LaserStream is available in multiple regions worldwide for optimal performance. Choose the endpoint closest to your application's location:

### Mainnet Endpoints

| Region   | Location                        | Endpoint                                          |
| -------- | ------------------------------- | ------------------------------------------------- |
| **ewr**  | New York, US (East Coast)       | `https://laserstream-mainnet-ewr.helius-rpc.com`  |
| **pitt** | Pittsburgh, US (Central)        | `https://laserstream-mainnet-pitt.helius-rpc.com` |
| **slc**  | Salt Lake City, US (West Coast) | `https://laserstream-mainnet-slc.helius-rpc.com`  |
| **ams**  | Amsterdam, Europe               | `https://laserstream-mainnet-ams.helius-rpc.com`  |
| **fra**  | Frankfurt, Europe               | `https://laserstream-mainnet-fra.helius-rpc.com`  |
| **tyo**  | Tokyo, Asia                     | `https://laserstream-mainnet-tyo.helius-rpc.com`  |
| **sgp**  | Singapore, Asia                 | `https://laserstream-mainnet-sgp.helius-rpc.com`  |

### Devnet Endpoint

| Network    | Location                  | Endpoint                                        |
| ---------- | ------------------------- | ----------------------------------------------- |
| **Devnet** | New York, US (East Coast) | `https://laserstream-devnet-ewr.helius-rpc.com` |

<Note>
  **Choosing Your Network & Region**:

  * For **production applications**, use a mainnet endpoint closest to your server location. For example, if your server is in Frankfurt, use `https://laserstream-mainnet-fra.helius-rpc.com`.
  * For **development and testing**, use the devnet endpoint: `https://laserstream-devnet-ewr.helius-rpc.com`.
</Note>

## Authentication & Availability

LaserStream uses your Helius API key for authentication. You can obtain your API key from the [Helius Dashboard](https://dashboard.helius.dev/). Your API key serves as both your authentication token and grants access to LaserStream's enhanced features.

<Note>
  **Plan Requirement**: LaserStream is available for **Professional plan** subscribers (\$999/month). Professional plan users pay 3 credits per 0.1MB for all LaserStream usage. You can upgrade your plan in the [Helius Dashboard](https://dashboard.helius.dev/).
</Note>

### Need High-Volume Streaming? LaserStream Plus Add-On

If you're building applications that consume massive amounts of real-time Solana data, the LaserStream Plus add-on transforms your costs:

<CardGroup cols={1}>
  <Card title="From Pay-Per-Use to 50 TB Included" icon="chart-line">
    **Professional Plan**: Pay 3 credits per 0.1MB from first byte\
    **LaserStream Plus**: Get 50 TB included monthly, then only 1 credit per 0.1MB

    **\$2,500/month** - Perfect for trading bots, real-time analytics, and portfolio trackers processing continuous market data.
  </Card>
</CardGroup>

**When to consider LaserStream Plus:**

* Your app processes full market data streams (all DEX trades, NFT sales, etc.)
* You're building high-frequency trading systems
* You need 24/7 account monitoring across thousands of wallets

## Getting Started

<Card title="gRPC" icon="bolt" href="/laserstream/grpc">
  High-performance streaming optimized for backend services and high-throughput applications
</Card>

For applications that need to catch up on historical data or implement fault-tolerant connections:

<Card title="Historical Replay" icon="clock-rotate-left" href="/laserstream/historical-replay">
  Learn how to implement historical replay to ensure data continuity
</Card>

## When to Use LaserStream vs. Other Solana Streaming Options

| Feature                 | LaserStream                             | Standard Solana WebSocket | Yellowstone gRPC        |
| ----------------------- | --------------------------------------- | ------------------------- | ----------------------- |
| **Historical replay**   |  Up to 3000 slots (approx. 20 minutes) |  Not available           |  Limited               |
| **Auto-reconnect**      |  Built-in with SDK                     |  Manual implementation   |  Manual implementation |
| **Multi-node failover** |  Automatic                             |  Manual implementation   |  Manual implementation |
| **gRPC support**        |  Enhanced                              |  Not available           |  Standard              |
| **Shredstream enabled** |  Yes                                   |  No                      |  Manual                |

## Next Steps

For more information, join the discussion on our [Discord](https://discord.com/invite/6GXdee3gBj) or [Telegram](https://t.me/helius_help).

## Attribution

LaserStream is a custom fork of [Richat](https://github.com/lamports-dev/richat) project.


# LaserStream Clients
Source: https://www.helius.dev/docs/laserstream/clients

High-performance SDK for gRPC streaming with automatic replay and zero data loss

## Automatic Replay on Disconnect

LaserStream clients continuously track your streaming position by slot number. If a disconnection occurs - from network issues, server maintenance, or any other cause - the client automatically reconnects and resumes streaming from your last processed slot. You never lose data, never miss transactions, and never need to write reconnection logic.

## JavaScript/TypeScript Client

The [JavaScript client](https://github.com/helius-labs/laserstream-sdk/tree/main/javascript) uses native Rust bindings to achieve 1.3GB/s throughput  over 40x faster than Yellowstone gRPC JavaScript clients that max out at 30MB/s.

<Warning>
  As Solana continues to scale, Yellowstone JavaScript client will struggle to keep up. If Solana speeds up 3x, Yellowstone gRPC clients subscribing to all transactions or blocks will fail to match chain speed. LaserSstream client's performance headroom ensures your application scales with the network.
</Warning>

On high-bandwidth subscriptions, Yellowstone clients experience progressive delays that compound over time. LaserStream maintains consistent, low-latency streaming regardless of data volume.

### Installation

<CodeGroup>
  ```bash npm
  npm install helius-laserstream
  ```

  ```bash yarn
  yarn add helius-laserstream
  ```

  ```bash pnpm
  pnpm add helius-laserstream
  ```
</CodeGroup>

### Quick Start

```typescript [expandable]
import { subscribe, CommitmentLevel, LaserstreamConfig, SubscribeRequest } from 'helius-laserstream';

async function streamTransactions() {
  const config: LaserstreamConfig = {
    apiKey: 'YOUR_API_KEY',
    endpoint: 'https://laserstream-mainnet-ewr.helius-rpc.com',
  };

  const request: SubscribeRequest = {
    transactions: {
      client: {
        accountInclude: ['JUP6LkbZbjS1jKKwapdHNy74zcZ3tLUZoi5QNyVTaV4'], // Jupiter Program
        accountExclude: [],
        accountRequired: [],
        vote: false,
        failed: false
      }
    },
    commitment: CommitmentLevel.CONFIRMED,
    accounts: {},
    slots: {},
    transactionsStatus: {},
    blocks: {},
    blocksMeta: {},
    entry: {},
    accountsDataSlice: []
  };

  // The SDK handles reconnection and replay automatically
  await subscribe(config, request, 
    async (data) => {
      console.log('New transaction:', data);
    }, 
    async (error) => {
      console.error('Error:', error);
    }
  );
}

streamTransactions().catch(console.error);
```

### Reliability Comparison

| Feature              | LaserStream | Yellowstone                      |
| -------------------- | ----------- | -------------------------------- |
| Automatic Replay     |  Built-in  |  Manual implementation required |
| Progressive Delays   |  None      |  On high bandwidth              |
| Data Loss Protection |  Automatic |  Application responsibility     |
| Reconnection         |  Seamless  |  No built-in support            |

## Rust Client

The [Rust client](https://github.com/helius-labs/laserstream-sdk/tree/main/rust) provides zero-copy deserialization and native performance for applications requiring maximum control.

### Installation

```toml
[dependencies]
helius-laserstream = "0.1"
tokio = { version = "1", features = ["full"] }
```

### Quick Start

```rust [expandable]
use helius_laserstream::{subscribe, CommitmentLevel, LaserstreamConfig, SubscribeRequest};
use futures::StreamExt;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let config = LaserstreamConfig {
        api_key: "YOUR_API_KEY".to_string(),
        endpoint: "https://laserstream-mainnet-ewr.helius-rpc.com".to_string(),
    };

    let request = SubscribeRequest {
        transactions: Some(TransactionsFilter {
            client: Some(TransactionFilter {
                account_include: vec!["JUP6LkbZbjS1jKKwapdHNy74zcZ3tLUZoi5QNyVTaV4".to_string()],
                vote: false,
                failed: false,
                ..Default::default()
            }),
        }),
        commitment: CommitmentLevel::Confirmed,
        ..Default::default()
    };

    let mut stream = subscribe(config, request).await?;

    while let Some(result) = stream.next().await {
        match result {
            Ok(data) => println!("New transaction: {:?}", data),
            Err(e) => eprintln!("Error: {:?}", e),
        }
    }

    Ok(())
}
```

## Go Client

The [Go client](https://github.com/helius-labs/laserstream-sdk/tree/main/go) provides idiomatic Go interfaces.

### Installation

```bash
go get github.com/helius-labs/laserstream-sdk/go
```

### Quick Start

```go [expandable]
package main

import (
    "context"
    "fmt"
    "log"
    
    laserstream "github.com/helius-labs/laserstream-sdk/go"
)

func main() {
    config := &laserstream.Config{
        APIKey:   "YOUR_API_KEY",
        Endpoint: "https://laserstream-mainnet-ewr.helius-rpc.com",
    }

    request := &laserstream.SubscribeRequest{
        Transactions: &laserstream.TransactionsFilter{
            Client: &laserstream.TransactionFilter{
                AccountInclude: []string{"JUP6LkbZbjS1jKKwapdHNy74zcZ3tLUZoi5QNyVTaV4"},
                Vote:          false,
                Failed:        false,
            },
        },
        Commitment: laserstream.CommitmentConfirmed,
    }

    ctx := context.Background()
    stream, err := laserstream.Subscribe(ctx, config, request)
    if err != nil {
        log.Fatal(err)
    }

    for data := range stream {
        if data.Error != nil {
            log.Printf("Error: %v", data.Error)
            continue
        }
        fmt.Printf("New transaction: %+v\n", data)
    }
}
```

## Why Migrate from Yellowstone to LaserStream

Yellowstone clients face critical limitations that will only worsen as Solana scales:

1. **Performance Bottleneck**: Yellowstone JavaScript clients max out at 30MB/s  insufficient for high-throughput applications
2. **Progressive Delays**: Latency compounds over time on high-bandwidth subscriptions
3. **Manual Replay**: You must implement your own reconnection and replay logic
4. **Data Loss Risk**: Without built-in replay, network disruptions mean missed transactions

**LaserStream solves these problems today**. With 40x better performance, automatic replay, and zero data loss guarantees, migrating to LaserStream ensures your application remains competitive as Solana evolves.


# LaserStream gRPC: High-Performance Data Streaming
Source: https://www.helius.dev/docs/laserstream/grpc

Stream real-time Solana blockchain data with LaserStream gRPC. Highly configurable low-latency streams with historical replay and multi-region support.

## Overview

LaserStream's gRPC offering builds on a Yellowstone-based interface and enhances it with features like historical replay, multi-node failover, and a fully managed environment. LaserStream uses the open source gRPC protocol, ensuring no vendor lock-in and maximum compatibility with existing gRPC implementations.

You can connect either directly with `@yellowstone-grpc` or use the higher-level **[Helius LaserStream SDK](https://github.com/helius-labs/laserstream-sdk)** for added benefits (auto-reconnect, subscription management, error handling, etc.).

<Warning>
  **Performance Notice**: If you experience any lag or performance issues with your LaserStream connection, please refer to the [Troubleshooting section](#troubleshooting-%2F-faq) for common causes and solutions related to client performance and network optimization.
</Warning>

<Divider />

## Endpoints & Regions

LaserStream is available in multiple regions worldwide. Choose the endpoint closest to your application for optimal performance:

### Mainnet Endpoints

| Region   | Location                        | Endpoint                                          |
| -------- | ------------------------------- | ------------------------------------------------- |
| **ewr**  | New York, US (East Coast)       | `https://laserstream-mainnet-ewr.helius-rpc.com`  |
| **pitt** | Pittsburgh, US (Central)        | `https://laserstream-mainnet-pitt.helius-rpc.com` |
| **slc**  | Salt Lake City, US (West Coast) | `https://laserstream-mainnet-slc.helius-rpc.com`  |
| **ams**  | Amsterdam, Europe               | `https://laserstream-mainnet-ams.helius-rpc.com`  |
| **fra**  | Frankfurt, Europe               | `https://laserstream-mainnet-fra.helius-rpc.com`  |
| **tyo**  | Tokyo, Asia                     | `https://laserstream-mainnet-tyo.helius-rpc.com`  |
| **sgp**  | Singapore, Asia                 | `https://laserstream-mainnet-sgp.helius-rpc.com`  |

### Devnet Endpoint

| Network    | Location                  | Endpoint                                        |
| ---------- | ------------------------- | ----------------------------------------------- |
| **Devnet** | New York, US (East Coast) | `https://laserstream-devnet-ewr.helius-rpc.com` |

<Tip>
  **Network & Region Selection**:

  * For **production applications**, choose the mainnet endpoint closest to your server for best performance. For example, if deploying in Europe, use either the Amsterdam (`ams`) or Frankfurt (`fra`) endpoint.
  * For **development and testing**, use the devnet endpoint: `https://laserstream-devnet-ewr.helius-rpc.com`.
</Tip>

## Quickstart

<Steps>
  <Step title="Create a New Project">
    ```bash
    mkdir laserstream-grpc-demo
    cd laserstream-grpc-demo
    npm init -y
    ```
  </Step>

  <Step title="Install Dependencies">
    ```bash
    npm install helius-laserstream
    npm install --save-dev typescript ts-node
    npx tsc --init
    ```
  </Step>

  <Step title="Obtain Your API Key">
    Generate a key from the [Helius Dashboard](https://dashboard.helius.dev/). This key will serve as your authentication token for LaserStream.

    <Note>
      **Professional Plan Required**: LaserStream requires a Professional plan. Ensure your Helius account is upgraded to access LaserStream features.
    </Note>
  </Step>

  <Step title="Create a Subscription Script">
    Create **`index.ts`** with the following:

    ```typescript
    import { subscribe, CommitmentLevel, LaserstreamConfig, SubscribeRequest } from 'helius-laserstream'

    async function main() {
      const subscriptionRequest: SubscribeRequest = {
        transactions: {
          client: {
            accountInclude: ['TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'],
            accountExclude: [],
            accountRequired: [],
            vote: false,
            failed: false
          }
        },
        commitment: CommitmentLevel.CONFIRMED,
        accounts: {},
        slots: {},
        transactionsStatus: {},
        blocks: {},
        blocksMeta: {},
        entry: {},
        accountsDataSlice: [],
        // Optionally, you can replay missed data by specifying a fromSlot:
        // fromSlot: '224339000'
        // Note: Currently, you can only replay data from up to 3000 slots in the past.
      };

    // Replace the values below with your actual LaserStream API key and endpoint
    const config: LaserstreamConfig = {
      apiKey: 'YOUR_API_KEY', // Replace with your key from https://dashboard.helius.dev/
      endpoint: 'https://laserstream-mainnet-ewr.helius-rpc.com', // Choose your closest region
    }

      await subscribe(config, subscriptionRequest, async (data) => {
        
        console.log(data);

      }, async (error) => {
        console.error(error);
      });
    }

    main().catch(console.error);
    ```
  </Step>

  <Step title="Replace Your API Key and Choose Your Region">
    In `index.ts`, update the `config` object with:

    1. Your actual API key from the [Helius Dashboard](https://dashboard.helius.dev/)
    2. The LaserStream endpoint closest to your server location

    ```typescript
    const config: LaserstreamConfig = {
      apiKey: 'YOUR_ACTUAL_API_KEY', // Replace with your key from Helius Dashboard
      endpoint: 'https://laserstream-mainnet-fra.helius-rpc.com', // Example: Frankfurt mainnet
      // For devnet: endpoint: 'https://laserstream-devnet-ewr.helius-rpc.com'
    }
    ```

    **Network & Region Selection Examples:**

    * **For Production (Mainnet)**:
      * Europe: Use `fra` (Frankfurt) or `ams` (Amsterdam)
      * US East: Use `ewr` (New York)
      * US West: Use `slc` (Salt Lake City)
      * Asia: Use `tyo` (Tokyo) or `sgp` (Singapore)
    * **For Development (Devnet)**: Use `https://laserstream-devnet-ewr.helius-rpc.com`
  </Step>

  <Step title="Run and View Results">
    ```bash
    npx ts-node index.ts
    ```

    Whenever a `confirmed` token transaction involves `TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA`, you'll see the data in your console.
  </Step>
</Steps>

<Divider />

## Subscribe Request

In the subscribe request, you need to include the following general parameters:

<Note>
  **Historical Replay:** You can optionally include a `fromSlot: string` field in the main `SubscribeRequest` object to replay data from a specific slot onwards. Currently, replay is supported for up to 3000 slots in the past.
</Note>

<ParamField type="enum">
  Specifies the commitment level, which can be **processed**, **confirmed**, or **finalized**.
</ParamField>

<ParamField type="array">
  An array of objects `{ offset: uint64, length: uint64 }` that allows you to receive only the required data slices from accounts.
</ParamField>

<ParamField type="boolean">
  Some cloud providers (like Cloudflare) may close idle streams after a period of inactivity. To prevent this and keep the connection alive without needing to resend filters, set this to **true**. The server will respond with a Pong message every 15 seconds.
</ParamField>

```typescript
const subscriptionRequest: SubscribeRequest = {
  commitment: CommitmentLevel.CONFIRMED,
  accountsDataSlice: [],
  transactions: {},
  accounts: {},
  slots: {},
  blocks: {},
  blocksMeta: {},
  entry: {},
}
```

Next, you'll need to specify the filters for the data you want to subscribe to, such as accounts, blocks, slots, or transactions.

<Accordion title="Slots">
  Define filters for slot updates. The key you use (e.g., `mySlotLabel`) is a **user-defined label** for this specific filter configuration, allowing you to potentially define multiple named configurations if needed (though typically one is sufficient).

  <ParamField type="boolean">
    By default, slots are sent for all commitment levels. With this filter, you can choose to receive only the selected commitment level.
  </ParamField>

  <ParamField type="boolean">
    Enables the subscription to receive updates for changes within a slot, not just at the beginning of new slots. This is useful for more granular, low-latency slot data.
  </ParamField>

  ```typescript
  slots: {
    // mySlotLabel is a user-defined name for this slot update filter configuration
    mySlotLabel: {
      // filterByCommitment: true => Only broadcast slot updates at the specified subscribeRequest commitment
      filterByCommitment: true
      // interslotUpdates: true allows receiving updates for changes occurring within a slot, not just new slots.
      interslotUpdates: true
    }
  },
  ```
</Accordion>

<Accordion title="Accounts">
  Define filters for account data updates. The key you use (e.g., `tokenAccounts`) is a **user-defined label** for this specific filter configuration.

  <ParamField type="array">
    Matches any public key from the provided array.
  </ParamField>

  <ParamField type="array">
    The account owner's public key. Matches any public key from the provided array.
  </ParamField>

  <ParamField type="array">
    Similar to the filters in [getProgramAccounts](https://solana.com/docs/rpc/http/getprogramaccounts). This is an array of `dataSize` and/or `memcmp` filters. Supported encoding includes `bytes`, `base58`, and `base64`.
  </ParamField>

  If all fields are empty, all accounts are broadcasted. Otherwise:

  * Fields operate as a logical **AND**.
  * Values within arrays act as a logical **OR** (except within `filters`, which operate as a logical **AND**).

  ```typescript
  accounts: {
    // tokenAccounts is a user-defined label for this account filter configuration
    tokenAccounts: {
      // Matches any of these public keys (logical OR)
      account: ["9SHQTA66Ekh7ZgMnKWsjxXk6DwXku8przs45E8bcEe38"],
      // Matches owners that are any of these public keys
      owner: ["TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"],
      // Filters - all must match (AND logic)
      filters: [
        { dataSize: 165 },
        {
          memcmp: {
            offset: 0,
            data: { base58: "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v" }
          }
        }
      ]
    }
  },
  ```
</Accordion>

<Accordion title="Transaction">
  Define filters for transaction updates. The key you use (e.g., `myTxSubscription`) is a **user-defined label** for this specific filter configuration.

  <ParamField type="boolean">
    Enable or disable the broadcast of vote transactions.
  </ParamField>

  <ParamField type="boolean">
    Enable or disable the broadcast of failed transactions.
  </ParamField>

  <ParamField type="string">
    Broadcast only transactions matching the specified signature.
  </ParamField>

  <ParamField type="array">
    Filter transactions that involve any account from the provided list.
  </ParamField>

  <ParamField type="array">
    Exclude transactions that involve any account from the provided list (opposite of `accountInclude`).
  </ParamField>

  <ParamField type="array">
    Filter transactions that involve all accounts from the provided list (all accounts must be used).
  </ParamField>

  If all fields are left empty, all transactions are broadcasted. Otherwise:

  * Fields operate as a logical **AND**.
  * Values within arrays are treated as a logical **OR** (except for `accountRequired`, where all must match).

  ```typescript
  transactions: {
    // myTxSubscription is a user-defined label for this transaction filter configuration
    myTxSubscription: {
      vote: false,
      failed: false,
      signature: "",
      // Transaction must include at least one of these public keys (OR)
      accountInclude: ["86xCnPeV69n6t3DnyGvkKobf9FdN2H9oiVDdaMpo2MMY"],
      // Exclude if it matches any of these
      accountExclude: [],
      // Require all accounts in this array (AND)
      accountRequired: []
    }
  },
  ```
</Accordion>

<Accordion title="Block">
  Define filters for block updates. The key you use (e.g., `myBlockLabel`) is a **user-defined label** for this specific filter configuration.

  <ParamField type="array">
    Filters transactions and accounts that involve any account from the provided list.
  </ParamField>

  <ParamField type="boolean">
    Includes all transactions in the broadcast.
  </ParamField>

  <ParamField type="boolean">
    Includes all account updates in the broadcast.
  </ParamField>

  <ParamField type="boolean">
    Includes all entries in the broadcast.
  </ParamField>

  ```typescript
  blocks: {
    // myBlockLabel is a user-defined label for this block filter configuration
    myBlockLabel: {
      // Only broadcast blocks referencing these accounts
      accountInclude: ["86xCnPeV69n6t3DnyGvkKobf9FdN2H9oiVDdaMpo2MMY"],
      includeTransactions: true,
      includeAccounts: false,
      includeEntries: false
    }
  },
  ```
</Accordion>

<Accordion title="Blocks Meta">
  This functions similarly to Blocks but excludes transactions, accounts, and entries. The key you use (e.g., `blockmetadata`) is a **user-defined label** for this subscription. Currently, no filters are available for block metadataall messages are broadcasted by default.

  ```typescript
  blocksMeta: {
    blockmetadata: {}
  },
  ```
</Accordion>

<Accordion title="Entries">
  Subscribe to ledger entries. The key you use (e.g., `entrySubscribe`) is a **user-defined label** for this subscription. Currently, there are no filters available for entries; all entries are broadcasted.

  ```typescript
  entry: {
    entrySubscribe: {}
  },
  ```
</Accordion>

<Divider />

## Code Examples (LaserStream SDK)

<Tabs>
  <Tab title="Slot Updates">
    ```typescript
    import { subscribe, CommitmentLevel, LaserstreamConfig, SubscribeRequest } from 'helius-laserstream'

    async function main() {
        const subscriptionRequest: SubscribeRequest = {
            transactions: {},
            commitment: CommitmentLevel.CONFIRMED,
            accounts: {},
            slots: {
                slot: { filterByCommitment: true },
            },
            transactionsStatus: {},
            blocks: {},
            blocksMeta: {},
            entry: {},
            accountsDataSlice: [],
        };

        const config: LaserstreamConfig = {
            apiKey: 'YOUR_API_KEY', // Replace with your key
            endpoint: 'https://laserstream-mainnet-ewr.helius-rpc.com', // Choose your closest region
        }

        await subscribe(config, subscriptionRequest, async (data) => {
            console.log(data);
        }, async (error) => {
            console.error(error);
        });
    }

    main().catch(console.error);
    ```
  </Tab>

  <Tab title="Account Updates">
    ```typescript
    import { subscribe, CommitmentLevel, LaserstreamConfig, SubscribeRequest } from 'helius-laserstream'

    async function main() {
        const subscriptionRequest: SubscribeRequest = {
            accounts: {
                accountSubscribe: {
                    account: ["EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"], // USDC mint account
                    owner: [],
                    filters: []
                }
            },
            accountsDataSlice: [],
            commitment: CommitmentLevel.CONFIRMED,
            slots: {},
            transactions: {},
            transactionsStatus: {},
            blocks: {},
            blocksMeta: {},
            entry: {}
        };

        const config: LaserstreamConfig = {
            apiKey: 'YOUR_API_KEY', // Replace with your key
            endpoint: 'https://laserstream-mainnet-ewr.helius-rpc.com', // Choose your closest region
        }

        await subscribe(config, subscriptionRequest, async (data) => {
            console.log(data);
        }, async (error) => {
            console.error(error);
        });
    }

    main().catch(console.error);
    ```
  </Tab>

  <Tab title="Transaction Updates">
    ```typescript
    import { subscribe, CommitmentLevel, LaserstreamConfig, SubscribeRequest } from 'helius-laserstream'

    async function main() {
        const subscriptionRequest: SubscribeRequest = {
            transactions: {
                client: {
                    accountInclude: ['TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'],
                    accountExclude: [],
                    accountRequired: [],
                    vote: false,
                    failed: false
                }
            },
            commitment: CommitmentLevel.CONFIRMED,
            accounts: {},
            slots: {},
            transactionsStatus: {},
            blocks: {},
            blocksMeta: {},
            entry: {},
            accountsDataSlice: [],
        };

        const config: LaserstreamConfig = {
            apiKey: 'YOUR_API_KEY', // Replace with your key
            endpoint: 'https://laserstream-mainnet-ewr.helius-rpc.com', // Choose your closest region
        }

        await subscribe(config, subscriptionRequest, async (data) => {
            console.log(data);
        }, async (error) => {
            console.error(error);
        });
    }

    main().catch(console.error);
    ```
  </Tab>

  <Tab title="Blocks">
    ```typescript
    import { subscribe, CommitmentLevel, LaserstreamConfig, SubscribeRequest } from 'helius-laserstream'

    async function main() {
        const subscriptionRequest: SubscribeRequest = {
            entry: {},
            accounts: {},
            accountsDataSlice: [],
            slots: {},
            blocks: {
                blocks: {
                    accountInclude: []
                }
            },
            blocksMeta: {},
            transactions: {},
            transactionsStatus: {},
            commitment: CommitmentLevel.CONFIRMED,
        };

        const config: LaserstreamConfig = {
            apiKey: 'YOUR_API_KEY', // Replace with your key
            endpoint: 'https://laserstream-mainnet-ewr.helius-rpc.com', // Choose your closest region
        }

        await subscribe(config, subscriptionRequest, async (data) => {
            console.log(data);
        }, async (error) => {
            console.error(error);
        });
    }

    main().catch(console.error);
    ```
  </Tab>

  <Tab title="Block Metadata">
    ```typescript
    import { subscribe, CommitmentLevel, LaserstreamConfig, SubscribeRequest } from 'helius-laserstream'

    async function main() {
        const subscriptionRequest: SubscribeRequest = {
            entry: {},
            accounts: {},
            accountsDataSlice: [],
            slots: {},
            blocks: {},
            blocksMeta: {
                blockmetadata: {}
            },
            transactions: {},
            transactionsStatus: {},
            commitment: CommitmentLevel.CONFIRMED,
        };

        const config: LaserstreamConfig = {
            apiKey: 'YOUR_API_KEY', // Replace with your key
            endpoint: 'https://laserstream-mainnet-ewr.helius-rpc.com', // Choose your closest region
        }

        await subscribe(config, subscriptionRequest, async (data) => {
            console.log(data);
        }, async (error) => {
            console.error(error);
        });
    }

    main().catch(console.error);
    ```
  </Tab>

  <Tab title="Entries">
    ```typescript
    import { subscribe, CommitmentLevel, LaserstreamConfig, SubscribeRequest } from 'helius-laserstream'

    async function main() {
        const subscriptionRequest: SubscribeRequest = {
            entry: {
                entrySubscribe: {}  // Subscribe to all entries
            },
            accounts: {},
            accountsDataSlice: [],
            slots: {},
            blocks: {},
            blocksMeta: {},
            transactions: {},
            transactionsStatus: {},
            commitment: CommitmentLevel.CONFIRMED,
        };

        const config: LaserstreamConfig = {
            apiKey: 'YOUR_API_KEY', // Replace with your key
            endpoint: 'https://laserstream-mainnet-ewr.helius-rpc.com', // Choose your closest region
        }

        await subscribe(config, subscriptionRequest, async (data) => {
            console.log(data);
        }, async (error) => {
            console.error(error);
        });
    }

    main().catch(console.error);
    ```
  </Tab>
</Tabs>

<Divider />

## SDK Options

We provide official SDKs for multiple programming languages:

* **TypeScript**: [LaserStream TypeScript SDK](https://github.com/helius-labs/laserstream-sdk)
* **Rust**: [LaserStream Rust SDK](https://github.com/helius-labs/laserstream-sdk/tree/main/rust)
* **Go**: [LaserStream Go SDK](https://github.com/helius-labs/laserstream-sdk/tree/main/go)

For other languages or custom implementations, you can use the [Yellowstone gRPC proto files](https://github.com/rpcpool/yellowstone-grpc/tree/v6.0.0%2Bsolana.2.2.12/yellowstone-grpc-proto/proto) directly to generate gRPC clients for your preferred language.

<Divider />

## Troubleshooting / FAQ

<Accordion title="Q: I'm experiencing lag or slow performance with my LaserStream connection. What could be causing this?">
  **A:** Performance issues with LaserStream connections are typically caused by:

  * **Javascript Client Slowness**: The JavaScript client may lag behind when processing too many messages or consuming too much bandwidth. Consider filtering your subscriptions more narrowly to reduce message volume or using another language.

  * **Limited local bandwidth**: Heavy subscriptions can overwhelm clients with limited network bandwidth. Monitor your network usage and consider upgrading your connection or reducing subscription scope.

  * **Geographic distance**: Running subscriptions against servers that are geographically far away can cause performance issues. TCP packets may get dropped on long routes, and you're limited by the slowest intermediate network path. **Solution**: Choose the LaserStream endpoint closest to your server location from our available regions (see [Endpoints & Regions](#mainnet-endpoints) above).

  * **Client-side processing bottlenecks**: Ensure your message processing logic is optimized and doesn't block the main thread for extended periods.

  **Debugging Client Lag**: To help you debug client, we built a tool to test for the max bandwidth from your node to a Laserstream gRPC server. To use it run:

  ```
  cargo install helius-laserstream-bandwidth
  helius-laserstream-bandwidth --laserstream-url $LASERSTREAM_URL --api-key $API_KEY
  ```

  The output returns the max network capacity between your server and the Laserstream server. At a minimum, you need 10MB/s to subscribe to all transaction data and 80MB/s to subscribe to all account data. We recommend having at least 2x the required capacity for optimal performance.
</Accordion>

<Accordion title="Q: I'm getting connection errors. What should I check?">
  **A:** Verify your API key and endpoint are correct and that your network allows outbound gRPC connections to the specified endpoint. Check the [Helius status page](https://helius.statuspage.io/) for any ongoing incidents.
</Accordion>

<Accordion title="Q: Why aren't my filters working as expected?">
  **A:** Double-check the logical operators (AND/OR) described in the filter sections. Ensure public keys are correct. Review the commitment level specified in your request.
</Accordion>

<Accordion title="Q: Can I subscribe to multiple types of data (e.g., accounts and transactions) in one request?">
  **A:** Yes, you can define filter configurations under multiple keys (e.g., `accounts`, `transactions`) within the same `SubscribeRequest` object.
</Accordion>


# Account Subscription and Updates
Source: https://www.helius.dev/docs/laserstream/guides/account-subscription

Learn how to subscribe to account updates and efficiently track on-chain state changes using Laserstream.

When building applications that need to respond to on-chain changes, polling RPC endpoints for account updates is both inefficient and slow. Account subscriptions solve this by delivering real-time updates about account state changes directly to your application.

This guide covers everything you need to know about account subscriptions: what they are, how they work, and how to optimize them for your specific use case.

***

## The account model context

<Info>
  Skip this section if you're familiar with Solana accounts and their structure.
</Info>

Solana uses an account-based model where every piece of data lives in an account - a container that holds both data and metadata. Each account has:

* **Data**: The actual bytes storing program state, token balances, or other information
* **Owner**: The program that controls this account and can modify its data
* **Lamports**: The account's SOL balance for rent exemption
* **Executable**: Whether this account contains program code

Programs are stateless - they don't store data internally. Instead, they create and manage separate accounts to store their state. When you interact with a program, you pass in the accounts it should read from or write to.

This design makes account subscriptions powerful: you can watch for changes to specific accounts, all accounts owned by a program, or accounts matching certain criteria.

***

## Basic account subscription

Let's start with a simple example that subscribes to changes in token accounts. This script will notify you whenever token balances change:

```ts [expandable]
import { subscribe, CommitmentLevel, SubscribeUpdate, LaserstreamConfig } from 'helius-laserstream';
import * as bs58 from 'bs58';

// Utility function to recursively convert Buffer objects to base58 strings
function convertBuffersToBase58(obj: any): any {
  if (obj === null || obj === undefined) {
    return obj;
  }
  
  if (Buffer.isBuffer(obj)) {
    return bs58.encode(obj);
  }
  
  if (Array.isArray(obj)) {
    return obj.map(convertBuffersToBase58);
  }
  
  if (typeof obj === 'object') {
    const result: any = {};
    for (const key in obj) {
      if (obj.hasOwnProperty(key)) {
        result[key] = convertBuffersToBase58(obj[key]);
      }
    }
    return result;
  }
  
  return obj;
}

async function main() {
  console.log(' Basic Account Subscription Example');

  const config: LaserstreamConfig = {
    apiKey: 'your-api-key',
    endpoint: 'laserstream-url',
  };

  const request = {
    accounts: {
      "token-accounts": {
        account: [], // Specific account pubkeys (empty = all)
        owner: ["TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"], // Token program
        filters: [
          {
            // Only token accounts (165 bytes)
            datasize: 165
          }
        ]
      }
    },
    commitment: CommitmentLevel.CONFIRMED,
    transactions: {}, slots: {}, transactionsStatus: {}, blocks: {}, blocksMeta: {}, entry: {}, accountsDataSlice: []
  };

  const stream = await subscribe(
    config,
    request,
    async (update: SubscribeUpdate) => {
      const readableUpdate = convertBuffersToBase58(update);
      console.log(' Account Update:', JSON.stringify(readableUpdate, null, 2));
    },
    async (err) => console.error(' Stream error:', err)
  );

  console.log(` Account subscription started (id: ${stream.id})`);

  process.on('SIGINT', () => {
    console.log('\n Cancelling stream...');
    stream.cancel();
    process.exit(0);
  });
}

main().catch(console.error);
```

When you run this basic subscription, you'll see real-time account updates streaming to your console:

```
 Basic Account Subscription Example
 Account subscription started (id: xyz789)

 Account Update: {
  "filters": ["token-accounts"],
  "account": {
    "account": {
      "pubkey": "BKMHWYLAX4un3HUbR7a3u9jPmzCiLNa4mSj1RiX11eWF",
      "lamports": "2039280",
      "owner": "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA",
      "rentEpoch": "18446744073709551615",
      "data": "2NUx6Xw9QkmgJCyYUP3d8TPsjJhUpSM7hcy9Fi1juGc6g9DrpPFyGyvBZzu9qiAjFtyEDbNiLHYFJsq1dD5Wxr4LPcF9Dqs4AJa15L1N92pfinnoKVfCsVCcybhV1iwkCCTMeMyxTRA4tqJm6MrLwgKG3HmmwVdhsEuXjSsGJFXGzgfgPHucVzBEgAqcpH9JPpoaQyis2MFwRJLjenxzkE8xJzWHv1Zk2T",
      "writeVersion": "2697618495",
      "txnSignature": "5C9Hr5nG2j8eQz6inxPmfyjbYdmXddzUDyR1iQgEnjYQ3RNvuP4Zzc8t1enLNy7Rk8KNCtQPEQztENYWxkt9GaVD"
    },
    "slot": "352366983"
  },
  "createdAt": "2025-07-10T11:56:22.027Z"
}
```

**What just happened?** Our subscription worked perfectly! We asked Laserstream to notify us about token account changes, and it delivered an update about account `BKMHWYLAX4un3HUbR7a3u9jPmzCiLNa4mSj1RiX11eWF`.

This account has:

* **2,039,280 lamports** (\~0.002 SOL balance - this is the rent-exempt amount for this token account)
* **Owner program** `TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA` (this is the SPL Token program)
* **Transaction signature** `5C9Hr5nG2j8eQz6inxPmfyjbYdmXddzUDyR1iQgEnjYQ3RNvuP4Zzc8t1enLNy7Rk8KNCtQPEQztENYWxkt9GaVD` showing which specific transaction caused this account to change
* **Slot 352366983** indicating when this update occurred on the blockchain
* **Data field** containing 165 bytes of account data encoded as base58

### Understanding account filtering with datasize

The data field is crucial - it contains the actual token account structure. Let's use this understanding for **smart account filtering**.

#### Why use datasize filtering?

To understand why we need filtering, let's first understand what token accounts actually are. **For every token a wallet holds, there's a separate account on-chain.** If your wallet holds 3 different tokens (USDC, BONK, and SOL), you actually have 1 wallet account (your main SOL account) plus 3 token accounts (one for each token type). Each token account is exactly 165 bytes and stores: which token it holds (mint address), who owns it (your wallet address), and how much of that token it contains (amount).

The Token Program owns **millions of accounts** on Solana, but not all of them are what we think of as "token accounts" holding user balances. Here's what happens with and without filtering:

**Without filtering - The flood:**

```ts
accounts: {
  "all-token-program-accounts": {
    owner: ["TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"] //  Overwhelming!
  }
}
```

This subscribes to ALL accounts owned by the Token Program, which includes:

* **Token accounts** (165 bytes) - User balances: millions of accounts
* **Mint accounts** (82 bytes) - Token definitions: hundreds of thousands of accounts
* **Multisig accounts** (355 bytes) - Shared wallet controls: tens of thousands of accounts
* **Associated Token Program accounts** (various sizes) - millions of accounts

<Warning>
  **Result:** Your application receives millions of account updates constantly, most of which you don't care about.
</Warning>

**With smart filtering - Surgical precision:**

```ts
accounts: {
  "token-accounts-only": {
    owner: ["TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"],
    filters: [{ datasize: 165 }] //  Only standard token accounts
  }
}
```

This filters down to only the 165-byte accounts, which are specifically the user token balance accounts - exactly what you want for tracking token transfers, balance changes, and portfolio updates.

**The difference:**

* **Without filtering:** Millions of account updates (mint creations, multisig changes, etc.)
* **With datasize filtering:** Only token balance changes

That's a significant reduction in noise, focusing only on the accounts that actually represent user token holdings.

#### Where does 165 bytes come from?

This isn't magic - it comes from the [SPL Token program's account structure](https://github.com/solana-program/token/blob/d05d10807fe8cf157f6e1f024c708274c30c953a/program/src/state.rs#L87). Looking at the source code, we can see the `Account` struct defines exactly 165 bytes:

```rust
pub struct Account {
    pub mint: Pubkey,                    // 32 bytes
    pub owner: Pubkey,                   // 32 bytes  
    pub amount: u64,                     // 8 bytes
    pub delegate: COption<Pubkey>,       // 4 + 32 bytes
    pub state: AccountState,             // 1 byte
    pub is_native: COption<u64>,         // 4 + 8 bytes
    pub delegated_amount: u64,           // 8 bytes
    pub close_authority: COption<Pubkey> // 4 + 32 bytes
}
// Total: 32+32+8+36+1+12+8+36 = 165 bytes
```

This fixed size allows us to filter precisely for standard token accounts and exclude:

* Mint accounts (82 bytes)
* Multisig accounts (355 bytes)
* Associated token account program accounts
* Other token-related accounts with different sizes

For calculating account sizes in other programs, check out the [Anchor Space Reference](https://www.anchor-lang.com/docs/references/space) - it shows you how much space different data types take (Pubkey = 32 bytes, u64 = 8 bytes, etc.).

#### Decoding the account structure

Now that we understand why we filtered for 165 bytes, let's decode what's inside our example account:

```
Base58 data: 2NUx6Xw9QkmgJCyYUP3d8TPsjJhUpSM7hcy9Fi1juGc6g9...
```

The 165 bytes break down as:

* **Bytes 0-31:** Mint address (which token this account holds)
* **Bytes 32-63:** Owner address (who owns this token account)
* **Bytes 64-71:** Token amount (how many tokens are in the account)
* **Bytes 72-164:** Additional metadata (delegate, state, close authority, etc.)

This structured approach gives us surgical precision: we only receive updates for standard token accounts, not the noise from other account types.

### Combining filters: datasize + memcmp for laser precision

Now that we know the mint address lives at bytes 0-31, we can get even more specific. Let's say we only want to monitor USDC token accounts. We can combine our `datasize` filter with a `memcmp` filter to target the exact mint address:

```ts
const USDC_MINT = "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v";

const request = {
  accounts: {
    "usdc-only": {
      owner: ["TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"],
      filters: [
        { datasize: 165 },                    // Standard token accounts only
        { 
          memcmp: {
            offset: 0,                         // Mint address starts at byte 0
            base58: USDC_MINT                  // Match this specific mint
          }
        }
      ]
    }
  },
  // ... other config
};
```

**Progressive filtering strategy:**

1. **Owner filter:** "Give me accounts owned by Token Program" (millions of accounts)
2. **Datasize filter:** "But only 165-byte standard token accounts" (hundreds of thousands)
3. **Memcmp filter:** "And only those holding USDC" (thousands)

This progression from broad to specific is the key to efficient account monitoring. Each filter narrows down the result set, so you only receive the exact updates you care about.

**Important:** All filters use AND logic - every condition must be met for an account update to trigger.

### Reading USDC account updates: Who, How Much, Where?

Now let's see what these filtered updates actually contain. Let's create a USDC-specific monitor that answers the key questions when a token account changes:

* **Who** owns this token account?
* **How much** USDC does it now contain?
* **Where** (which specific account) changed?
* **When** did this change happen?
* **What transaction** caused the change?

The raw account updates contain binary data that we need to decode. Since Solana uses base58 encoding for addresses and signatures, we use the `bs58.encode()` function to convert binary Buffer objects to readable strings.

```ts [expandable]
import { subscribe, CommitmentLevel, SubscribeUpdate, LaserstreamConfig } from 'helius-laserstream';
import * as bs58 from 'bs58';

async function main() {
  console.log('USDC Account Monitor');

  const config: LaserstreamConfig = {
    apiKey: 'your-api-key',
    endpoint: 'laserstream-url',
  };

  const USDC_MINT = "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v";

  const request = {
    accounts: {
      "usdc-accounts": {
        account: [],
        owner: ["TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"],
        filters: [
          { datasize: 165 },                           // Standard token accounts
          { memcmp: { offset: 0, base58: USDC_MINT } } // Only USDC
        ]
      }
    },
    commitment: CommitmentLevel.CONFIRMED,
    transactions: {}, slots: {}, transactionsStatus: {}, blocks: {}, blocksMeta: {}, entry: {}, accountsDataSlice: []
  };

  const stream = await subscribe(
    config,
    request,
    async (update: SubscribeUpdate) => {
      explainAccountUpdate(update);
    },
    async (err) => console.error('Stream error:', err)
  );

  console.log(`Account monitor started (id: ${stream.id})`);

  process.on('SIGINT', () => {
    console.log('\nCancelling stream...');
    stream.cancel();
    process.exit(0);
  });
}

function explainAccountUpdate(update: SubscribeUpdate) {
  if (!update.account) return;
  
  const account = update.account.account;
  
  // Decode the key addresses
  const tokenAccountAddress = bs58.encode(account.pubkey);
  const transactionSignature = account.txnSignature ? bs58.encode(account.txnSignature) : 'Unknown';
  
  // Extract and decode the token account data (165 bytes)
  const walletOwner = bs58.encode(account.data.slice(32, 64));       // Bytes 32-63: Owner
  const tokenAmount = account.data.readBigUInt64LE(64);              // Bytes 64-71: Amount
  const usdcAmount = Number(tokenAmount) / 1_000_000;                // Convert to USDC (6 decimals)
  
  console.log(`Account: ${tokenAccountAddress}`);
  console.log(`Owner: ${walletOwner}`);
  console.log(`Balance: ${usdcAmount.toLocaleString()} USDC`);
  console.log(`Slot: ${update.account.slot}`);
  console.log(`Transaction: ${transactionSignature.slice(0, 8)}...`);
  console.log('---');
}

main().catch(console.error);
```

When you run this USDC monitor, you'll see clean, structured output like this:

```
USDC Account Monitor
Account monitor started (id: abc123)

Account: 7xKXtg2CW87d97TXJSDpbD5jBkheTqA83TZRuJosgAsU
Owner: 9WzDXwBbmkg8ZTbNMqUxvQRAyrZzDsGYdLVL9zYtAWWM
Balance: 1,500 USDC
Slot: 352154103
Transaction: 5v8fy0eJ...
---
Account: BQy5rNRxLfcaK6554PMzsg4VJsFXzwGnAnayb8TZKgZX
Owner: HN7cABqLq46Es1jh92dQQisAq662SmxELLLsHHe4YWrH
Balance: 0 USDC
Slot: 352154103
Transaction: 5v8fy0eJ...
---
```

Each block represents a USDC account that changed state. The first account now holds 1,500 USDC, while the second account has been emptied to 0 USDC. You get the current balance immediately after each transaction, along with which specific account changed and when.

Account subscriptions show you the end result of what happened to each account, not the transaction details. If you need to understand the full transaction context (who sent to whom, fees, etc.), you'd need to fetch the full transaction using the signature shown.

## Complete filtering reference

Beyond the basic `owner`, `datasize`, and `memcmp` filters we've used, account subscriptions support additional filtering options to further narrow your results:

### Specific account filtering

Monitor exact accounts by their public keys:

```ts
accounts: {
  "specific-accounts": {
    account: [
      "7xKXtg2CW87d97TXJSDpbD5jBkheTqA83TZRuJosgAsU",
      "BQy5rNRxLfcaK6554PMzsg4VJsFXzwGnAnayb8TZKgZX"
    ]
  }
}
```

This approach works well when you know exactly which accounts matter to your application - like monitoring your application's treasury accounts or specific user accounts.

### Combined filtering strategies

The power comes from combining multiple filter types. Here's the mental model:

1. **Cast a wide net** with `owner` - "Give me all accounts managed by this program"
2. **Filter by structure** with `datasize` - "But only accounts of this specific type"
3. **Target specific data** with `memcmp` - "And only those containing this specific information"
4. **Monitor known accounts** with `account` - "Or just watch these exact accounts I care about"

For example, monitoring high-value USDC accounts:

```ts
accounts: {
  "high-value-usdc": {
    owner: ["TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"],
    filters: [
      { datasize: 165 },                           // Token accounts only
      { memcmp: { offset: 0, base58: USDC_MINT } } // USDC only
      // Note: You'd implement balance filtering in your callback logic
    ]
  }
}
```

The key insight is that each filter reduces the volume of updates you receive. Without filtering, you might get overwhelming amounts of account updates. With smart filtering, you get only the updates that matter to your specific use case.

### Understanding the bigger picture

Think of account subscriptions as watching a live feed of database changes. Solana's state is essentially a massive key-value store where each account is an entry. When programs execute, they modify these accounts. Your subscription lets you watch specific entries change in real-time.

The filtering system works like database indexes - you're not just watching "all changes" but rather "changes to accounts that match these criteria." This makes it possible to build responsive applications that react immediately to relevant on-chain events without overwhelming your system with irrelevant data.

## Applying this pattern to other programs

The approach we've learned works for any Solana program. Here's the general pattern:

1. **Research the account structure** - Check the program's source code or documentation
2. **Start with owner filtering** - Target the program that manages the accounts
3. **Apply structural filters** - Use account size, data patterns, or other characteristics to narrow down to specific account types
4. **Add targeted filters** - Focus on specific accounts, states, or data values that matter to your application


# Decoding and Parsing Transaction Data
Source: https://www.helius.dev/docs/laserstream/guides/decoding-transaction-data

Learn how to decode and parse transaction data from Laserstream for better understanding of Solana transactions.

**When you receive transaction data from Laserstream, there are two important things to look for:**

* **Message**  What the user wanted to do (their signed proposal)
* **Meta**  What actually happened (the execution result)

**The challenge:** Raw transaction data comes as binary byte arrays like `<Buffer 00 bf a0 e8...>` instead of readable addresses and signatures.

**This guide shows you how to:** Decode that binary data into human-readable format, extract meaningful information, and understand the complete transaction story from proposal to execution.

***

## A live stream, no decoding

Run the minimal client below. The filter flags drop vote and failed transactions, and the accountsInclude array limits results to activity that touches the Jupiter program ID.

```ts [expandable]
import { subscribe, CommitmentLevel, SubscribeUpdate, LaserstreamConfig } from 'helius-laserstream';

async function runTransactionSubscription() {
  const config: LaserstreamConfig = {
    apiKey: 'your-api-key',
    endpoint: 'laserstream-endpoint',
  };

  const request = {
    transactions: {
      "Jupiter-transactions": {
        vote: false,
        failed: false,
        accountsInclude: ['JUP6LkbZbjS1jKKwapdHNy74zcZ3tLUZoi5QNyVTaV4']
      }
    },
    commitment: CommitmentLevel.PROCESSED,
    accounts: {}, slots: {}, transactionsStatus: {}, blocks: {}, blocksMeta: {}, entry: {}, accountsDataSlice: []
  };

  const stream = await subscribe(
    config,
    request,
    (u: SubscribeUpdate) => console.log(' Transaction update', u),
    console.error
  );

  console.log(` stream id  ${stream.id}`);
  process.on('SIGINT', () => { stream.cancel(); process.exit(0); });
}
runTransactionSubscription().catch(console.error);
```

Your console now shows a wrapper`filters`, `createdAt` plus a `transaction` branch that hides two children:

* `transaction.transaction.transaction`  the signed **message**
* `transaction.transaction.meta`  the execution **meta**

```json
{
 filters: [ 'Jupiter-transactions' ],
  account: undefined,
  transaction: {
    transaction: {
      signature: <Buffer 00 bf a0 e8 9f cc 84 0c a4 83 e3 97 cd b7 57 e2 2b bc 1d ca 8c a6 1b ce b5 57 d7 47 5e ec 1f 46 ae b2 2d 6a 12 cb 88 48 1d 07 bf f6 b2 d3 a8 0b c9 04 ... 14 more bytes>,
      transaction: [Object],
      meta: [Object],
      index: '1177'
    },
    slot: '351704819'
  },
  transactionStatus: undefined,
  block: undefined,
  blockMeta: undefined,
  entry: undefined,
  ping: undefined,
  pong: undefined,
  createdAt: 2025-07-07T10:58:44.403Z
}
```

Everything that looks like `Uint8Array` remains opaque for the moment.

When you run the script with the decoding function, you'll see the actual nested structure with readable addresses:

```json [expandable]
{
  "filters": ["Jupiter-transactions"],
  "account": undefined,
  "transaction": {
    "transaction": {
      "signature": "5u62i53R1Hdc4thm6DQTNWNkyypuJJSaXSMwwQDxNqKMaAw62H1Xa3Md7QDhYjoPk5dCPg18fwz83kUR6TrMviTx",
      "transaction": {
        "message": {
          "header": {
            "numRequiredSignatures": 1,
            "numReadonlySignedAccounts": 0,
            "numReadonlyUnsignedAccounts": 8
          },
          "accountKeys": [
            "AF9KFSWQeKVxd3kVvFvysWXmATHyYzrN8zN8GtXn4qTF",
            "G9VzXwhDPQ8KRbQAJN6TyGf2gWukYDAvmnXJhPZFev4f",
            "ES9qPxWQVMRZkobJ9yr3U6XSrXzGNLJdSe6p6fS7b82T",
            "JUP6LkbZbjS1jKKwapdHNy74zcZ3tLUZoi5QNyVTaV4",
            "ComputeBudget111111111111111111111111111111",
            "ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL",
            "So11111111111111111111111111111111111111112",
            "11111111111111111111111111111111",
            "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"
          ],
          "recentBlockhash": "8sGjRxJHLJVWqpHt5UdN8qxtLLdgcnLKBpFj9Qrn5PNF",
          "instructions": [
            {
              "programIdIndex": 4,
              "accounts": [],
              "data": "3bjaAzoXPjbY"
            },
            {
              "programIdIndex": 3,
              "accounts": [0, 1, 2, 5, 6, 7, 8],
              "data": "2L1xoA2KEqBgWfGt3fwFJK8k4FPJRJzYHRgH4R3xC8A7"
            }
          ]
        },
        "signatures": [
          "5u62i53R1Hdc4thm6DQTNWNkyypuJJSaXSMwwQDxNqKMaAw62H1Xa3Md7QDhYjoPk5dCPg18fwz83kUR6TrMviTx"
        ]
      },
      "meta": {
        "err": null,
        "fee": 12500,
        "preBalances": [1075517572, 0, 207594496815, 0, 0, 0, 0, 0, 0],
        "postBalances": [1075502572, 1461600, 207594496815, 2001231920, 2039280, 0, 0, 0, 0],
        "innerInstructions": [
          {
            "index": 1,
            "instructions": [
              {
                "programIdIndex": 5,
                "accounts": [1, 2, 0],
                "data": "3Bxs4h24hBtQy9rw"
              }
            ]
          }
        ],
        "logMessages": [
          "Program ComputeBudget111111111111111111111111111111 invoke [1]",
          "Program ComputeBudget111111111111111111111111111111 success",
          "Program JUP6LkbZbjS1jKKwapdHNy74zcZ3tLUZoi5QNyVTaV4 invoke [1]",
          "Program log: Instruction: Swap",
          "Program ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL invoke [2]",
          "Program log: Create",
          "Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA invoke [3]",
          "Program log: Instruction: GetAccountDataSize",
          "Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA consumed 1569 of 242833 compute units",
          "Program return: TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA pQAAAAAAAAA=",
          "Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA success",
          "Program JUP6LkbZbjS1jKKwapdHNy74zcZ3tLUZoi5QNyVTaV4 success"
        ],
        "preTokenBalances": [],
        "postTokenBalances": [],
        "computeUnitsConsumed": 182564
      },
      "index": "1177"
    },
    "slot": "351709933"
  },
  "transactionStatus": undefined,
  "block": undefined,
  "blockMeta": undefined,
  "entry": undefined,
  "ping": undefined,
  "pong": undefined,
  "createdAt": "2025-01-14T10:58:44.403Z"
}
```

***

## Decoding the binary data

**Why decode?** Raw Laserstream data contains signatures, account keys, and hashes as binary `Uint8Array` objects that are unreadable. You need to convert these to base58 strings to make sense of the transaction.

**The solution:** Laserstream uses Yellowstone gRPC, which provides built-in decoding utilities. Instead of writing separate decoders for each field type, we use one recursive function that converts all binary data to human-readable format.

```ts [expandable]
import bs58 from 'bs58';
import { subscribe, CommitmentLevel, SubscribeUpdate, LaserstreamConfig } from 'helius-laserstream';

// Recursive function to convert all Buffer/Uint8Array fields to base58
function convertBuffers(obj: any): any {
  if (!obj) return obj;
  if (Buffer.isBuffer(obj) || obj instanceof Uint8Array) {
    return bs58.encode(obj);
  }
  if (Array.isArray(obj)) {
    return obj.map(item => convertBuffers(item));
  }
  if (typeof obj === 'object') {
    return Object.fromEntries(
      Object.entries(obj).map(([key, value]) => [key, convertBuffers(value)])
    );
  }
  return obj;
}

async function runTransactionSubscription() {
  const config: LaserstreamConfig = {
    apiKey: 'your-api-key',
    endpoint: 'laserstream-endpoint',
  };

  const request = {
    transactions: {
      "Jupiter-transactions": {
        vote: false,
        failed: false,
        accountsInclude: ['JUP6LkbZbjS1jKKwapdHNy74zcZ3tLUZoi5QNyVTaV4']
      }
    },
    commitment: CommitmentLevel.PROCESSED,
    accounts: {}, slots: {}, transactionsStatus: {}, blocks: {}, blocksMeta: {}, entry: {}, accountsDataSlice: []
  };

  const stream = await subscribe(
    config,
    request,
    (update: SubscribeUpdate) => {
      if (update.transaction) {
        // Convert all binary fields to human-readable format
        const decodedTransaction = convertBuffers(update.transaction);
        console.log(' Decoded transaction:', JSON.stringify(decodedTransaction, null, 2));
        
        // Or process specific fields
        processTransaction(update.transaction);
      }
    },
    console.error
  );

  console.log(` stream id  ${stream.id}`);
  process.on('SIGINT', () => { stream.cancel(); process.exit(0); });
}

function processTransaction(txUpdate: any) {
  const tx = txUpdate.transaction;
  const meta = tx.meta;
  
  console.log('Transaction Details:');
  console.log('- Signature:', bs58.encode(tx.signature));
  console.log('- Slot:', txUpdate.slot);
  console.log('- Success:', meta.err === null);
  console.log('- Fee:', meta.fee, 'lamports');
  console.log('- Compute Units:', meta.computeUnitsConsumed);
  
  // Account keys are already available in the message
  const message = tx.transaction.message;
  if (message.accountKeys) {
    console.log('- Account Keys:');
    message.accountKeys.forEach((key: Uint8Array, index: number) => {
      console.log(`  ${index}: ${bs58.encode(key)}`);
    });
  }
  
  // Log messages are already UTF-8 strings
  if (meta.logMessages && meta.logMessages.length > 0) {
    console.log('- Log Messages:');
    meta.logMessages.forEach((log: string) => {
      console.log(`  ${log}`);
    });
  }
}

runTransactionSubscription();
```

This approach leverages the built-in decoding while handling the binary fields that need manual conversion. The transaction structure is already parsed - you just need to convert the binary fields to human-readable format.

***

## Understanding the transaction structure

Now that we can see the decoded data, let's explore the two main parts of every Laserstream transaction update. Remember from our initial example that each transaction contains two key objects:

* **Message (Proposal)**  `transaction.transaction.transaction`  the signed message (user's proposal)
* **Meta (Execution)**  `transaction.transaction.meta`  the execution metadata (validator's response)

This two-part structure tells a complete story: what the user requested versus what actually happened. Let's examine each part in detail.

***

## The proposal: everything inside message

The user creates a message that specifies *what*, *who* and *until when*. Here's how to decode each part:

### Transaction Header

```json
{
  "header": {
    "numRequiredSignatures": 1,
    "numReadonlySignedAccounts": 0,
    "numReadonlyUnsignedAccounts": 5
  }
}
```

`numRequiredSignatures` tells the validator how many signatures to verify, while the two `numReadonly*` values label accounts the runtime can treat as read-only, enabling parallel execution.

### Account Keys Dictionary

```json
{
  "accountKeys": [
    "7YttLkHDoNj9wyDur5pM1ejNaAvT9X4eqaYcHQqtj2G5",
    "JUP6LkbZbjS1jKKwapdHNy74zcZ3tLUZoi5QNyVTaV4",
    "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA",
    "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",
    "So11111111111111111111111111111111111111112",
    "11111111111111111111111111111111"
  ]
}
```

`accountKeys` is a plain list of public keys that acts as a lookup table. Every later integer in the transaction - `programIdIndex`, each element in an instruction's `accounts` array - points back into this list by index, saving more than a kilobyte per message.

### Protection Against Replay

```json
{
  "recentBlockhash": "8sGjRxJHLJVWqpHt5UdN8qxtLLdgcnLKBpFj9Qrn5PNF"
}
```

`recentBlockhash` expires once it scrolls out of the last 150 block-hashes, roughly ninety seconds on mainnet.

### Instructions: The Actual Commands

```json
{
  "instructions": [
    {
      "programIdIndex": 10,
      "data": "HnkkG7"
    },
    {
      "programIdIndex": 15,
      "accounts": "3vtmrQMafzDoG2CBz1iqgXPTnC",
      "data": "5jRcjdixRUDKQKUEt6oHJ747HCB3vWb5y"
    }
  ]
}
```

Each instruction contains three key parts:

* **Program ID** (`programIdIndex`): Points to an address in the `accountKeys` array (e.g., index 10 = `ComputeBudget111111111111111111111111111111`)
* **Accounts** (`accounts`): A base58-encoded string representing which account indexes this instruction touches
* **Data** (`data`): The actual instruction data encoded as base58

Due to the `convertBuffers` function, accounts appears as base58 but actually contains account indices (e.g., `"3vtmrQMafzDoG2CBz1iqgXPTnC"` decodes to indices \[21, 19, 12, 17, 2, 6, 1, 22])

This design means instead of repeating full 32-byte addresses, each instruction just references positions in the lookup table.

### Signatures: Proof of Authorization

```json
{
  "signatures": [
    "5u62i53R1Hdc4thm6DQTNWNkyypuJJSaXSMwwQDxNqKMaAw62H1Xa3Md7QDhYjoPk5dCPg18fwz83kUR6TrMviTx"
  ]
}
```

`signatures` contains the cryptographic signatures proving the required accounts authorized this transaction. The number of signatures must match `header.numRequiredSignatures`.

### Address Table Lookups

```json
{
  "addressTableLookups": [
    {
      "accountKey": "5Q544fKrFoe6tsEbD7S8EmxGTJYAKtTVhAW5Q5pge4j1",
      "writableIndexes": [0, 1],
      "readonlyIndexes": [2, 3, 4]
    }
  ],
  "versioned": true
}
```

If `versioned` is `true`, `addressTableLookups` appears with an on-chain table and two index lists. Lookup tables lift the hard cap on address count to dozens while keeping the packet under the 1,232-byte MTU.

### How It All Connects: The Flow

Here's what happens from first principles:

1. **Build the lookup table**: `accountKeys` lists all addresses this transaction will touch
2. **Set the rules**: `header` specifies how many signatures are required and which accounts are read-only
3. **Create the commands**: Each `instruction` points to:
   * A program (via `programIdIndex`  `accountKeys[index]`)
   * The accounts it needs (via `accounts`  multiple `accountKeys[index]` positions)
   * The instruction data (encoded in `data`)
4. **Add authorization**: `signatures` proves the required accounts approved this transaction
5. **Set expiration**: `recentBlockhash` ensures this transaction can't be replayed later

***

## The execution: everything inside meta

While the message shows what the user wanted to do, the meta shows what actually happened when validators executed the transaction.

### Basic execution information

**Success/Failure**

```json
{
  "err": null,
  "fee": 12500
}
```

* `err: null` = success
* `err: {...}` = failure with error details
* `fee` = lamports charged for this transaction

**Balance Changes**

```json
{
  "preBalances": [1075517572, 0, 207594496815, 0, 0, 0, 0, 0, 0],
  "postBalances": [1075502572, 1461600, 207594496815, 2001231920, 2039280, 0, 0, 0, 0]
}
```

Balance arrays correspond to the `accountKeys` array by index:

* Account 0: Lost 15000 lamports (fee payment)
* Account 1: Gained 1461600 lamports (new account created)
* Account 3: Gained 2001231920 lamports (program account)

**Compute Usage**

```json
{
  "computeUnitsConsumed": 182564
}
```

Shows how much compute budget was used (out of the requested amount).

### Advanced execution details

**Inner Instructions**

```json
{
  "innerInstructions": [
    {
      "index": 1,
      "instructions": [
        {
          "programIdIndex": 5,
          "accounts": [1, 2, 0],
          "data": "3Bxs4h24hBtQy9rw"
        }
      ]
    }
  ]
}
```

Inner instructions are additional instructions that programs called during execution. They're not part of the original transaction but were triggered by the main instructions.

**Log Messages**

```json
{
  "logMessages": [
    "Program ComputeBudget111111111111111111111111111111 invoke [1]",
    "Program ComputeBudget111111111111111111111111111111 success",
    "Program JUP6LkbZbjS1jKKwapdHNy74zcZ3tLUZoi5QNyVTaV4 invoke [1]",
    "Program log: Instruction: Swap",
    "Program ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL invoke [2]",
    "Program log: Create",
    "Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA invoke [3]",
    "Program log: Instruction: GetAccountDataSize",
    "Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA consumed 1569 of 242833 compute units",
    "Program return: TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA pQAAAAAAAAA=",
    "Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA success",
    "Program JUP6LkbZbjS1jKKwapdHNy74zcZ3tLUZoi5QNyVTaV4 success"
  ]
}
```

Log messages provide a chronological trace of program execution, showing which programs were called and any custom log messages they output.

**Token Balance Changes**

```json
{
  "preTokenBalances": [],
  "postTokenBalances": [
    {
      "accountIndex": 1,
      "mint": "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",
      "owner": "7YttLkHDoNj9wyDur5pM1ejNaAvT9X4eqaYcHQqtj2G5",
      "uiTokenAmount": {
        "amount": "1000000",
        "decimals": 6,
        "uiAmount": 1.0,
        "uiAmountString": "1"
      }
    }
  ]
}
```

Token balance changes show before/after states for SPL token accounts, including the human-readable amounts with proper decimal handling.

***

## Practical decoding patterns

Here are common patterns for extracting useful information from decoded transactions:

```typescript
// Transaction Success
function isTransactionSuccessful(meta: any): boolean {
  return meta.err === null;
}

function getTransactionFee(meta: any): number {
  return meta.fee;
}

function getComputeUnitsUsed(meta: any): number {
  return meta.computeUnitsConsumed;
}

// Balance Changes
function getBalanceChanges(meta: any, accountKeys: string[]): Array<{account: string, change: number}> {
  const changes = [];
  
  for (let i = 0; i < meta.preBalances.length; i++) {
    const change = meta.postBalances[i] - meta.preBalances[i];
    if (change !== 0) {
      changes.push({
        account: accountKeys[i],
        change: change
      });
    }
  }
  
  return changes;
}

// Program Calls
function getInvokedPrograms(meta: any, accountKeys: string[]): string[] {
  const programs = new Set<string>();
  
  meta.logMessages.forEach((log: string) => {
    const match = log.match(/Program ([1-9A-HJ-NP-Za-km-z]{32,}) invoke/);
    if (match) {
      programs.add(match[1]);
    }
  });
  
  return Array.from(programs);
}

// Token Transfers
function getTokenTransfers(meta: any): Array<{mint: string, from: string, to: string, amount: number}> {
  const transfers = [];
  
  // Compare pre and post token balances
  const preBalances = new Map();
  const postBalances = new Map();
  
  meta.preTokenBalances.forEach((balance: any) => {
    preBalances.set(balance.accountIndex, balance);
  });
  
  meta.postTokenBalances.forEach((balance: any) => {
    postBalances.set(balance.accountIndex, balance);
  });
  
  // Find changes
  for (const [accountIndex, postBalance] of postBalances) {
    const preBalance = preBalances.get(accountIndex);
    const preAmount = preBalance ? parseInt(preBalance.uiTokenAmount.amount) : 0;
    const postAmount = parseInt(postBalance.uiTokenAmount.amount);
    
    if (preAmount !== postAmount) {
      transfers.push({
        mint: postBalance.mint,
        account: postBalance.owner,
        change: postAmount - preAmount,
        decimals: postBalance.uiTokenAmount.decimals
      });
    }
  }
  
  return transfers;
}
```

***

## Complete example: Jupiter swap decoder

Here's a complete example that decodes Jupiter swap transactions and extracts meaningful information:

```typescript [expandable]
import bs58 from 'bs58';
import { subscribe, CommitmentLevel, SubscribeUpdate, LaserstreamConfig } from '../client';

interface SwapInfo {
  signature: string;
  slot: number;
  user: string;
  inputMint: string;
  outputMint: string;
  inputAmount: number;
  outputAmount: number;
  fee: number;
  success: boolean;
}

function convertBuffers(obj: any): any {
  if (!obj) return obj;
  if (Buffer.isBuffer(obj) || obj instanceof Uint8Array) {
    return bs58.encode(obj);
  }
  if (Array.isArray(obj)) {
    return obj.map(item => convertBuffers(item));
  }
  if (typeof obj === 'object') {
    return Object.fromEntries(
      Object.entries(obj).map(([key, value]) => [key, convertBuffers(value)])
    );
  }
  return obj;
}

function decodeJupiterSwap(txUpdate: any): SwapInfo | null {
  const tx = txUpdate.transaction;
  const meta = tx.meta;
  const message = tx.transaction.message;
  
  // Convert binary fields to readable format
  const signature = bs58.encode(tx.signature);
  const accountKeys = message.accountKeys.map((key: any) => bs58.encode(key));
  
  // Check if this is a Jupiter transaction
  const jupiterProgram = "JUP6LkbZbjS1jKKwapdHNy74zcZ3tLUZoi5QNyVTaV4";
  if (!accountKeys.includes(jupiterProgram)) {
    return null;
  }
  
  // Extract user (first account is typically the fee payer/user)
  const user = accountKeys[0];
  
  // Get token balance changes
  const tokenChanges = getTokenTransfers(meta);
  
  // Find input (negative change) and output (positive change)
  const inputChange = tokenChanges.find(change => change.change < 0);
  const outputChange = tokenChanges.find(change => change.change > 0);
  
  if (!inputChange || !outputChange) {
    return null;
  }
  
  return {
    signature,
    slot: parseInt(txUpdate.slot),
    user,
    inputMint: inputChange.mint,
    outputMint: outputChange.mint,
    inputAmount: Math.abs(inputChange.change),
    outputAmount: outputChange.change,
    fee: meta.fee,
    success: meta.err === null
  };
}

function getTokenTransfers(meta: any): Array<{mint: string, change: number}> {
  const transfers = [];
  
  const preBalances = new Map();
  const postBalances = new Map();
  
  meta.preTokenBalances.forEach((balance: any) => {
    preBalances.set(balance.accountIndex, balance);
  });
  
  meta.postTokenBalances.forEach((balance: any) => {
    postBalances.set(balance.accountIndex, balance);
  });
  
  for (const [accountIndex, postBalance] of postBalances) {
    const preBalance = preBalances.get(accountIndex);
    const preAmount = preBalance ? parseInt(preBalance.uiTokenAmount.amount) : 0;
    const postAmount = parseInt(postBalance.uiTokenAmount.amount);
    
    if (preAmount !== postAmount) {
      transfers.push({
        mint: postBalance.mint,
        change: postAmount - preAmount
      });
    }
  }
  
  return transfers;
}

async function runJupiterSwapMonitor() {
  const config: LaserstreamConfig = {
    apiKey: 'your-api-key',
    endpoint: 'laserstream-endpoint',
  };

  const request = {
    transactions: {
      "Jupiter-swaps": {
        vote: false,
        failed: false,
        accountsInclude: ['JUP6LkbZbjS1jKKwapdHNy74zcZ3tLUZoi5QNyVTaV4']
      }
    },
    commitment: CommitmentLevel.PROCESSED,
    accounts: {}, slots: {}, transactionsStatus: {}, blocks: {}, blocksMeta: {}, entry: {}, accountsDataSlice: []
  };

  const stream = await subscribe(
    config,
    request,
    (update: SubscribeUpdate) => {
      if (update.transaction) {
        const swapInfo = decodeJupiterSwap(update.transaction);
        if (swapInfo) {
          console.log(' Jupiter Swap:');
          console.log(`  User: ${swapInfo.user}`);
          console.log(`  Input: ${swapInfo.inputAmount} of ${swapInfo.inputMint}`);
          console.log(`  Output: ${swapInfo.outputAmount} of ${swapInfo.outputMint}`);
          console.log(`  Fee: ${swapInfo.fee} lamports`);
          console.log(`  Success: ${swapInfo.success}`);
          console.log(`  Signature: ${swapInfo.signature}`);
          console.log('---');
        }
      }
    },
    console.error
  );

  console.log(` Jupiter swap monitor started (id: ${stream.id})`);
  process.on('SIGINT', () => { stream.cancel(); process.exit(0); });
}

runJupiterSwapMonitor().catch(console.error);
```

This example shows how to combine message decoding with meta analysis to extract business-relevant information from complex DeFi transactions.

***

## Key takeaways

* **Two-part structure**: Every transaction has a **message** (what was requested) and **meta** (what actually happened)
* **Binary decoding**: Use `bs58.encode()` to convert binary fields to readable base58 strings
* **Account key lookups**: Instructions reference accounts by index in the `accountKeys` array
* **Balance tracking**: Compare `preBalances` and `postBalances` to see what changed

The key to understanding Solana transactions is recognizing that they're designed for efficiency: instead of repeating addresses, they use lookup tables and indexes to minimize transaction size while maximizing information density.


# Measuring Latency
Source: https://www.helius.dev/docs/laserstream/guides/measuring-latency

Learn how to properly measure and analyze latency for gRPC streams using various testing methods.

<Warning>
  **CRITICAL DISCLAIMER: Production Data Center Only**

  These latency tests are designed for **production data center environments only**. DO NOT run these tests on local machines or consumer internet connections. Local bandwidth cannot handle heavy Solana subscriptions and will produce meaningless results that don't reflect real-world performance.
</Warning>

<Warning>
  **CO-LOCATION REQUIREMENT: Deploy Near Your LaserStream Endpoint**

  For meaningful latency measurements, you **must** co-locate your testing infrastructure in the same region as your chosen LaserStream endpoint. Network distance will dominate your measurements - testing from a different continent will show network latency, not LaserStream performance.
</Warning>

***

## Understanding latency in distributed blockchain systems

When working with blockchain streaming services, latency measurement becomes complex because distributed systems don't have a universal clock. Unlike traditional systems where you can measure round-trip time to a single server, blockchain networks involve multiple validators, each receiving and processing the same transaction at different times.

**The fundamental challenge:** Blockchains like Solana don't have a concept of absolute time. Each validator node globally will receive the same transaction at different times, and confirmation depends on a percentage of the cluster reaching consensus. This makes deterministic latency measurement impossible in the traditional sense.

## Commitment levels and latency priorities

Solana offers three commitment levels, each with different latency characteristics:

* **Processed**: Fastest, single validator confirmation (\~400ms)
* **Confirmed**: Medium, supermajority confirmation (\~2-3 seconds)
* **Finalized**: Slowest, complete network finalization (\~15-30 seconds)

For latency-sensitive applications, **processed commitment** is typically the target. All tests in this guide use processed commitment level since most high-frequency use cases prioritize speed over absolute finality.

## Three approaches to measuring latency

### 1. Comparing parallel gRPC streams

**Most reliable method** - Compares two independent streams to the same data source, measuring which receives identical events first.

**Advantages:**

* Eliminates clock synchronization issues
* Provides relative performance comparison
* Most accurate for comparing services

### 2. Local timestamp vs created\_at comparison

**Moderate reliability** - Measures the difference between when your system receives a message and the timestamp embedded in the message by the LaserStream service.

**Limitations:**

* Only represents when LaserStream created the message internally
* Upstream delays to LaserStream won't be captured
* Less accurate than Method 1 for true end-to-end latency

### 3. Block timestamp analysis (not recommended)

**Not recommended** - Compares local receipt time against Solana's block timestamp.

**Significant limitations:**

* Block timestamps only have second-level granularity
* Solana produces blocks every 400ms
* Provides minimal useful information

***

## Setup requirements

### Regional co-location

For meaningful latency measurements, deploy your testing infrastructure in the same data center or region as your LaserStream endpoint.

**Available LaserStream regions:**

* **ewr**: New York, US (East Coast) - `https://laserstream-mainnet-ewr.helius-rpc.com`
* **pitt**: Pittsburgh, US (Central) - `https://laserstream-mainnet-pitt.helius-rpc.com`
* **slc**: Salt Lake City, US (West Coast) - `https://laserstream-mainnet-slc.helius-rpc.com`
* **ams**: Amsterdam, Europe - `https://laserstream-mainnet-ams.helius-rpc.com`
* **fra**: Frankfurt, Europe - `https://laserstream-mainnet-fra.helius-rpc.com`
* **tyo**: Tokyo, Asia - `https://laserstream-mainnet-tyo.helius-rpc.com`
* **sgp**: Singapore, Asia - `https://laserstream-mainnet-sgp.helius-rpc.com`

For devnet testing, use: `https://laserstream-devnet-ewr.helius-rpc.com`

See the [LaserStream gRPC documentation](/laserstream/grpc) for complete setup instructions and endpoint selection guidelines.

### Rust environment setup

All measurement scripts use Rust with Cargo. Basic setup:

```bash
# Install Rust
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh

# Setup project
cargo new latency-testing
cd latency-testing

# Add dependencies to Cargo.toml
[dependencies]
# Async runtime
tokio = { version = "1", features = ["full"] }
# Futures utilities for StreamExt, SinkExt
futures = "0.3"
# Environment variable loading
dotenvy = "0.15"
# Logging
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["fmt", "env-filter"] }
# Yellowstone gRPC client and protocol
yellowstone-grpc-client = "8.0.0"
yellowstone-grpc-proto = "8.0.0"
# For timestamp analysis
prost-types = "0.12"
```

Create a `.env` file with your credentials:

```bash
YS_GRPC_URL=your-comparison-endpoint
YS_API_KEY=your-comparison-api-key
LS_GRPC_URL=your-laserstream-endpoint  
LS_API_KEY=your-helius-api-key
```

Get your Helius API key from the [Helius Dashboard](https://dashboard.helius.dev/). LaserStream requires a Professional plan subscription.

***

## Method 1: Parallel stream comparison

This script establishes two independent connections to different gRPC endpoints and measures which receives the same `BlockMeta` messages first. This approach eliminates clock synchronization issues by using relative timing.

```rust [expandable]
use std::collections::HashMap;
use std::time::SystemTime;

use dotenvy::dotenv;
use futures::{StreamExt, SinkExt};
use tokio::sync::mpsc;
use tracing::{debug, error, info};

use yellowstone_grpc_client::{ClientTlsConfig, GeyserGrpcClient};
use yellowstone_grpc_proto::prelude::{
    subscribe_update::UpdateOneof, CommitmentLevel, SubscribeRequest, 
    SubscribeRequestFilterBlocksMeta, SubscribeUpdate,
};

#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
enum Source {
    Yellowstone,
    Laserstream,
}

#[derive(Default, Debug)]
struct SlotTimings {
    ys_recv_ms: Option<i128>,
    ls_recv_ms: Option<i128>,
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let _ = dotenv();
    tracing_subscriber::fmt().with_env_filter("info").init();

    let ys_url = std::env::var("YS_GRPC_URL").expect("YS_GRPC_URL env variable not set");
    let ls_url = std::env::var("LS_GRPC_URL").expect("LS_GRPC_URL env variable not set");
    let ys_api_key = std::env::var("YS_API_KEY").ok();
    let ls_api_key = std::env::var("LS_API_KEY").ok();

    let commitment = CommitmentLevel::Processed;
    info!(?commitment, "Starting latency comparison");

    // Establish both clients
    let mut ys_client = GeyserGrpcClient::build_from_shared(ys_url.clone())
        .expect("invalid YS url")
        .x_token(ys_api_key.clone())?
        .tls_config(ClientTlsConfig::new().with_native_roots())?
        .max_decoding_message_size(10 * 1024 * 1024)
        .connect()
        .await?;

    let mut ls_client = GeyserGrpcClient::build_from_shared(ls_url.clone())
        .expect("invalid LS url")
        .x_token(ls_api_key.clone())?
        .tls_config(ClientTlsConfig::new().with_native_roots())?
        .max_decoding_message_size(10 * 1024 * 1024)
        .connect()
        .await?;

    let (mut ys_tx, mut ys_rx) = ys_client.subscribe().await?;
    let (mut ls_tx, mut ls_rx) = ls_client.subscribe().await?;
    
    let subscribe_request = SubscribeRequest {
        blocks_meta: {
            let mut m = HashMap::<String, SubscribeRequestFilterBlocksMeta>::new();
            m.insert("all".to_string(), SubscribeRequestFilterBlocksMeta::default());
            m
        },
        commitment: Some(commitment as i32),
        ..Default::default()
    };

    ys_tx.send(subscribe_request.clone()).await?;
    ls_tx.send(subscribe_request).await?;

    let (agg_tx, mut agg_rx) = mpsc::unbounded_channel::<(Source, u64, i128)>();

    // Spawn task for Yellowstone stream
    {
        let agg_tx = agg_tx.clone();
        tokio::spawn(async move {
            while let Some(update_res) = ys_rx.next().await {
                match update_res {
                    Ok(update) => handle_update(Source::Yellowstone, update, &agg_tx).await,
                    Err(e) => {
                        error!(target: "ys", "stream error: {:?}", e);
                        break;
                    }
                }
            }
        });
    }

    // Spawn task for Laserstream stream
    {
        let agg_tx = agg_tx.clone();
        tokio::spawn(async move {
            while let Some(update_res) = ls_rx.next().await {
                match update_res {
                    Ok(update) => handle_update(Source::Laserstream, update, &agg_tx).await,
                    Err(e) => {
                        error!(target: "ls", "stream error: {:?}", e);
                        break;
                    }
                }
            }
        });
    }

    // Aggregator  collect latencies per slot and print once we have both sources
    let mut timings: HashMap<u64, SlotTimings> = HashMap::new();
    let mut deltas: Vec<i128> = Vec::new();
    let mut count = 0;

    println!("slot,ys_recv_ms,ls_recv_ms,delta_ms");

    while let Some((source, slot, latency_ms)) = agg_rx.recv().await {
        let entry = timings.entry(slot).or_default();
        match source {
            Source::Yellowstone => entry.ys_recv_ms = Some(latency_ms),
            Source::Laserstream => entry.ls_recv_ms = Some(latency_ms),
        }

        if let (Some(ys), Some(ls)) = (entry.ys_recv_ms, entry.ls_recv_ms) {
            let delta = ys - ls; // positive => YS arrived later
            println!("{slot},{ys},{ls},{delta}");
            
            deltas.push(delta);
            count += 1;
            
            if count % 100 == 0 {
                print_statistics(&deltas, count);
            }
            
            timings.remove(&slot);
        }
    }

    Ok(())
}

async fn handle_update(
    source: Source,
    update: SubscribeUpdate,
    agg_tx: &mpsc::UnboundedSender<(Source, u64, i128)>,
) {
    if let Some(UpdateOneof::BlockMeta(block_meta)) = update.update_oneof {
        let slot = block_meta.slot;
        let recv_ms = system_time_to_millis(SystemTime::now());
        debug!(?source, slot, recv_ms, "BlockMeta received");
        let _ = agg_tx.send((source, slot, recv_ms));
    }
}

fn print_statistics(deltas: &[i128], count: usize) {
    if deltas.is_empty() {
        return;
    }
    
    let mut sorted_deltas = deltas.to_vec();
    sorted_deltas.sort();
    
    let median = if sorted_deltas.len() % 2 == 0 {
        let mid = sorted_deltas.len() / 2;
        (sorted_deltas[mid - 1] + sorted_deltas[mid]) / 2
    } else {
        sorted_deltas[sorted_deltas.len() / 2]
    };
    
    let min = *sorted_deltas.first().unwrap();
    let max = *sorted_deltas.last().unwrap();
    let sum: i128 = sorted_deltas.iter().sum();
    let mean = sum / sorted_deltas.len() as i128;
    
    let p25_idx = (sorted_deltas.len() as f64 * 0.25) as usize;
    let p75_idx = (sorted_deltas.len() as f64 * 0.75) as usize;
    let p95_idx = (sorted_deltas.len() as f64 * 0.95) as usize;
    
    let p25 = sorted_deltas[p25_idx.min(sorted_deltas.len() - 1)];
    let p75 = sorted_deltas[p75_idx.min(sorted_deltas.len() - 1)];
    let p95 = sorted_deltas[p95_idx.min(sorted_deltas.len() - 1)];
    
    eprintln!("--- Statistics after {} slots ---", count);
    eprintln!("Delta (YS - LS) in milliseconds:");
    eprintln!("  Min: {}, Max: {}", min, max);
    eprintln!("  Mean: {}, Median: {}", mean, median);
    eprintln!("  P25: {}, P75: {}, P95: {}", p25, p75, p95);
    eprintln!("  Positive deltas (YS slower): {}/{} ({:.1}%)", 
              sorted_deltas.iter().filter(|&&x| x > 0).count(),
              sorted_deltas.len(),
              sorted_deltas.iter().filter(|&&x| x > 0).count() as f64 / sorted_deltas.len() as f64 * 100.0);
    eprintln!("---");
}

fn system_time_to_millis(st: SystemTime) -> i128 {
    st.duration_since(SystemTime::UNIX_EPOCH)
        .unwrap()
        .as_millis() as i128
}
```

**What this measures:** The relative performance difference between two streaming services. The delta shows which service delivers the same slot information first.

**Key metrics:**

* **Positive delta**: First service (YS) slower than second service (LS) - LaserStream is faster
* **Negative delta**: First service (YS) faster than second service (LS) - LaserStream is slower
* **Mean/Median**: Average performance difference
* **P95**: 95th percentile latency difference

**Running the test:**

```bash
cargo run --bin latency-comparison
```

**Sample output:**

```
slot,ys_recv_ms,ls_recv_ms,delta_ms
352416939,1752168399141,1752168399140,1
352416940,1752168399526,1752168399512,14
352416941,1752168399890,1752168399877,13
```

The output shows real-time latency differences and periodic statistics. A positive mean delta indicates the second service (LaserStream) consistently delivers data faster.

***

## Method 2: Created timestamp analysis

This approach compares the `created_at` timestamp embedded in messages against your local system time when receiving them.

```rust [expandable]
use std::time::{Duration, SystemTime};
use dotenvy::dotenv;
use tracing::{debug, error, info};
use yellowstone_grpc_proto::prost_types::Timestamp;
use futures::StreamExt;
use futures::SinkExt;
use std::collections::HashMap;

use yellowstone_grpc_client::{ClientTlsConfig, GeyserGrpcClient};
use yellowstone_grpc_proto::prelude::{
    subscribe_update::UpdateOneof, CommitmentLevel, SubscribeRequest,
    SubscribeRequestFilterTransactions, SubscribeUpdate,
};

const ACCOUNTS_INCLUDE: &[&str] = &["BB5dnY55FXS1e1NXqZDwCzgdYJdMCj3B92PU6Q5Fb6DT"];
const COMMITMENT_LEVEL: &str = "processed";

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let _ = dotenv();
    tracing_subscriber::fmt().with_env_filter("info").init();

    let grpc_url = std::env::var("YS_GRPC_URL").expect("GRPC_URL env variable not set");
    let api_key = std::env::var("YS_API_KEY").ok();

    info!("Connecting to {} ", grpc_url);
    debug!(accounts_include = ?ACCOUNTS_INCLUDE, "Subscribing with accountsInclude filter");

    let mut client = GeyserGrpcClient::build_from_shared(grpc_url.clone())
        .expect("invalid URL")
        .x_token(api_key.clone())?
        .tls_config(ClientTlsConfig::new().with_native_roots())?
        .connect()
        .await?;

    let (mut subscribe_tx, mut subscribe_rx) = client.subscribe().await?;

    let mut tx_filter_map = HashMap::new();
    tx_filter_map.insert(
        "latency".to_string(),
        SubscribeRequestFilterTransactions {
            account_include: ACCOUNTS_INCLUDE.iter().map(|s| s.to_string()).collect(),
            vote: Some(false),
            failed: Some(false),
            ..Default::default()
        },
    );

    subscribe_tx
        .send(SubscribeRequest {
            transactions: tx_filter_map,
            commitment: Some(CommitmentLevel::Processed as i32),
            ..Default::default()
        })
        .await?;

    let mut latencies: Vec<i64> = Vec::new();
    let mut count = 0;

    while let Some(update_res) = subscribe_rx.next().await {
        match update_res {
            Ok(update) => {
                if let Some(UpdateOneof::Transaction(tx)) = update.update_oneof {
                    let recv_time = SystemTime::now();
                    
                    if let Some(created_at) = update.created_at {
                        let created_time = SystemTime::UNIX_EPOCH + Duration::new(
                            created_at.seconds as u64,
                            created_at.nanos as u32,
                        );
                        
                        if let Ok(latency) = recv_time.duration_since(created_time) {
                            let latency_ms = latency.as_millis() as i64;
                            latencies.push(latency_ms);
                            count += 1;
                            
                            println!("Transaction latency: {}ms", latency_ms);
                            
                            if count % 100 == 0 {
                                print_statistics(&latencies, count);
                            }
                        }
                    }
                }
            }
            Err(e) => {
                error!("Stream error: {:?}", e);
                break;
            }
        }
    }

    Ok(())
}

fn print_statistics(latencies: &[i64], count: usize) {
    if latencies.is_empty() {
        return;
    }
    
    let mut sorted = latencies.to_vec();
    sorted.sort();
    
    let median = if sorted.len() % 2 == 0 {
        let mid = sorted.len() / 2;
        (sorted[mid - 1] + sorted[mid]) / 2
    } else {
        sorted[sorted.len() / 2]
    };
    
    let min = *sorted.first().unwrap();
    let max = *sorted.last().unwrap();
    let sum: i64 = sorted.iter().sum();
    let mean = sum / sorted.len() as i64;
    
    let p95_idx = (sorted.len() as f64 * 0.95) as usize;
    let p95 = sorted[p95_idx.min(sorted.len() - 1)];
    
    eprintln!("--- Statistics after {} transactions ---", count);
    eprintln!("Latency (created_at to receive) in milliseconds:");
    eprintln!("  Min: {}, Max: {}", min, max);
    eprintln!("  Mean: {}, Median: {}", mean, median);
    eprintln!("  P95: {}", p95);
    eprintln!("---");
}
```

**Important limitation:** This method only measures from when LaserStream created the message to when you received it. It doesn't account for any upstream delays between the blockchain event and LaserStream processing.

**Running the test:**

```bash
cargo run --bin timestamp-analysis
```

**Sample output:**

```
Transaction latency: 45ms
Transaction latency: 52ms
Transaction latency: 38ms
--- Statistics after 100 transactions ---
Latency (created_at to receive) in milliseconds:
  Min: 28, Max: 89
  Mean: 47, Median: 45
  P95: 72
---
```

This method provides insights into the network and processing latency between LaserStream and your application, but should be used in conjunction with Method 1 for comprehensive analysis.

***

## Best practices for latency testing

### Key principles

* **Co-location**: Deploy tests in the same region as your LaserStream endpoint to minimize network latency
* **Multiple methods**: Use parallel stream comparison (Method 1) as your primary metric, supplemented by timestamp analysis
* **Long-term monitoring**: Run tests over extended periods to capture different network conditions and blockchain congestion
* **Statistical analysis**: Focus on percentiles (P95, P99) rather than just averages to understand tail latency

### Interpreting results

1. **Establish baseline**: Run tests for at least 1 hour to establish baseline performance under normal conditions
2. **Identify patterns**: Look for patterns in latency spikes - do they correlate with high blockchain activity or network congestion?
3. **Compare percentiles**: P95 latency is often more important than average latency for user experience
4. **Monitor consistency**: Consistent performance is often more valuable than absolute minimum latency

Remember that blockchain latency is inherently variable due to network consensus requirements. Focus on relative performance differences and consistency over absolute numbers.


# LaserStream Historical Replay: Backfill Missing Data
Source: https://www.helius.dev/docs/laserstream/historical-replay

Recover from disconnections and backfill missing Solana blockchain data with LaserStream's historical replay feature. Never miss a transaction again.

<Info>
  **Never miss a beat**: LaserStream's Historical Replay ensures you can recover from disconnections and backfill missing data from the last 20 minutes of blockchain activity.
</Info>

## What is Historical Replay?

Historical Replay is LaserStream's feature that lets you replay recent blockchain data from up to 3000 slots in the past (approximately 20 minutes of blockchain activity). This is particularly useful for handling disconnections and ensuring data continuity in real-time applications.

<Warning>
  **Limited Time Window**: Historical replay is currently limited to the last 3000 slots (approximately 20 minutes of blockchain activity). You cannot replay data from arbitrary points in the past.
</Warning>

<CardGroup cols={2}>
  <Card title="Handle Disconnections" icon="clock-rotate-left">
    Recover data lost during brief disconnections (up to 20 minutes)
  </Card>

  <Card title="Bootstrap Applications" icon="rocket">
    Start applications with recent context from the last 20 minutes
  </Card>

  <Card title="Analyze Recent Events" icon="magnifying-glass">
    Review recent transactions and account changes
  </Card>

  <Card title="Test with Recent Data" icon="flask">
    Use real recent data for testing and development
  </Card>
</CardGroup>

## How It Works

<Steps>
  <Step title="Specify Starting Point">
    Use the `fromSlot` parameter to set your replay starting point (must be within last 3000 slots)
  </Step>

  <Step title="Stream Historical Data">
    LaserStream delivers all events from your specified slot forward
  </Step>

  <Step title="Catch Up to Real-Time">
    Historical data streams until you reach the current slot
  </Step>

  <Step title="Continue Live Streaming">
    Seamlessly transition to real-time data streaming
  </Step>
</Steps>

<Note>
  **Automatic Reconnection**: The [LaserStream SDK](https://github.com/helius-labs/laserstream-sdk) handles reconnections and replay automatically. No additional code required!
</Note>

## Quick Start

<Tabs>
  <Tab title="gRPC">
    ```typescript
    import { subscribe, CommitmentLevel, LaserstreamConfig, SubscribeRequest } from 'helius-laserstream';

    const subscriptionRequest: SubscribeRequest = {
      transactions: {
        client: {
          accountInclude: ['TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'],
          vote: false,
          failed: false
        }
      },
      commitment: CommitmentLevel.CONFIRMED,
      accounts: {},
      slots: {},
      blocks: {},
      blocksMeta: {},
      entry: {},
      accountsDataSlice: [],
      fromSlot: '224339000' // Start replay from this slot (must be within last 3000 slots)
    };

    const config: LaserstreamConfig = {
      apiKey: 'YOUR_API_KEY',
      endpoint: 'https://laserstream-mainnet-ewr.helius-rpc.com', // Choose your closest region
    };

    await subscribe(config, subscriptionRequest, 
      async (data) => {
        console.log('Received data:', data);
      }, 
      async (error) => {
        console.error('Error:', error);
      }
    );
    ```
  </Tab>

  <Tab title="WebSocket (Soon)">
    ```javascript
    const ws = new WebSocket('wss://laserstream-mainnet-ewr.helius-rpc.com/ws');

    const subscribeMessage = {
      jsonrpc: '2.0',
      id: 1,
      method: 'transactionSubscribe',
      params: {
        transactions: {
          client: {
            accountInclude: ['6EF8rrecthR5Dkzon8Nwu78hRvfCKubJ14M5uBEwF6P'],
            vote: false,
            failed: false
          }
        },
        commitment: 'confirmed',
        fromSlot: '224339000' // Start replay from this slot (must be within last 3000 slots)
      }
    };

    ws.onopen = () => {
      ws.send(JSON.stringify(subscribeMessage));
    };

    ws.onmessage = (event) => {
      const data = JSON.parse(event.data);
      console.log('Received data:', data);
    };
    ```
  </Tab>
</Tabs>

## Configuration Options

<ParamField path="fromSlot" type="string" required>
  The slot number to start replaying from. Must be within the replay window (last 3000 slots from current slot).

  **Example**: `"224339000"`

  **Important**: The slot must be recent enough to fall within the 20-minute replay window.
</ParamField>

## Use Cases

<AccordionGroup>
  <Accordion title="Reconnection After Brief Disconnection">
    When your application reconnects after a short disconnection (under 20 minutes), you can use Historical Replay to ensure no data is missed:

    ```typescript
    // Store the last processed slot
    let lastProcessedSlot = getLastProcessedSlot();

    // Check if the slot is still within the replay window
    const currentSlot = await getCurrentSlot();
    const maxReplaySlot = currentSlot - 3000;

    if (lastProcessedSlot < maxReplaySlot) {
      console.warn('Disconnection too long, some data may be lost');
      lastProcessedSlot = maxReplaySlot;
    }

    const subscriptionRequest: SubscribeRequest = {
      // ... your subscription config
      fromSlot: lastProcessedSlot.toString()
    };

    await subscribe(config, subscriptionRequest, 
      async (data) => {
        // Process data and update last processed slot
        await processData(data);
        lastProcessedSlot = data.slot;
        saveLastProcessedSlot(lastProcessedSlot);
      }
    );
    ```
  </Accordion>

  <Accordion title="Bootstrap with Recent Context">
    Start your application with recent context from the last few minutes:

    ```typescript
    // Get a slot from 10 minutes ago (within the 20-minute window)
    const currentSlot = await getCurrentSlot();
    const startSlot = currentSlot - 1500; // ~10 minutes ago

    const subscriptionRequest: SubscribeRequest = {
      // ... your subscription config
      fromSlot: startSlot.toString()
    };
    ```
  </Accordion>

  <Accordion title="Testing with Recent Data">
    Use recent historical data for testing (limited to last 20 minutes):

    ```typescript
    // Test with data from the last 5 minutes
    const currentSlot = await getCurrentSlot();
    const testStartSlot = currentSlot - 750; // ~5 minutes ago
    const testEndSlot = currentSlot - 150; // ~1 minute ago

    const subscriptionRequest: SubscribeRequest = {
      // ... your subscription config
      fromSlot: testStartSlot.toString()
    };

    // Stop processing when reaching test end slot
    await subscribe(config, subscriptionRequest, 
      async (data) => {
        if (data.slot >= testEndSlot) {
          // Stop processing
          return;
        }
        await processTestData(data);
      }
    );
    ```
  </Accordion>
</AccordionGroup>

## Next Steps

<CardGroup cols={1}>
  <Card title="LaserStream gRPC" icon="bolt" href="/laserstream/grpc">
    Learn more about gRPC streaming capabilities
  </Card>
</CardGroup>

<CardGroup cols={2}>
  <Card title="SDK Documentation" icon="github" href="https://github.com/helius-labs/laserstream-sdk">
    View the complete SDK documentation
  </Card>

  <Card title="Contact Support" icon="headset" href="/support">
    Get help with your implementation
  </Card>
</CardGroup>


# LaserStream vs Dedicated Nodes: Choosing the Right gRPC Solution
Source: https://www.helius.dev/docs/laserstream/laserstream-vs-dedicated-nodes

Compare LaserStream and Dedicated Nodes to choose the best gRPC streaming solution for your needs

<Warning>
  **LaserStream is the recommended choice for virtually all streaming use cases** due to its superior performance, enhanced reliability, managed infrastructure, and advanced features like historical replay and auto-reconnection.
</Warning>

## Quick Decision Guide

<CardGroup cols={2}>
  <Card title="Choose LaserStream" icon="bolt" color="#00D4AA">
    **Best for 99% of use cases**

    * Superior performance & reliability
    * Historical replay & auto-reconnection
    * Managed infrastructure
    * Multi-region support
  </Card>

  <Card title="Choose Dedicated Nodes" icon="server" color="#F59E0B">
    **Only if you specifically need**

    * No rate limits
    * No credits usage
    * Custom node configurations
  </Card>
</CardGroup>

***

## Feature Comparison

<Tabs>
  <Tab title="Performance & Reliability">
    <table>
      <thead>
        <tr>
          <th width="300">Feature</th>
          <th width="200">LaserStream</th>
          <th width="200">Dedicated Nodes</th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td><strong>Streaming Performance</strong></td>
          <td> **Superior optimized performance**</td>
          <td> **Can fail under high load**</td>
        </tr>

        <tr>
          <td><strong>Reliability</strong></td>
          <td> **Multi-node redundancy**</td>
          <td> **Single point of failure**</td>
        </tr>

        <tr>
          <td><strong>Uptime Guarantee</strong></td>
          <td> **Zero downtime risk**</td>
          <td> **Node failure risk**</td>
        </tr>

        <tr>
          <td><strong>Geographic Distribution</strong></td>
          <td> **Multiple regions worldwide**</td>
          <td> **Single location**</td>
        </tr>

        <tr>
          <td><strong>Network Support</strong></td>
          <td> **Mainnet + Devnet**</td>
          <td> **Single network only**</td>
        </tr>
      </tbody>
    </table>
  </Tab>

  <Tab title="Advanced Features">
    <table>
      <thead>
        <tr>
          <th width="300">Feature</th>
          <th width="200">LaserStream</th>
          <th width="200">Dedicated Nodes</th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td><strong>Historical Replay</strong></td>
          <td> **Up to 3000 slots (\~20 minutes)**</td>
          <td> **Not available**</td>
        </tr>

        <tr>
          <td><strong>Auto-Reconnection</strong></td>
          <td> **Built-in with SDK**</td>
          <td> **Manual implementation required**</td>
        </tr>

        <tr>
          <td><strong>Enhanced SDK</strong></td>
          <td> **Professional connection management**</td>
          <td> **Basic client only**</td>
        </tr>

        <tr>
          <td><strong>Archival Data Access</strong></td>
          <td> **Available via shared plan**</td>
          <td> **Not available**</td>
        </tr>
      </tbody>
    </table>
  </Tab>

  <Tab title="Platform Integration">
    <table>
      <thead>
        <tr>
          <th width="300">Feature</th>
          <th width="200">LaserStream</th>
          <th width="200">Dedicated Nodes</th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td><strong>Rate Limits</strong></td>
          <td> **Has rate limits**</td>
          <td> **No rate limits**</td>
        </tr>

        <tr>
          <td><strong>Credit Usage</strong></td>
          <td> **Has credits**</td>
          <td> **No credits**</td>
        </tr>

        <tr>
          <td><strong>sendTransaction</strong></td>
          <td> **Optimized landing rates**</td>
          <td> **Poor landing rates**</td>
        </tr>

        <tr>
          <td><strong>Platform Features</strong></td>
          <td> **APIs, webhooks included**</td>
          <td> **Requires separate shared plan**</td>
        </tr>
      </tbody>
    </table>
  </Tab>
</Tabs>

***

## Use Cases

<Tabs>
  <Tab title="LaserStream Ideal For">
    <CardGroup cols={2}>
      <Card title="High-Performance Trading" icon="chart-line">
        Real-time data feeds with superior performance and reliability
      </Card>

      <Card title="Production Applications" icon="shield-check">
        Mission-critical systems that need guaranteed uptime
      </Card>

      <Card title="Portfolio Tracking" icon="wallet">
        Account monitoring, balance updates, transaction history
      </Card>

      <Card title="DeFi Analytics" icon="coins">
        Protocol monitoring, yield farming data, liquidity tracking
      </Card>

      <Card title="NFT Applications" icon="image">
        Collection monitoring, marketplace data, trait analysis
      </Card>

      <Card title="Enterprise Solutions" icon="building">
        Professional applications requiring managed infrastructure
      </Card>
    </CardGroup>
  </Tab>

  <Tab title="Dedicated Nodes Limited Cases">
    <Warning>
      **Very limited use cases** - only suitable for specific requirements
    </Warning>

    <CardGroup cols={2}>
      <Card title="No Credits" icon="filter">
        When you don't want to deal with credits
      </Card>

      <Card title="No Rate Limits" icon="gauge">
        When you need unlimited request rates
      </Card>
    </CardGroup>

    <Note>
      **Important**: Dedicated nodes have significant limitations including performance risks, single points of failure, and higher costs.
    </Note>
  </Tab>
</Tabs>

***

## Pricing Comparison

<CardGroup cols={2}>
  <Card title="LaserStream" icon="bolt" color="#00D4AA">
    **Professional Plan: \$999/month**

    * 200M monthly credits included
    * 3 credits per 0.1MB of data
    * Transparent pay-per-use pricing
    * All platform features included
  </Card>

  <Card title="Dedicated Nodes" icon="server" color="#F59E0B">
    **Starting at \$2,300+/month**

    * Node cost varies by specifications
    * Shared plan required for full features
    * Higher total cost for most use cases
  </Card>
</CardGroup>

***

## Technical Implementation

<Tabs>
  <Tab title="LaserStream">
    **Simple integration with enhanced features**

    ```typescript
    import { subscribe, LaserstreamConfig } from 'helius-laserstream';

    const config: LaserstreamConfig = {
      apiKey: 'your-api-key',
      endpoint: 'https://laserstream-mainnet-ewr.helius-rpc.com'
    };

    // Automatic reconnection and historical replay
    await subscribe(config, subscriptionRequest, handleData, handleError);
    ```

    <Info>
      **Key Benefits**: Built-in reconnection, historical replay, and professional error handling
    </Info>
  </Tab>

  <Tab title="Dedicated Nodes">
    **Manual connection management required**

    ```typescript
    import { Client } from '@yellowstone-grpc/client';

    const client = new Client(endpoint, undefined, {
      'grpc.keepalive_time_ms': 30000,
      // Custom connection settings...
    });

    // Manual reconnection logic needed
    client.on('error', (error) => {
      // Implement your own reconnection strategy
    });
    ```

    <Warning>
      **Additional Work Required**: You need to implement your own reconnection logic, error handling, and connection management
    </Warning>
  </Tab>
</Tabs>

***

## Decision Framework

<Steps>
  <Step title="Assess Your Needs">
    Do you need the best streaming performance and reliability?

    * **Yes**  LaserStream
    * **No**  Continue to next step
  </Step>

  <Step title="Infrastructure Preference">
    Do you want to focus on your application, not infrastructure management?

    * **Yes**  LaserStream
    * **No**  Continue to next step
  </Step>

  <Step title="Advanced Features">
    Do you need historical replay or auto-reconnection?

    * **Yes**  LaserStream
    * **No**  Continue to next step
  </Step>

  <Step title="Rate Limits & Credits">
    Do you specifically need no rate limits and no credits usage?

    * **Yes**  Consider Dedicated Nodes (but weigh the significant downsides)
    * **No**  LaserStream
  </Step>
</Steps>

***

## Getting Started

<CardGroup cols={2}>
  <Card title="Start with LaserStream" icon="bolt" href="/laserstream">
    Get started with LaserStream's enhanced gRPC streaming
  </Card>

  <Card title="Explore Dedicated Nodes" icon="server" href="/dedicated-nodes">
    Learn about dedicated node options and specifications
  </Card>
</CardGroup>

## Need Help Deciding?

<CardGroup cols={1}>
  <Card title="Join Discord Community" icon="discord" href="https://discord.com/invite/6GXdee3gBj">
    Get real-time help from our community and team
  </Card>
</CardGroup>

<Tip>
  **Pro Tip**: Most users find LaserStream meets their needs perfectly. Start there unless you specifically need no rate limits or credits.
</Tip>


# Helius MCP: AI-Powered Solana Development Documentation
Source: https://www.helius.dev/docs/mcp

Connect AI tools directly to Helius Solana API documentation for intelligent code generation and contextual development assistance.

<Info>
  **AI-Native Development**: Use the Helius MCP server to give AI tools access to our documentation, enabling contextual code generation and intelligent assistance.
</Info>

## What is MCP?

Model Context Protocol (MCP) is a standard that allows AI applications to access external documentation and data sources. Think of it as a bridge that lets AI tools like Claude, Cursor, and Windsurf read your documentation in real-time to provide better, more accurate assistance.

<CardGroup cols={2}>
  <Card title="Real-time Context" icon="bolt">
    AI tools can query live documentation and API specifications for accurate, up-to-date information
  </Card>

  <Card title="Code Generation" icon="code">
    AI generates working code examples using current API methods and best practices from our docs
  </Card>

  <Card title="Interactive Development" icon="robot">
    Ask questions about Helius APIs and get contextual answers based on our documentation
  </Card>

  <Card title="Seamless Integration" icon="plug">
    Works with popular AI-powered IDEs and development tools
  </Card>
</CardGroup>

## How Helius MCP Works

The Helius MCP server automatically provides AI tools with access to:

* **Complete API Documentation**: All Helius API methods, parameters, and examples
* **Code Examples**: Working implementations for common use cases
* **Best Practices**: Recommended patterns for using Helius services
* **Real-time Updates**: Always current with the latest documentation changes

<Note>
  **Automatic Generation**: Our MCP server is automatically generated from our documentation and API specifications, ensuring it's always up-to-date with the latest features and changes.
</Note>

## Getting Started

<Steps>
  <Step title="Install MCP Support">
    First, make sure your AI tool supports MCP. Popular options include:

    * **Cursor**: Built-in MCP support
    * **Windsurf**: Native MCP integration
    * **Claude Desktop**: MCP server support
    * **VS Code**: via MCP extensions
  </Step>

  <Step title="Add Helius MCP Server">
    Install the Helius MCP server in your development environment:

    ```bash
    npx mint-mcp add helius
    ```

    This automatically configures your MCP client to access Helius documentation for AI assistance.
  </Step>

  <Step title="Start Using AI with Helius Context">
    Open your AI-powered IDE and start asking questions about Helius APIs. The AI will automatically query our MCP server for accurate, contextual documentation to help generate code.
  </Step>
</Steps>

## Quick Test

Want to see it in action? Here's the fastest way to test the Helius MCP integration:

<Tabs>
  <Tab title="Cursor">
    1. Open Cursor IDE
    2. Open a terminal and run: `npx mint-mcp add helius`
    3. Open Agent mode (Ctrl/Cmd + K)
    4. Ask: "Write a Node.js script for sending transactions using Helius"
    5. The AI will reference our documentation via MCP to generate accurate code
    6. Watch as the AI generates working code using current Helius API patterns from our docs
  </Tab>

  <Tab title="Windsurf">
    1. Open Windsurf IDE
    2. Run: `npx mint-mcp add helius` in terminal
    3. Open the AI assistant
    4. Ask: "Show me how to get NFT data using Helius DAS API"
    5. The AI will reference our docs via MCP and generate code with proper imports and error handling
  </Tab>

  <Tab title="Claude Desktop">
    1. Install Claude Desktop
    2. Run: `npx mint-mcp add helius`
    3. Open Claude and ask: "Help me build a Solana transaction monitor with Helius"
    4. Get contextual responses with working code examples based on our documentation
  </Tab>
</Tabs>

## Use Cases

<AccordionGroup>
  <Accordion title="Rapid Prototyping">
    **Scenario**: You need to quickly build a demo that fetches NFT data and displays it.

    **With MCP**: Ask your AI tool "Create a React component that fetches and displays NFTs for a wallet using Helius DAS API"

    **Result**: Get a complete component with proper error handling, loading states, and current API usage.
  </Accordion>

  <Accordion title="API Integration">
    **Scenario**: Integrating Helius websockets into your application.

    **With MCP**: "Show me how to set up Helius websockets for monitoring account changes"

    **Result**: Complete websocket setup code with proper connection handling and real-time updates.
  </Accordion>

  <Accordion title="Documentation Generation">
    **Scenario**: Need to document your Helius integration for your team.

    **With MCP**: "Generate documentation for our Helius RPC usage patterns"

    **Result**: Comprehensive docs with code examples and best practices.
  </Accordion>

  <Accordion title="Debugging & Optimization">
    **Scenario**: Your Helius API calls are failing or performing poorly.

    **With MCP**: "Help me optimize these Helius API calls and handle errors properly"

    **Result**: Improved code with proper error handling and performance optimizations.
  </Accordion>
</AccordionGroup>

## Example Workflows

### Building a Transaction Monitor

```typescript
// Ask your AI: "Create a transaction monitor using Helius websockets"
// The AI will generate something like this with current API patterns:

const WebSocket = require('ws');

// Create WebSocket connection
const ws = new WebSocket('wss://mainnet.helius-rpc.com/?api-key=YOUR_API_KEY');

ws.on('open', function open() {
  console.log('WebSocket connected');
  
  // Subscribe to account changes
  const request = {
    jsonrpc: "2.0",
    id: 1,
    method: "accountSubscribe",
    params: [
      "YOUR_WALLET_ADDRESS",
      {
        encoding: "jsonParsed",
        commitment: "confirmed"
      }
    ]
  };
  
  ws.send(JSON.stringify(request));
});

ws.on('message', function incoming(data) {
  const message = JSON.parse(data.toString());
  console.log('Account update:', message);
});
```

### NFT Portfolio Tracker

```typescript
// Ask: "Build an NFT portfolio tracker using Helius DAS API"
// Get working code with current method signatures:

const getNFTPortfolio = async (walletAddress: string) => {
  const response = await fetch(`https://mainnet.helius-rpc.com/?api-key=${API_KEY}`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      jsonrpc: '2.0',
      id: 'my-id',
      method: 'getAssetsByOwner',
      params: {
        ownerAddress: walletAddress,
        page: 1,
        limit: 1000
      },
    }),
  });
  
  const data = await response.json();
  return data.result;
};
```

## Advanced Features

<Tabs>
  <Tab title="Context-Aware Suggestions">
    The MCP server provides documentation context so AI tools can make intelligent suggestions:

    * **API Method Selection**: AI recommends the most appropriate Helius API based on our docs
    * **Error Handling**: AI suggests proper error handling patterns from our documentation
    * **Performance Tips**: AI identifies optimization opportunities using our best practices
  </Tab>

  <Tab title="Multi-API Orchestration">
    Get help combining multiple Helius services:

    ```typescript
    // Ask: "Combine RPC, DAS, and websocket APIs to build a complete NFT marketplace backend"
    // The AI understands how these services work together from our documentation
    ```
  </Tab>

  <Tab title="Real-time Updates">
    The MCP server stays current with our documentation for:

    * New API endpoints and methods
    * Updated parameter requirements
    * Latest SDK versions and features
    * Current best practices and patterns
  </Tab>
</Tabs>

## Supported AI Tools

| Tool               | Support Level         | Setup Difficulty | Best For                   |
| ------------------ | --------------------- | ---------------- | -------------------------- |
| **Cursor**         |  Native              | Easy             | Full-stack development     |
| **Windsurf**       |  Native              | Easy             | AI-assisted coding         |
| **Claude Desktop** |  Supported           | Medium           | Documentation and planning |
| **VS Code**        |  Extension Required | Medium           | Existing VS Code workflows |

## Best Practices

<CardGroup cols={2}>
  <Card title="Be Specific" icon="bullseye">
    Ask specific questions like "How do I paginate through NFT results?" rather than "Help with NFTs"
  </Card>

  <Card title="Include Context" icon="info">
    Mention your tech stack: "Using Next.js and TypeScript, show me how to..."
  </Card>

  <Card title="Iterate Quickly" icon="arrow-right">
    Use the generated code as a starting point and ask for modifications
  </Card>

  <Card title="Test Generated Code" icon="flask">
    Always test AI-generated code in your development environment
  </Card>
</CardGroup>

## Troubleshooting

<AccordionGroup>
  <Accordion title="MCP Server Not Found">
    **Issue**: AI tool can't find the Helius MCP server

    **Solution**:

    1. Re-run `npx mint-mcp add helius`
    2. Restart your AI tool
    3. Check that MCP is enabled in your tool's settings
  </Accordion>

  <Accordion title="Outdated Information">
    **Issue**: AI is providing outdated API information

    **Solution**:

    1. The MCP server auto-updates, but you may need to refresh your AI session
    2. Clear your AI tool's cache if available
    3. Ask specifically for "the latest" information
  </Accordion>

  <Accordion title="Generated Code Doesn't Work">
    **Issue**: AI-generated code has errors or doesn't run

    **Solution**:

    1. Share the error message with the AI for debugging
    2. Ask for error handling improvements
    3. Verify your API key and network connectivity
  </Accordion>
</AccordionGroup>

## Learn More

<CardGroup cols={2}>
  <Card title="MCP Specification" icon="book" href="https://modelcontextprotocol.io/">
    Learn about the Model Context Protocol standard
  </Card>

  <Card title="Helius APIs" icon="code" href="/api-reference">
    Explore all available Helius APIs and endpoints
  </Card>

  <Card title="SDK Documentation" icon="code" href="/sdks">
    Official SDKs for different programming languages
  </Card>

  <Card title="Join Discord" icon="discord" href="https://discord.com/invite/6GXdee3gBj">
    Get help from our developer community
  </Card>
</CardGroup>

Ready to supercharge your development workflow? Install the Helius MCP server and start building with AI assistance today!


# Solana Compressed NFT Event Listening
Source: https://www.helius.dev/docs/nfts/cnft-event-listening

Learn how to listen for and retrieve Solana compressed NFT events using Helius APIs. WebSockets, webhooks, gRPC streaming, and real-time cNFT monitoring.

### 1. Understanding cNFTs and Their Event Lifecycle

On Solana, [**Compressed NFTs (cNFTs)**](./) differ from traditional NFTs in a crucial way:

* **Traditional NFTs** each have their own mint address and token account.
* **Compressed NFTs** store data within a **Merkle tree** managed by the **related cNFT** program. This single on-chain account holds the Merkle tree root, and each NFT is represented as a leaf in that tree.

#### Key Points:

* A **cNFT mint** adds a new leaf.
* A **cNFT transfer** updates the ownership data in the existing leaf.
* A **cNFT burn** removes or invalidates the leaf from the tree.

Because cNFTs lack typical token accounts, standard Solana NFT tracking methods (e.g., "watch the mint address" or "subscribe to a token account") won't work. Instead, you focus on program instructions or the **Merkle tree** account.

***

### 2. Why listen for cNFT Events?

Imagine building a marketplace, wallet, or analytics dashboard around cNFTs. You need to know:

* When new cNFTs are minted.
* Which cNFTs are transferred to or from a user.
* Whether a cNFT was burned.

Receiving these updates in **real time** helps you keep your interface or data layer in perfect sync with on-chain state. Combined with **historical** lookups, you gain a complete timeline of cNFT activity, from the moment it was created to its current status.

***

### 3. Event Listening Methods

Helius offers **three major** ways to listen for cNFT events:

* **Standard WebSockets**: Simple persistent connection for basic program monitoring
* **Enhanced WebSockets**: Advanced filtering with better transaction targeting
* **gRPC (Yellowstone)**: Maximum performance and flexibility via LaserStream or Dedicated Nodes

Choose based on your needs: Standard WebSockets for simplicity, Enhanced WebSockets for better filtering, or gRPC for enterprise-scale applications with the highest performance.

#### 3.1 Standard WebSockets

[**Standard WebSockets**](/rpc/websocket)

* **Persistent connection**: You subscribe to accounts or programs, and Solana pushes updates.

```js [expandable]
const WebSocket = require('ws');

// Replace <API_KEY> with your actual API key
const HELIUS_WS_URL = 'wss://mainnet.helius-rpc.com/?api-key=<API_KEY>';
const ws = new WebSocket(HELIUS_WS_URL);

// Keep connection alive with periodic pings
function startPing(ws) {
  setInterval(() => {
    if (ws.readyState === WebSocket.OPEN) {
      ws.ping();
    }
  }, 30000); // Ping every 30 seconds
}

ws.on('open', () => {
  console.log('Connected to Helius WebSocket');
  
  // Start pinging to keep connection alive
  startPing(ws);

  // Subscribe to the Bubblegum program to catch cNFT events
  const subscribeMsg = {
    jsonrpc: '2.0',
    id: 1,
    method: 'programSubscribe',
    params: [
      'BGUMAp9Gq7iTEuizy4pqaxsTyUCBK68MDfK752saRPUY', // Bubblegum program ID
      { 
        commitment: 'confirmed',
        encoding: 'jsonParsed'
      }
    ]
  };

  ws.send(JSON.stringify(subscribeMsg));
});

ws.on('message', (rawData) => {
  try {
    const data = JSON.parse(rawData);
    console.log('New cNFT event:', data);
    
    // Check if this is a subscription result or notification
    if (data.method === 'programNotification') {
      console.log('Program notification received:', data.params);
      // Parse for mints/transfers/burns in the instruction data
    }
  } catch (err) {
    console.error('Failed to parse WS message:', err);
  }
});

ws.on('error', (err) => {
  console.error('WebSocket error:', err);
});

ws.on('close', () => {
  console.log('WebSocket closed');
});
```

#### 3.2 Enhanced WebSockets

[**Enhanced WebSockets**](/enhanced-websockets)

* **Enhanced** WebSocket with advanced filters (`accountInclude`, `accountRequired`, etc.).
* **Reduces parsing overhead** because you only receive transactions relevant to your addresses.
* **Real-time filtering** ensures you only get the transactions you care about.

```js [expandable]
const WebSocket = require('ws');

// Note: No /? in the URL, just ?
const HELIUS_ENHANCED_WS_URL = 'wss://atlas-mainnet.helius-rpc.com?api-key=<API_KEY>';
const ws = new WebSocket(HELIUS_ENHANCED_WS_URL);

ws.on('open', () => {
  console.log('Connected to Enhanced WebSocket');
  
  // Send subscription request
  const subscribeRequest = {
    jsonrpc: '2.0',
    id: 420,
    method: 'transactionSubscribe',
    params: [
      // Filter object
      {
        failed: false,
        vote: false,
        accountInclude: ['MERKLE_TREE_ADDRESS'] // Replace with your Merkle tree address
      },
      // Options object
      {
        commitment: 'confirmed',
        encoding: 'jsonParsed',
        transactionDetails: 'full',
        showRewards: false,
        maxSupportedTransactionVersion: 0
      }
    ]
  };

  ws.send(JSON.stringify(subscribeRequest));
  
  // Keep connection alive with periodic pings
  setInterval(() => {
    if (ws.readyState === WebSocket.OPEN) {
      ws.ping();
      console.log('Ping sent');
    }
  }, 30000); // Ping every 30 seconds
});

ws.on('message', (data) => {
  const messageStr = data.toString('utf8');
  try {
    const payload = JSON.parse(messageStr);
    const result = payload.params?.result;
    
    if (!result) {
      console.log('Subscription confirmation:', payload);
      return;
    }

    console.log('Enhanced cNFT transaction detected!');
    console.log('Signature:', result.signature);
    console.log('Slot:', result.slot);
    
    // Check transaction logs for cNFT operations
    const logs = result.transaction?.meta?.logMessages || [];
    const hasBubblegumLogs = logs.some(log => 
      log.includes('BGUMAp9Gq7iTEuizy4pqaxsTyUCBK68MDfK752saRPUY')
    );
    
    if (hasBubblegumLogs) {
      console.log('Bubblegum program interaction detected - likely cNFT operation');
      console.log('Transaction logs:', logs);
    }

    // Access transaction instructions
    const instructions = result.transaction?.transaction?.message?.instructions || [];
    instructions.forEach((instruction, index) => {
      console.log(`Instruction ${index}:`, instruction);
    });

  } catch (err) {
    console.error('Failed to parse Enhanced WS message:', err);
  }
});

ws.on('error', (err) => {
  console.error('Enhanced WebSocket error:', err);
});

ws.on('close', () => {
  console.log('Enhanced WebSocket closed');
});
```

**For monitoring specific cNFT programs:**

```js [expandable]
// Monitor Bubblegum program directly
const BUBBLEGUM_PROGRAM_ID = 'BGUMAp9Gq7iTEuizy4pqaxsTyUCBK68MDfK752saRPUY';

const subscribeRequest = {
  jsonrpc: '2.0',
  id: 420,
  method: 'transactionSubscribe',
  params: [
    {
      failed: false,
      vote: false,
      accountInclude: [BUBBLEGUM_PROGRAM_ID] // Monitor all Bubblegum transactions
    },
    {
      commitment: 'confirmed',
      encoding: 'jsonParsed',
      transactionDetails: 'full',
      maxSupportedTransactionVersion: 0
    }
  ]
};
```

***

#### 3.3 Webhooks

[**Webhooks**](/webhooks) let Helius notify your server via HTTP POST whenever an on-chain event occurs. Ideal if you **don't want** a persistent connection.

1. **Create** the webhook via [API](/api-reference/webhooks/create-webhook), [SDK](/sdks) or [Dashboard](https://dashboard.helius.dev).
2. **Specify** addresses to watch (Merkle tree address, user wallet, etc.).
3. **Receive** transaction data on your server endpoint; parse for cNFT instructions.

**Creating a Webhook** (API Example):

```bash
curl -X POST \
  -H "Content-Type: application/json" \
  -d '{
    "webhookURL": "https://myapp.com/cnft-webhook",
    "transactionTypes": ["ANY"],
    "accountAddresses": ["MERKLE_TREE_ADDRESS"],
    "webhookType": "enhanced",
    "authHeader": "Bearer your-auth-token",
    "txnStatus": "all",
    "encoding": "jsonParsed"
  }' \
  "https://api.helius.xyz/v0/webhooks?api-key=<YOUR_API_KEY>"
```

**JavaScript Example:**

```js [expandable]
const fetch = require('node-fetch');

async function createCNFTWebhook() {
  const webhookData = {
    webhookURL: 'https://myapp.com/cnft-webhook',
    transactionTypes: ['ANY'], // Monitor all transaction types
    accountAddresses: ['MERKLE_TREE_ADDRESS'], // Replace with your Merkle tree address
    webhookType: 'enhanced', // Get parsed transaction data
    authHeader: 'Bearer your-auth-token', // Optional: secure your webhook
    txnStatus: 'all', // Monitor both success and failed transactions
    encoding: 'jsonParsed'
  };

  const response = await fetch('https://api.helius.xyz/v0/webhooks?api-key=<YOUR_API_KEY>', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify(webhookData),
  });

  if (!response.ok) {
    throw new Error(`HTTP error! status: ${response.status}`);
  }

  const webhook = await response.json();
  console.log('Webhook created:', webhook);
  return webhook;
}

createCNFTWebhook().catch(console.error);
```

**Webhook Payload Structure:**

When your webhook endpoint receives a notification, it will contain structured data like:

```json [expandable]
{
  "accountData": [
    {
      "account": "MERKLE_TREE_ADDRESS",
      "nativeBalanceChange": 0,
      "tokenBalanceChanges": []
    }
  ],
  "description": "Compressed NFT Mint",
  "events": {
    "compressed": {
      "type": "COMPRESSED_NFT_MINT",
      "treeId": "MERKLE_TREE_ADDRESS",
      "assetId": "...",
      "leafIndex": 12,
      "instructionIndex": 1,
      "newLeafOwner": "UserWalletAddress"
    }
  },
  "fee": 5000,
  "feePayer": "PAYER_ADDRESS",
  "signature": "TRANSACTION_SIGNATURE",
  "slot": 1234567,
  "timestamp": 1234567890000,
  "type": "COMPRESSED_NFT_MINT"
}
```

***

#### 3.4 gRPC (Yellowstone)

[**gRPC**](/grpc) is the most flexible and high-performance event listening solution, available through [**LaserStream**](/laserstream) or [**Dedicated Nodes**](/dedicated-nodes).

* **Advanced filtering** (memcmp, owners, accounts, etc.).
* **Enterprise-level** throughput for large-scale apps.
* **LaserStream**: Multi-tenant gRPC service with automatic failover and historical replay.
* **Dedicated Nodes**: Exclusive gRPC endpoint with guaranteed resource isolation.

**Complete Example** (TypeScript with robust stream management):

```bash
# First install dependencies
npm install @triton-one/yellowstone-grpc
npm install typescript @types/node --save-dev
```

```ts [expandable]
import Client, { CommitmentLevel, SubscribeRequest } from "@triton-one/yellowstone-grpc";

class CNFTStreamManager {
  private client: Client;
  private stream: any;
  private isConnected = false;
  private reconnectAttempts = 0;
  private readonly maxReconnectAttempts = 10;
  private readonly baseReconnectDelay = 1000;

  constructor(
    private endpoint: string,
    private apiKey: string,
    private onCNFTEvent: (data: any) => void
  ) {
    this.client = new Client(endpoint, apiKey, {
      "grpc.max_receive_message_length": 64 * 1024 * 1024
    });
  }

  async connect(merkleTreeAddress: string): Promise<void> {
    try {
      console.log(`Connecting to gRPC endpoint: ${this.endpoint}`);
      
      const subscribeRequest: SubscribeRequest = {
        commitment: CommitmentLevel.CONFIRMED,
        accounts: {
          merkleTreeAccount: {
            account: [merkleTreeAddress],
            owner: [],
            filters: []
          }
        },
        accountsDataSlice: [],
        transactions: {
          cnftTransactions: {
            accountInclude: [merkleTreeAddress],
            accountExclude: [],
            accountRequired: [],
            vote: false,
            failed: false
          }
        },
        blocks: {},
        blocksMeta: {},
        entry: {},
        slots: {},
        transactionsStatus: {},
        ping: { id: 1 } // Keep connection alive
      };

      this.stream = await this.client.subscribe();
      
      this.stream.on("data", (data: any) => {
        if (data.account) {
          console.log("Merkle tree account update:", data.account);
          this.onCNFTEvent({
            type: 'account_update',
            account: data.account
          });
        }
        
        if (data.transaction) {
          console.log("Transaction involving cNFT:", data.transaction.signature);
          this.onCNFTEvent({
            type: 'transaction',
            transaction: data.transaction
          });
        }
      });

      this.stream.on("error", (error: any) => {
        console.error("Stream error:", error);
        this.handleReconnect();
      });

      this.stream.on("close", () => {
        console.log("Stream closed");
        this.isConnected = false;
      });

      // Send subscription request
      await this.writeRequest(subscribeRequest);
      this.isConnected = true;
      this.reconnectAttempts = 0;
      
      console.log("Successfully connected to gRPC stream");
      
    } catch (error) {
      console.error("Failed to connect:", error);
      this.handleReconnect();
    }
  }

  private async writeRequest(request: SubscribeRequest): Promise<void> {
    return new Promise((resolve, reject) => {
      this.stream.write(request, (err: any) => {
        if (err) {
          reject(err);
        } else {
          resolve();
        }
      });
    });
  }

  private async handleReconnect(): Promise<void> {
    if (this.reconnectAttempts >= this.maxReconnectAttempts) {
      console.error("Max reconnection attempts reached");
      return;
    }

    this.reconnectAttempts++;
    const delay = this.baseReconnectDelay * Math.pow(2, this.reconnectAttempts - 1);
    
    console.log(`Reconnecting in ${delay}ms... (attempt ${this.reconnectAttempts})`);
    
    setTimeout(() => {
      this.connect("MERKLE_TREE_ADDRESS").catch(console.error);
    }, delay);
  }

  disconnect(): void {
    if (this.stream) {
      this.stream.end();
    }
    this.client.close();
    this.isConnected = false;
  }
}

// Usage example
async function monitorCNFTTree() {
  const endpoint = "https://laserstream-mainnet-ewr.helius-rpc.com"; // Choose your region
  const apiKey = "your-api-key";
  const merkleTreeAddress = "MERKLE_TREE_ADDRESS";

  const manager = new CNFTStreamManager(
    endpoint,
    apiKey,
    (eventData) => {
      console.log("cNFT Event received:", eventData);
      
      // Process different event types
      if (eventData.type === 'account_update') {
        console.log("Merkle tree state changed");
        // Handle account update - tree root may have changed
      } else if (eventData.type === 'transaction') {
        console.log("Transaction affecting cNFT detected");
        // Parse transaction for mint/transfer/burn operations
      }
    }
  );

  await manager.connect(merkleTreeAddress);
  
  // Keep running until interrupted
  process.on('SIGINT', () => {
    console.log("Shutting down...");
    manager.disconnect();
    process.exit(0);
  });
}

monitorCNFTTree().catch(console.error);
```

***

### 4. Retrieving Historical cNFT Data

Real-time event feeds are great for capturing **future** events. But what if you need the **past**the entire lifetime of a cNFT or all transactions that impacted a Merkle tree or wallet?

In this section, we'll explore **two** primary methods for historical lookups:

1. Helius' Parsed Transaction API
2. Normal Solana RPC Calls: `getSignaturesForAddress` + `getParsedTransaction` or `getTransaction`

***

#### 4.1 Helius' Enhanced Transaction API

Helius offers an **Enhanced** Transaction API. It automatically decodes NFT, SPL, and Swap transactions into a human-readable format. This saves you from manually parsing raw data.

**4.1.1 Single or Batched Transactions (**[**`/v0/transactions`**](/api-reference/enhanced-transactions/gettransactions)**)**

**Endpoint**:

* **Mainnet**: `https://api.helius.xyz/v0/transactions?api-key=<YOUR_API_KEY>`
* **Devnet**: `https://api-devnet.helius.xyz/v0/transactions?api-key=<YOUR_API_KEY>`

You send up to **100** transaction signatures in the request body, and Helius returns an **array** of parsed transactions.

**Example**:

```js [expandable]
async function parseMultipleTransactions(signatures) {
  const url = 'https://api.helius.xyz/v0/transactions?api-key=<YOUR_API_KEY>';

  const response = await fetch(url, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ 
      transactions: signatures,
      commitment: 'confirmed' // Optional: specify commitment level
    })
  });

  if (!response.ok) {
    throw new Error(`HTTP error! status: ${response.status}`);
  }

  const parsedTxs = await response.json();
  
  // Filter for cNFT-related transactions
  const cnftTransactions = parsedTxs.filter(tx => {
    return tx.events && tx.events.compressed;
  });

  console.log("Parsed cNFT transactions:", JSON.stringify(cnftTransactions, null, 2));
  return cnftTransactions;
}

// Usage with error handling
parseMultipleTransactions([
  "5rfFLBUp5YPr6rC2g1KBBW8LGZBcZ8Lvs7gKAdgrBjmQvFf6EKkgc5cpAQUTwGxDJbNqtLYkjV5vS5zVK4tb6JtP",
  "4jzQxVTaJ4Fe4Fct9y1aaT9hmVyEjpCqE2bL8JMnuLZbzHZwaL4kZZvNEZ6bEj6fGmiAdCPjmNQHCf8v994PAgDf"
]).catch(console.error);
```

Within each parsed transaction, you may find a `compressed` object under `events`, indicating a cNFT mint, transfer, or burn:

```json [expandable]
"compressed": {
  "type": "COMPRESSED_NFT_MINT",
  "treeId": "MERKLE_TREE_ADDRESS",
  "assetId": "...",
  "leafIndex": 12,
  "instructionIndex": 1,
  "newLeafOwner": "UserWalletAddress",
  ...
}
```

**4.1.2 Parsed Transactions by Address (**[**`/v0/addresses/{address}/transactions`**](/api-reference/enhanced-transactions/gettransactionsbyaddress)**)**

If you want **parsed** transactions for a **specific** addresssay a **Merkle tree** or **user wallet**you can call:

* **Mainnet**: `https://api.helius.xyz/v0/addresses/{address}/transactions?api-key=<YOUR_API_KEY>`
* **Devnet**: `https://api-devnet.helius.xyz/v0/addresses/{address}/transactions?api-key=<YOUR_API_KEY>`

**Example**:

```js [expandable]
async function getParsedHistoryForAddress(address) {
  // Add pagination support and error handling
  const url = `https://api.helius.xyz/v0/addresses/${address}/transactions?api-key=<YOUR_API_KEY>&limit=50`;

  const response = await fetch(url);
  if (!response.ok) {
    throw new Error(`HTTP error! status: ${response.status}`);
  }

  const parsedHistory = await response.json();
  
  // Filter for cNFT-related transactions
  const cnftTransactions = parsedHistory.filter(tx => {
    return tx.events && tx.events.compressed;
  });

  console.log("Parsed cNFT history:", JSON.stringify(cnftTransactions, null, 2));

  // Example of pagination - get next page if needed
  if (parsedHistory.length === 50) {
    const lastSignature = parsedHistory[parsedHistory.length - 1].signature;
    console.log(`More transactions available. Use before=${lastSignature} for next page`);
  }

  return cnftTransactions;
}

// Usage with error handling
getParsedHistoryForAddress("MERKLE_TREE_ADDRESS_OR_USER_WALLET").catch(console.error);
```

***

#### 4.2 Normal Methods: `getSignaturesForAddress` + `getParsedTransaction` / `getTransaction`

If you prefer the **traditional Solana approach** or want maximum control, you can call **Solana's native RPC** methods:

1. **`getSignaturesForAddress`**: Returns an array of transaction signatures involving the given address (e.g., the Merkle tree or user's wallet).
2. **`getParsedTransaction`**: Returns a **Solana-parsed** JSON for a given signature.
3. **`getTransaction`**: Returns the **raw** binary-encoded transaction, which you can parse using an external library (e.g., [Blockbuster](https://github.com/helius-labs/blockbuster)) if you need specialized cNFT decoding.

**4.2.1 `getSignaturesForAddress`**

This is a **pagination-friendly** method. You can pass `before` or `until` parameters.

**Example**:

```js [expandable]
async function fetchSignatures(address, limit = 10) {
  const rpcUrl = "https://mainnet.helius-rpc.com/?api-key=<YOUR_API_KEY>";
  const body = {
    jsonrpc: "2.0",
    id: 1,
    method: "getSignaturesForAddress",
    params: [
      address,
      { 
        limit: limit,
        commitment: "confirmed"
      }
    ]
  };

  const response = await fetch(rpcUrl, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(body)
  });

  if (!response.ok) {
    throw new Error(`HTTP error! status: ${response.status}`);
  }

  const data = await response.json();
  
  if (data.error) {
    throw new Error(`RPC error: ${data.error.message}`);
  }

  console.log("Signatures for address:", data.result);
  return data.result;
}

// Usage with error handling
fetchSignatures("MERKLE_TREE_ADDRESS").catch(console.error);
```

**4.2.2 `getParsedTransaction` or `getTransaction`**

Once you have the signatures, retrieve each transaction's details:

```js [expandable]
async function fetchTransaction(signature, encoding = "jsonParsed") {
  const rpcUrl = "https://mainnet.helius-rpc.com/?api-key=<YOUR_API_KEY>";
  const body = {
    jsonrpc: "2.0",
    id: 1,
    method: "getTransaction",
    params: [
      signature, 
      {
        encoding: encoding,
        commitment: "confirmed",
        maxSupportedTransactionVersion: 0
      }
    ]
  };

  const response = await fetch(rpcUrl, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(body)
  });

  if (!response.ok) {
    throw new Error(`HTTP error! status: ${response.status}`);
  }

  const data = await response.json();
  
  if (data.error) {
    throw new Error(`RPC error: ${data.error.message}`);
  }

  console.log("Transaction:", JSON.stringify(data.result, null, 2));
  return data.result;
}

// Usage:
fetchTransaction("TransactionSignature").catch(console.error);
```

Look for instructions referencing the **cNFT** program or the **Merkle tree**. If you use `getTransaction` instead, you'll get raw data (e.g., base64), which you'd decode with a specialized parser.

***

### 5. Putting It All Together

1. **Listen for cNFT Events**
   * Pick a method: WebSockets, Webhooks, or gRPC.
   * Filter for the **cNFT** program or a **Merkle tree** address.
   * Parse instructions in real time to track mints, transfers, and burns.
2. **Retrieve Historical Data**
   * **Helius Enhanced Transaction API**: The easiest way to get a human-readable breakdown of cNFT actions.
   * **Normal RPC**: `getSignaturesForAddress` + `getParsedTransaction` (or `getTransaction` + manual parsing) for maximum flexibility or if you already rely on standard Solana RPC calls.
3. **Build a Complete Timeline**
   * Merge **future** (real-time) events with **past** (historical) data.
   * If your event listening solution ever goes down, fill gaps by pulling recent transaction signatures for your Merkle tree or user address.

***

### 6. Next Steps and Best Practices

* **Leverage Helius**: The **Enhanced Transaction API** is particularly handy if you want cNFT events (mints, transfers, burns) in a straightforward JSON format.
* **Pagination**: For addresses with a lot of activity, you may need to iterate with `before` or `until` to get older data.
* **Verification**: For extra security, you can verify Merkle proofs to confirm a cNFT leaf is valid under the on-chain root.
* **Indexing**: If you're building a large-scale solution, consider storing parsed cNFT events in your own database for quick queries.
* **Performance**: For high-volume event listening, **gRPC** (via LaserStream or Dedicated Nodes) offers top performance and advanced filters.
* **Error Handling**: Always implement proper error handling and retry logic for production applications.
* **Connection Management**: For WebSocket connections, implement heartbeat/ping mechanisms to maintain connections.
* **Rate Limiting**: Be aware of API rate limits and implement appropriate throttling in your applications.

**Happy building!**


# Solana NFT Compression: Cost-Efficient Mass NFT Minting
Source: https://www.helius.dev/docs/nfts/nft-compression

The most cost-efficient way to mint large numbers of NFTs on Solana. Learn Merkle trees, compressed NFTs, and massive cost savings for digital collections.

## What is Compression?

Data is stored in [accounts](https://solana.com/docs/core/accounts) on Solana, which can be expensive. **Compression** offers a cost-efficient alternative by storing data directly on the Solana ledger.

## NFT Compression

NFT Compression enables developers to mint large numbers of NFTs at a fraction of the cost by storing their properties on the Solana ledger instead of individual accounts. Traditionally, each NFT required its own account, which could become expensive for large collections. With compression, NFTs are stored in a **Merkle tree**, and the tree's validity is verified using its **root hash**, which is stored in a single account.

Modifications to a compressed NFT require **proof** to ensure that the NFT cannot be maliciously modified. The data returned by an indexer can also be verified by comparing the root hash with what is stored in the root account. For more details, see the Solana documentation and our [blog explainer](https://www.helius.dev/blog/solana-nft-compression).

Helius simplifies NFT development by tracking compressed NFT states, providing faster look-ups, and returning data with cryptographic proof to ensure integrity.

## How are compressed NFTs different?

* Compressed NFTs are not native Solana tokens. They do not have a token account, mint account, or metadata.
* One account exists per Merkle tree; each tree can hold millions of NFTs.
* One collection can use multiple Merkle trees (recommended for larger collections).
* A Merkle tree account can also hold multiple collections (not recommended).
* A [DAS API](/api-reference/das) call is required to read any information about a compressed NFT (e.g., attributes, collection information, etc.). This would affect Solana dApps loading your assets, etc.
* A compressed NFT can be converted to a regular NFT but not vice versa.

<Note>
  It is recommended to keep the tree size to 1 million or less for practical reasons. This is because the proof path will begin to exceed the Solana transaction account limit.
</Note>

<Note>
  All cNFT modifications must occur through the [Bubblegum program](https://github.com/metaplex-foundation/mpl-bubblegum/tree/main/programs/bubblegum). You can refer to the methods [here](https://developers.metaplex.com/bubblegum).
</Note>

## How does the indexer work?

Compressed NFT information is not stored in a traditional Solana account. Instead, all metadata is stored on a ledger, which requires indexing services to efficiently fetch the needed metadata. While it's possible to derive the current state by replaying relevant transactions, we handle this process for convenience.

The indexer monitors all Bubblegum transactions, parses them, and updates its internal state. For example, when a compressed NFT is minted, the indexer parses the transaction to extract key details such as the NFT's name, collection, and owner. If the indexer encounters a previously unseen tree or detects a missing update, it fetches the tree's transaction history and reconstructs the complete state. The indexer code can be found [here](https://github.com/metaplex-foundation/digital-asset-rpc-infrastructure).

## Examples

You can get started with the following examples:

* [Helius Compression Examples](https://github.com/helius-labs/compression-examples)
* [Metaplex Compression Examples](https://github.com/metaplex-foundation/compression-read-api-js-examples)

## Further Reading

* [What is Compression, a Twitter Thread](https://twitter.com/heliuslabs/status/1686796581193023489)
* [Metaplex Compression Overview](https://metaplex.notion.site/Compression-for-NFTs-Public-94f9faa25f034110b513414a11a85bbe)
* [Metaplex Compression Documentation Hub](https://docs.metaplex.com/programs/compression/)
* [Solana Account Compression Repo](https://github.com/solana-labs/solana-program-library/tree/master/account-compression)
* [Exploring Compression on Solana](https://www.helius.dev/blog/solana-nft-compression)

If you're more of a visual learner, here's a crash course on it:

<iframe width="560" height="315" src="https://www.youtube.com/embed/vKIE7tHad8w?si=rkFCHdhMGQYrEH1O" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen />


# Solana Priority Fee API: Smart Transaction Fee Estimation
Source: https://www.helius.dev/docs/priority-fee-api

Estimate optimal priority fees for Solana transactions. Real-time fee analysis with six priority levels to ensure fast confirmation and cost efficiency.

<Info>
  **Save money, improve performance**: Get precise priority fee estimates based on real-time network conditions. Pay only what you need for the speed you want.
</Info>

## What Are Priority Fees?

On Solana, priority fees allow your transactions to jump ahead in the validator queue during network congestion. Think of them as express lanes for your transactions.

<CardGroup cols={2}>
  <Card title="Base Fees vs Priority Fees" icon="coins">
    **Base fees** are fixed costs for transaction processing

    **Priority fees** are optional payments for faster processing
  </Card>

  <Card title="How They Work" icon="rocket">
    You set a price per compute unit - higher prices get processed first during network congestion
  </Card>
</CardGroup>

## Why Use Priority Fees

Priority fees are now a standard part of Solana transactions, helping ensure reliable confirmation times and optimal network performance.

<CardGroup cols={2}>
  <Card title="Reliable Confirmation" icon="circle-check">
    Ensure your transactions confirm quickly and reliably, even during varying network conditions
  </Card>

  <Card title="Competitive Edge" icon="trophy">
    Stay competitive in time-sensitive operations like trading, minting, and DeFi interactions
  </Card>

  <Card title="User Experience" icon="heart">
    Provide consistent, fast transaction processing for better user experience
  </Card>

  <Card title="Network Efficiency" icon="gauge">
    Help optimize network resource allocation and overall performance
  </Card>
</CardGroup>

## Priority Levels Explained

Our API provides six priority levels based on recent network activity:

<AccordionGroup>
  <Accordion title="Min">
    **Lowest observed fee** - Based on minimum fees seen in recent slots

    **Best for**: Non-urgent transactions when cost optimization is priority

    **Note**: May result in slower confirmation times
  </Accordion>

  <Accordion title="Low">
    **25th percentile** - Budget-friendly option with reasonable confirmation times

    **Best for**: Standard operations where speed isn't critical

    **Note**: Good balance of cost and reliability
  </Accordion>

  <Accordion title="Medium (Recommended)">
    **50th percentile** - Median fee providing reliable confirmation times

    **Best for**: Most applications and general use cases

    **Note**: Recommended starting point for most developers
  </Accordion>

  <Accordion title="High">
    **75th percentile** - Higher fees for faster processing

    **Best for**: Time-sensitive operations and competitive scenarios

    **Note**: Prioritized processing during network activity
  </Accordion>

  <Accordion title="VeryHigh">
    **95th percentile** - Premium fees for maximum speed

    **Best for**: Critical operations, MEV strategies, urgent transactions

    **Note**: Fast confirmation even during high network activity
  </Accordion>

  <Accordion title="UnsafeMax">
    **Maximum observed** - Highest fees seen in recent slots

    **Best for**: Emergency situations only

    **Warning**: Often unnecessarily high - use with caution
  </Accordion>
</AccordionGroup>

<Warning>
  **Cost Calculation**: Total priority fee = Price per compute unit  Compute units consumed

  A typical transaction uses 200,000-400,000 compute units. At current Medium level (\~40,000 microlamports per unit), that's 0.008-0.016 SOL in priority fees. Always check current network conditions for accurate estimates.
</Warning>

## Implementation Methods

<CardGroup cols={2}>
  <Card title="Serialized Transaction (Recommended)" icon="file-code" href="/priority-fee/estimating-fees-using-serialized-transaction">
    **Primary Method** - Analyzes your exact transaction for maximum accuracy

    **Best for**: Most applications and production use cases

    **Benefits**:

    * Instruction-specific analysis
    * Highest accuracy
    * Production-ready
    * Considers transaction complexity
  </Card>

  <Card title="Account Keys (Advanced)" icon="key" href="/priority-fee/estimating-fees-using-account-keys">
    **Specialized Use Cases** - Estimates based on account patterns

    **Best for**: Pre-transaction analysis, batch operations, specialized architectures

    **Benefits**:

    * Account-level pattern analysis
    * Useful for planning and research
    * Batch account analysis
  </Card>
</CardGroup>

## Quick Start Example

<CodeGroup>
  ```javascript JavaScript
  import { Transaction, SystemProgram, ComputeBudgetProgram } from "@solana/web3.js";
  import bs58 from "bs58";

  // 1. Build your transaction (without priority fee)
  const transaction = new Transaction();
  const transferIx = SystemProgram.transfer({
    fromPubkey: senderKeypair.publicKey,
    toPubkey: recipientPublicKey,
    lamports: 1000000, // 0.001 SOL
  });
  transaction.add(transferIx);

  // 2. Set required fields and serialize
  transaction.recentBlockhash = (await connection.getLatestBlockhash()).blockhash;
  transaction.feePayer = senderKeypair.publicKey;
  const serializedTx = bs58.encode(transaction.serialize());

  // 3. Get priority fee estimate
  const response = await fetch("https://mainnet.helius-rpc.com/?api-key=YOUR_API_KEY", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      jsonrpc: "2.0",
      id: "1",
      method: "getPriorityFeeEstimate",
      params: [{
        transaction: serializedTx,
        options: { 
          priorityLevel: "Medium",
          recommended: true 
        }
      }]
    })
  });

  const result = await response.json();
  const priorityFee = result.result.priorityFeeEstimate;

  // 4. Add priority fee and send
  transaction.instructions = []; // Reset
  transaction.add(ComputeBudgetProgram.setComputeUnitPrice({ microLamports: priorityFee }));
  transaction.add(transferIx);
  transaction.recentBlockhash = (await connection.getLatestBlockhash()).blockhash;
  transaction.sign(senderKeypair);
  ```

  ```python Python
  import requests
  import base58
  from solana.transaction import Transaction
  from solana.system_program import transfer, TransferParams

  # 1. Build and serialize your transaction
  # (transaction building code here)
  serialized_tx = base58.b58encode(transaction.serialize()).decode('utf-8')

  # 2. Get priority fee estimate
  response = requests.post(
      "https://mainnet.helius-rpc.com/?api-key=YOUR_API_KEY",
      json={
          "jsonrpc": "2.0",
          "id": "1",
          "method": "getPriorityFeeEstimate",
          "params": [{
              "transaction": serialized_tx,
              "options": {
                  "priorityLevel": "Medium",
                  "recommended": True
              }
          }]
      }
  )

  result = response.json()
  priority_fee = result["result"]["priorityFeeEstimate"]
  print(f"Recommended priority fee: {priority_fee} micro-lamports")

  # 3. Rebuild transaction with priority fee and send
  ```

  ```curl cURL
  curl -X POST "https://mainnet.helius-rpc.com/?api-key=YOUR_API_KEY" \
    -H "Content-Type: application/json" \
    -d '{
      "jsonrpc": "2.0",
      "id": "1",
      "method": "getPriorityFeeEstimate",
      "params": [{
        "transaction": "SERIALIZED_TRANSACTION_BASE58",
        "options": {
          "priorityLevel": "Medium",
          "recommended": true
        }
      }]
    }'
  ```
</CodeGroup>

## API Reference

<Card title="getPriorityFeeEstimate" icon="code" href="/api-reference/priority-fee/getpriorityfeeestimate">
  Complete API documentation with all parameters and response formats
</Card>

## Implementation Guides

<CardGroup cols={2}>
  <Card title="Serialized Transaction Method" icon="file-code" href="/priority-fee/estimating-fees-using-serialized-transaction">
    Comprehensive guide for the recommended transaction-based estimates
  </Card>

  <Card title="Account Keys Method" icon="key" href="/priority-fee/estimating-fees-using-account-keys">
    Advanced guide for specialized account-based estimates
  </Card>
</CardGroup>

## Real-Time Network Monitoring

<Tip>
  **Pro tip**: Monitor network conditions to optimize your priority fee strategy. During normal conditions, use lower priority levels. During congestion, consider higher levels for time-sensitive operations.

  You can check current network conditions using Solana explorers or the `getRecentPerformanceSamples` RPC method.
</Tip>

## Support & Resources

<CardGroup cols={2}>
  <Card title="Discord Community" icon="discord" href="https://discord.com/invite/6GXdee3gBj">
    Get help from the community and Helius team
  </Card>

  <Card title="Direct Support" icon="headset" href="/support">
    Priority fee questions and optimization assistance
  </Card>
</CardGroup>


# Solana Priority Fee Estimation: Account Keys Method
Source: https://www.helius.dev/docs/priority-fee/estimating-fees-using-account-keys

Estimate Solana priority fees using account keys with the Helius Priority Fee API. Quick fee estimates for pre-transaction analysis and batch operations.

<Info>
  **Advanced Method**: Get priority fee estimates using account keys for specialized use cases like pre-transaction analysis, batch operations, and account pattern research.
</Info>

## Overview

The account keys method provides a simpler alternative to transaction serialization when you need quick fee estimates or want to estimate fees before constructing the complete transaction.

<CardGroup cols={2}>
  <Card title="Advanced Use Cases" icon="key">
    * Pre-transaction analysis
    * Batch account operations
    * Market research and patterns
    * Specialized architectures
  </Card>

  <Card title="Trade-offs" icon="scale-unbalanced-flip">
    * Less accurate than serialized transactions
    * No instruction-specific analysis
    * Best for account-level patterns
  </Card>
</CardGroup>

<Warning>
  **Recommendation**: For most applications, use the [serialized transaction method](/priority-fee/estimating-fees-using-serialized-transaction) instead. This account keys method is for specialized use cases where you need account-level analysis or pre-transaction planning.
</Warning>

## When to Use Account Keys

<Tabs>
  <Tab title="Ideal Use Cases">
    <CardGroup cols={2}>
      <Card title="Pre-transaction Planning" icon="calendar">
        Get fee estimates before constructing complete transactions
      </Card>

      <Card title="Simplified Integration" icon="puzzle-piece">
        When your architecture makes transaction serialization difficult
      </Card>

      <Card title="Quick Market Analysis" icon="chart-line">
        Analyze fee patterns for specific accounts without building transactions
      </Card>

      <Card title="Multi-account Analysis" icon="users">
        Understand fee patterns across multiple accounts independently
      </Card>
    </CardGroup>
  </Tab>

  <Tab title="Specialized Scenarios">
    **Research & Analysis**: When studying fee patterns across different accounts and programs

    **Batch Operations**: When analyzing fee patterns across many accounts simultaneously

    **Pre-planning**: For cost estimation before building complex transaction workflows

    **Custom Architectures**: When system constraints prevent transaction serialization
  </Tab>
</Tabs>

## Quick Start

<Steps>
  <Step title="Identify Accounts">
    Determine which accounts will be involved in your transaction
  </Step>

  <Step title="Call the API">
    Make a request with the account keys and desired priority level
  </Step>

  <Step title="Apply the Fee">
    Use the estimate to set priority fee in your transaction
  </Step>
</Steps>

### Basic Example

<CodeGroup>
  ```javascript JavaScript
  import { ComputeBudgetProgram } from "@solana/web3.js";

  // 1. Identify accounts involved in your transaction
  const accountKeys = [
    "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA", // Token program
    "YOUR_WALLET_ADDRESS",                          // Your wallet
    "RECIPIENT_ADDRESS"                             // Recipient
  ];

  // 2. Get priority fee estimate
  const priorityFee = await getPriorityFeeEstimate(connection, accountKeys, "Medium");

  // 3. Add to your transaction
  const priorityFeeIx = ComputeBudgetProgram.setComputeUnitPrice({
    microLamports: priorityFee
  });
  transaction.add(priorityFeeIx);
  ```

  ```python Python
  import requests

  # Get priority fee estimate
  def get_priority_fee_estimate(account_keys, priority_level="Medium"):
      response = requests.post(
          "https://mainnet.helius-rpc.com/?api-key=YOUR_API_KEY",
          json={
              "jsonrpc": "2.0",
              "id": "1",
              "method": "getPriorityFeeEstimate",
              "params": [{
                  "accountKeys": account_keys,
                  "options": {
                      "priorityLevel": priority_level,
                      "recommended": True
                  }
              }]
          }
      )
      return response.json()["result"]["priorityFeeEstimate"]

  # Usage
  accounts = ["ACCOUNT_1", "ACCOUNT_2", "ACCOUNT_3"]
  fee = get_priority_fee_estimate(accounts, "High")
  print(f"Priority fee: {fee} micro-lamports")
  ```
</CodeGroup>

## Implementation Guide

### Core Function

Here's a reusable function for getting priority fee estimates:

```javascript
async function getPriorityFeeEstimate(connection, accountKeys, priorityLevel = "Medium") {
  const response = await fetch(connection.rpcEndpoint, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      jsonrpc: "2.0",
      id: "1",
      method: "getPriorityFeeEstimate",
      params: [{
        accountKeys: accountKeys,
        options: { 
          priorityLevel: priorityLevel,
          recommended: true 
        }
      }]
    })
  });
  
  const result = await response.json();
  
  if (result.error) {
    throw new Error(`Fee estimation failed: ${JSON.stringify(result.error)}`);
  }
  
  return result.result.priorityFeeEstimate;
}
```

### Complete Example with Multiple Priority Levels

<Accordion title="Expand to see full implementation">
  ```javascript
  const { 
    Connection, 
    PublicKey, 
    Transaction, 
    ComputeBudgetProgram 
  } = require("@solana/web3.js");

  // Initialize connection
  const connection = new Connection("https://mainnet.helius-rpc.com/?api-key=YOUR_API_KEY");

  async function analyzeAccountPriorityFees() {
    // Define accounts involved in your transaction
    const accountKeys = [
      "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA", // Token program
      "YOUR_WALLET_ADDRESS",                          // Your wallet
      "TOKEN_ACCOUNT_ADDRESS",                        // Token account
      "RECIPIENT_ADDRESS"                             // Recipient
    ];
    
    try {
      // Get estimates for different priority levels
      const [lowFee, mediumFee, highFee, veryHighFee] = await Promise.all([
        getPriorityFeeEstimate(connection, accountKeys, "Low"),
        getPriorityFeeEstimate(connection, accountKeys, "Medium"), 
        getPriorityFeeEstimate(connection, accountKeys, "High"),
        getPriorityFeeEstimate(connection, accountKeys, "VeryHigh")
      ]);
      
      console.log("Priority Fee Estimates:");
      console.log(`Low:      ${lowFee} micro-lamports`);
      console.log(`Medium:   ${mediumFee} micro-lamports`);
      console.log(`High:     ${highFee} micro-lamports`);
      console.log(`VeryHigh: ${veryHighFee} micro-lamports`);
      
      // Get all levels at once for comparison
      const allLevels = await getAllPriorityLevels(connection, accountKeys);
      console.log("\nAll priority levels:", allLevels);
      
      return {
        low: lowFee,
        medium: mediumFee,
        high: highFee,
        veryHigh: veryHighFee,
        allLevels
      };
    } catch (error) {
      console.error("Error getting priority fees:", error);
      throw error;
    }
  }

  // Helper function to get all priority levels
  async function getAllPriorityLevels(connection, accountKeys) {
    const response = await fetch(connection.rpcEndpoint, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        jsonrpc: "2.0",
        id: "1",
        method: "getPriorityFeeEstimate",
        params: [{
          accountKeys: accountKeys,
          options: { 
            includeAllPriorityFeeLevels: true
          }
        }]
      })
    });
    
    const result = await response.json();
    
    if (result.error) {
      throw new Error(`Fee estimation failed: ${JSON.stringify(result.error)}`);
    }
    
    return result.result.priorityFeeLevels;
  }

  // Run the analysis
  analyzeAccountPriorityFees();
  ```
</Accordion>

## Account Types & Strategies

<Tabs>
  <Tab title="Program Accounts">
    High-volume program accounts typically show higher priority fees due to competition.

    ```javascript
    // Popular program accounts
    const programAccounts = [
      "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA", // Token program
      "ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL", // Associated token program
      "M2mx93ekt1fmXSVkTrUL9xVFHkmME8HTUi5Cyc5aF7K"  // Metaplex program
    ];

    const programFees = await getPriorityFeeEstimate(connection, programAccounts, "Medium");
    console.log(`Program account fees: ${programFees} micro-lamports`);
    ```

    <Note>
      **Expected behavior**: Higher fees due to high transaction volume and competition.
    </Note>
  </Tab>

  <Tab title="User Wallets">
    Active user wallets may have different fee patterns based on their activity.

    ```javascript
    // Active user wallets
    const userWallets = [
      "USER_WALLET_1", // Active trader
      "USER_WALLET_2"  // Regular user
    ];

    const walletFees = await getPriorityFeeEstimate(connection, userWallets, "Medium");
    console.log(`User wallet fees: ${walletFees} micro-lamports`);
    ```

    <Tip>
      **Pro tip**: Include both sender and recipient wallets for more accurate estimates.
    </Tip>
  </Tab>

  <Tab title="Token Accounts">
    Specific token accounts can show varying patterns based on token popularity.

    ```javascript
    // Popular token accounts
    const tokenAccounts = [
      "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v", // USDC mint
      "So11111111111111111111111111111111111111112",  // SOL mint
      "YOUR_TOKEN_ACCOUNT"                            // Your specific token account
    ];

    const tokenFees = await getPriorityFeeEstimate(connection, tokenAccounts, "Medium");
    ```
  </Tab>
</Tabs>

## Advanced Configuration Options

<AccordionGroup>
  <Accordion title="Empty Slot Evaluation">
    The `evaluateEmptySlotAsZero` option is particularly useful for account-based estimates:

    ```javascript
    async function compareEmptySlotHandling(accountKeys) {
      const withEmptyAsZero = await fetch(connection.rpcEndpoint, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          jsonrpc: "2.0",
          id: "1",
          method: "getPriorityFeeEstimate",
          params: [{
            accountKeys: accountKeys,
            options: { 
              priorityLevel: "Medium",
              evaluateEmptySlotAsZero: true // Default: true
            }
          }]
        })
      });

      const withoutEmptyAsZero = await fetch(connection.rpcEndpoint, {
        method: "POST", 
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          jsonrpc: "2.0",
          id: "1",
          method: "getPriorityFeeEstimate", 
          params: [{
            accountKeys: accountKeys,
            options: {
              priorityLevel: "Medium",
              evaluateEmptySlotAsZero: false
            }
          }]
        })
      });
      
      const result1 = await withEmptyAsZero.json();
      const result2 = await withoutEmptyAsZero.json();
      
      console.log(`With empty as zero: ${result1.result.priorityFeeEstimate}`);
      console.log(`Without empty as zero: ${result2.result.priorityFeeEstimate}`);
    }
    ```

    <Note>
      When `true` (default), slots with no transactions are treated as zero fees rather than excluded. This provides more balanced estimates for accounts with sparse activity.
    </Note>
  </Accordion>

  <Accordion title="Include Details">
    Request detailed information about each account's fee patterns:

    ```javascript
    async function getDetailedFeeEstimate(connection, accountKeys) {
      const response = await fetch(connection.rpcEndpoint, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          jsonrpc: "2.0",
          id: "1",
          method: "getPriorityFeeEstimate",
          params: [{
            accountKeys: accountKeys,
            options: { 
              includeDetails: true,
              priorityLevel: "Medium"
            }
          }]
        })
      });
      
      const result = await response.json();
      console.log("Detailed fee analysis:", result.result);
      return result.result;
    }
    ```

    This returns additional information about how fees were calculated for each account.
  </Accordion>

  <Accordion title="Custom Lookback Period">
    Adjust the number of slots analyzed for fee estimation:

    ```javascript
    async function getCustomLookbackEstimate(accountKeys, lookbackSlots = 50) {
      const response = await fetch(connection.rpcEndpoint, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          jsonrpc: "2.0",
          id: "1",
          method: "getPriorityFeeEstimate",
          params: [{
            accountKeys: accountKeys,
            options: { 
              priorityLevel: "Medium",
              lookbackSlots: lookbackSlots  // 1-150, default is 150
            }
          }]
        })
      });
      
      const result = await response.json();
      return result.result.priorityFeeEstimate;
    }

    // Compare different lookback periods
    const shortTerm = await getCustomLookbackEstimate(accountKeys, 50);   // Recent trends
    const longTerm = await getCustomLookbackEstimate(accountKeys, 150);   // Historical average

    console.log(`Short-term estimate: ${shortTerm} micro-lamports`);
    console.log(`Long-term estimate: ${longTerm} micro-lamports`);
    ```

    <Tip>
      **Smaller lookback**: More recent, potentially volatile data

      **Larger lookback**: More stable, historical context
    </Tip>
  </Accordion>
</AccordionGroup>

## Best Practices for Account Selection

<CardGroup cols={1}>
  <Card title="Include Writable Accounts" icon="pen-to-square">
    **Priority**: Focus on accounts that will be modified

    ```javascript
    const writableAccounts = [
      "YOUR_WALLET",        // Paying fees
      "TOKEN_ACCOUNT",      // Being modified  
      "RECIPIENT_ACCOUNT"   // Receiving tokens
    ];
    ```
  </Card>

  <Card title="Add Key Programs" icon="gear">
    **Context**: Include relevant program accounts

    ```javascript
    const programAccounts = [
      "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA", // Token program
      "CUSTOM_PROGRAM_ID"                           // Your program
    ];
    ```
  </Card>
</CardGroup>

## Error Handling & Fallbacks

<CodeGroup>
  ```javascript Robust Implementation
  class AccountBasedFeeEstimator {
    constructor(connection) {
      this.connection = connection;
      this.fallbackFee = 10000; // 10k micro-lamports fallback
    }

    async getEstimate(accountKeys, priorityLevel = "Medium") {
      try {
        // Primary attempt
        const estimate = await this.getPrimaryEstimate(accountKeys, priorityLevel);
        return estimate;
      } catch (error) {
        console.warn("Primary estimate failed:", error.message);
        
        // Fallback to different configuration
        try {
          return await this.getFallbackEstimate(accountKeys, priorityLevel);
        } catch (fallbackError) {
          console.warn("Fallback estimate failed:", fallbackError.message);
          return this.fallbackFee;
        }
      }
    }

    async getPrimaryEstimate(accountKeys, priorityLevel) {
      const response = await fetch(this.connection.rpcEndpoint, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          jsonrpc: "2.0",
          id: "1",
          method: "getPriorityFeeEstimate",
          params: [{
            accountKeys: accountKeys,
            options: { 
              priorityLevel: priorityLevel,
              recommended: true 
            }
          }]
        })
      });

      const result = await response.json();
      if (result.error) {
        throw new Error(result.error.message);
      }
      
      return result.result.priorityFeeEstimate;
    }

    async getFallbackEstimate(accountKeys, priorityLevel) {
      // Try with fewer accounts or different settings
      const coreAccounts = accountKeys.slice(0, 3); // Take first 3 accounts
      
      const response = await fetch(this.connection.rpcEndpoint, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          jsonrpc: "2.0",
          id: "1",
          method: "getPriorityFeeEstimate",
          params: [{
            accountKeys: coreAccounts,
            options: { 
              priorityLevel: "Medium", // Use medium as fallback
              evaluateEmptySlotAsZero: true
            }
          }]
        })
      });

      const result = await response.json();
      if (result.error) {
        throw new Error(result.error.message);
      }
      
      return result.result.priorityFeeEstimate;
    }
  }

  // Usage
  const estimator = new AccountBasedFeeEstimator(connection);
  const fee = await estimator.getEstimate(accountKeys, "High");
  ```

  ```javascript Simple Error Handling
  async function safeGetPriorityFee(accountKeys, priorityLevel = "Medium") {
    try {
      return await getPriorityFeeEstimate(connection, accountKeys, priorityLevel);
    } catch (error) {
      console.warn(`Priority fee estimation failed: ${error.message}`);
      
      // Return reasonable fallback based on priority level
      const fallbacks = {
        "Low": 1000,
        "Medium": 5000,
        "High": 15000,
        "VeryHigh": 50000
      };
      
      return fallbacks[priorityLevel] || 5000;
    }
  }
  ```
</CodeGroup>

## Limitations & Considerations

<Warning>
  **Account-based method limitations:**

  1. **Less accurate for read-only accounts** - The algorithm focuses on writable accounts
  2. **No instruction-specific analysis** - Can't consider specific operations
  3. **Account activity dependency** - Less accurate for inactive accounts
  4. **No transaction size consideration** - Doesn't account for transaction complexity
</Warning>

<Note>
  **When to upgrade to serialized transactions:**

  * Production applications requiring highest accuracy
  * Complex transactions with multiple instructions
  * When instruction-specific fee patterns matter
  * Performance-critical applications
</Note>

## Related Resources

<CardGroup cols={2}>
  <Card title="Serialized Transactions" icon="file-code" href="/priority-fee/estimating-fees-using-serialized-transaction">
    More accurate method using full transaction serialization
  </Card>

  <Card title="API Reference" icon="book" href="/api-reference/priority-fee/getpriorityfeeestimate">
    Complete API documentation and parameters
  </Card>
</CardGroup>


# Solana Priority Fee Estimation: Serialized Transaction Method
Source: https://www.helius.dev/docs/priority-fee/estimating-fees-using-serialized-transaction

Get the most accurate Solana priority fee estimates using serialized transactions with the Helius Priority Fee API. Perfect for production applications.

<Info>
  **Most Accurate Method**: Get the highest precision priority fee estimates by analyzing your exact transaction. Recommended for production applications where accuracy matters most.
</Info>

## Overview

Serialized transactions provide the most accurate fee estimates because the API can analyze the exact accounts and operations that will be performed in your transaction.

<CardGroup cols={2}>
  <Card title="Why Use Serialized Transactions" icon="bullseye">
    * **Highest accuracy** - Analyzes exact operations
    * **Detailed analysis** - Instruction-specific patterns
    * **Realistic estimates** - Reflects actual transaction
    * **Production-ready** - Built for critical applications
  </Card>

  <Card title="Best For" icon="bullseye-pointer">
    * Production applications
    * Complex transactions
    * Critical operations
    * Maximum accuracy needed
  </Card>
</CardGroup>

## Advantages Over Account Keys

<Tabs>
  <Tab title="Accuracy Benefits">
    <CardGroup cols={1}>
      <Card title="Instruction-Specific Analysis" icon="code">
        The API can analyze specific operations and their historical fee patterns, not just account activity.
      </Card>

      <Card title="Transaction Size Awareness" icon="expand">
        Considers the actual size and complexity of your transaction for more accurate estimates.
      </Card>

      <Card title="Read-Only Account Handling" icon="eye">
        Better analysis of both writable and read-only accounts in their transaction context.
      </Card>
    </CardGroup>
  </Tab>

  <Tab title="Real-World Benefits">
    **DeFi Trading**: More accurate estimates for complex swap operations

    **NFT Minting**: Better estimates for mint transactions with specific metadata

    **Multi-instruction Transactions**: Accurate fees for complex multi-step operations

    **Program Interactions**: Better estimates for specific program calls
  </Tab>
</Tabs>

## Implementation Guide

<Steps>
  <Step title="Build Your Transaction">
    Create your transaction with all instructions (except priority fee)
  </Step>

  <Step title="Serialize the Transaction">
    Convert your transaction to a serialized format
  </Step>

  <Step title="Get Fee Estimate">
    Call the Priority Fee API with your serialized transaction
  </Step>

  <Step title="Apply Priority Fee">
    Add the priority fee instruction and send your transaction
  </Step>
</Steps>

### Quick Start Example

<CodeGroup>
  ```javascript JavaScript
  import { 
    Connection, 
    PublicKey, 
    Transaction, 
    SystemProgram, 
    ComputeBudgetProgram 
  } from "@solana/web3.js";
  import bs58 from "bs58";

  const connection = new Connection("https://mainnet.helius-rpc.com/?api-key=YOUR_API_KEY");

  // 1. Build your transaction (without priority fee)
  const transaction = new Transaction();
  const transferIx = SystemProgram.transfer({
    fromPubkey: senderKeypair.publicKey,
    toPubkey: recipientPublicKey,
    lamports: 1000000, // 0.001 SOL
  });
  transaction.add(transferIx);

  // 2. Set required fields and serialize
  transaction.recentBlockhash = (await connection.getLatestBlockhash()).blockhash;
  transaction.feePayer = senderKeypair.publicKey;
  const serializedTx = bs58.encode(transaction.serialize());

  // 3. Get priority fee estimate
  const priorityFee = await getPriorityFeeEstimate(connection, serializedTx, "Medium");

  // 4. Add priority fee and send
  transaction.instructions = []; // Reset
  transaction.add(ComputeBudgetProgram.setComputeUnitPrice({ microLamports: priorityFee }));
  transaction.add(transferIx);
  transaction.recentBlockhash = (await connection.getLatestBlockhash()).blockhash;
  transaction.sign(senderKeypair);
  ```

  ```python Python
  import requests
  import json
  from solana.transaction import Transaction
  from solana.system_program import transfer, TransferParams

  # Build and serialize transaction
  def get_serialized_transaction():
      # Build your transaction here
      # Return base58 encoded serialized transaction
      pass

  # Get priority fee estimate
  def get_priority_fee_estimate(serialized_tx, priority_level="Medium"):
      response = requests.post(
          "https://mainnet.helius-rpc.com/?api-key=YOUR_API_KEY",
          json={
              "jsonrpc": "2.0",
              "id": "1",
              "method": "getPriorityFeeEstimate",
              "params": [{
                  "transaction": serialized_tx,
                  "options": {
                      "priorityLevel": priority_level,
                      "recommended": True
                  }
              }]
          }
      )
      return response.json()["result"]["priorityFeeEstimate"]

  # Usage
  serialized_tx = get_serialized_transaction()
  fee = get_priority_fee_estimate(serialized_tx, "High")
  print(f"Priority fee: {fee} micro-lamports")
  ```
</CodeGroup>

## Core Implementation Function

Here's a reusable function for getting priority fee estimates from serialized transactions:

```javascript
async function getPriorityFeeEstimate(connection, serializedTransaction, priorityLevel = "Medium") {
  const response = await fetch(connection.rpcEndpoint, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      jsonrpc: "2.0",
      id: "1",
      method: "getPriorityFeeEstimate",
      params: [{
        transaction: serializedTransaction,
        options: { 
          priorityLevel: priorityLevel,
          recommended: true 
        }
      }]
    })
  });
  
  const result = await response.json();
  
  if (result.error) {
    throw new Error(`Fee estimation failed: ${JSON.stringify(result.error)}`);
  }
  
  return result.result.priorityFeeEstimate;
}
```

## Complete Implementation Examples

<Tabs>
  <Tab title="Simple Transfer">
    <Accordion title="Expand to see complete example">
      ```javascript
      const { 
        Connection, 
        PublicKey, 
        Transaction, 
        SystemProgram, 
        ComputeBudgetProgram, 
        sendAndConfirmTransaction,
        Keypair
      } = require("@solana/web3.js");
      const bs58 = require("bs58");

      // Initialize connection and accounts
      const connection = new Connection("https://mainnet.helius-rpc.com/?api-key=YOUR_API_KEY");
      const senderKeypair = Keypair.fromSecretKey(bs58.decode("YOUR_PRIVATE_KEY"));
      const receiverPublicKey = new PublicKey("RECIPIENT_PUBLIC_KEY");

      async function sendTransactionWithPriorityFee(amount, priorityLevel = "Medium") {
        // 1. Create transaction with transfer instruction
        const transaction = new Transaction();
        const transferIx = SystemProgram.transfer({
          fromPubkey: senderKeypair.publicKey,
          toPubkey: receiverPublicKey,
          lamports: amount,
        });
        transaction.add(transferIx);
        
        // 2. Set required fields for serialization
        transaction.recentBlockhash = (await connection.getLatestBlockhash()).blockhash;
        transaction.feePayer = senderKeypair.publicKey;
        
        // 3. Serialize the transaction
        const serializedTransaction = bs58.encode(transaction.serialize());
        
        // 4. Get priority fee estimate
        const priorityFee = await getPriorityFeeEstimate(connection, serializedTransaction, priorityLevel);
        console.log(`Estimated ${priorityLevel} priority fee: ${priorityFee} micro-lamports`);
        
        // 5. Reset transaction and add priority fee instruction first
        transaction.instructions = [];
        
        // Add priority fee instruction
        const priorityFeeIx = ComputeBudgetProgram.setComputeUnitPrice({
          microLamports: priorityFee
        });
        transaction.add(priorityFeeIx);
        
        // Re-add the original transfer instruction
        transaction.add(transferIx);
        
        // 6. Update blockhash and sign
        transaction.recentBlockhash = (await connection.getLatestBlockhash()).blockhash;
        transaction.sign(senderKeypair);
        
        // 7. Send the transaction
        try {
          const signature = await sendAndConfirmTransaction(
            connection,
            transaction,
            [senderKeypair],
            { maxRetries: 0 } // Set to 0 for staked connection usage
          );
          console.log(`Transaction successful with signature: ${signature}`);
          return signature;
        } catch (error) {
          console.error("Error sending transaction:", error);
          throw error;
        }
      }

      // Usage
      sendTransactionWithPriorityFee(1000000, "High"); // Send 0.001 SOL with high priority
      ```
    </Accordion>
  </Tab>

  <Tab title="Token Transfer">
    <Accordion title="Expand to see complete example">
      ```javascript
      const { 
        Connection, 
        PublicKey, 
        Transaction, 
        ComputeBudgetProgram,
        sendAndConfirmTransaction,
        Keypair
      } = require("@solana/web3.js");
      const { 
        createTransferInstruction,
        getAssociatedTokenAddress,
        TOKEN_PROGRAM_ID,
        ASSOCIATED_TOKEN_PROGRAM_ID
      } = require("@solana/spl-token");
      const bs58 = require("bs58");

      async function sendTokenWithPriorityFee(
        connection,
        senderKeypair,
        recipientPublicKey,
        mintAddress,
        amount,
        priorityLevel = "Medium"
      ) {
        // 1. Get token account addresses
        const senderTokenAccount = await getAssociatedTokenAddress(
          mintAddress,
          senderKeypair.publicKey
        );
        
        const recipientTokenAccount = await getAssociatedTokenAddress(
          mintAddress,
          recipientPublicKey
        );
        
        // 2. Create transaction with token transfer instruction
        const transaction = new Transaction();
        const transferIx = createTransferInstruction(
          senderTokenAccount,
          recipientTokenAccount,
          senderKeypair.publicKey,
          amount,
          [],
          TOKEN_PROGRAM_ID
        );
        transaction.add(transferIx);
        
        // 3. Set required fields and serialize
        transaction.recentBlockhash = (await connection.getLatestBlockhash()).blockhash;
        transaction.feePayer = senderKeypair.publicKey;
        const serializedTransaction = bs58.encode(transaction.serialize());
        
        // 4. Get priority fee estimate
        const priorityFee = await getPriorityFeeEstimate(connection, serializedTransaction, priorityLevel);
        console.log(`Token transfer priority fee: ${priorityFee} micro-lamports`);
        
        // 5. Reset and rebuild transaction with priority fee
        transaction.instructions = [];
        
        // Add priority fee instruction first
        const priorityFeeIx = ComputeBudgetProgram.setComputeUnitPrice({
          microLamports: priorityFee
        });
        transaction.add(priorityFeeIx);
        
        // Re-add the transfer instruction
        transaction.add(transferIx);
        
        // 6. Update blockhash and send
        transaction.recentBlockhash = (await connection.getLatestBlockhash()).blockhash;
        transaction.sign(senderKeypair);
        
        const signature = await sendAndConfirmTransaction(
          connection,
          transaction,
          [senderKeypair],
          { maxRetries: 0 }
        );
        
        return signature;
      }
      ```
    </Accordion>
  </Tab>

  <Tab title="Complex Multi-Instruction">
    <Accordion title="Expand to see complete example">
      ```javascript
      async function complexTransactionWithPriorityFee(connection, keypair) {
        // 1. Build complex transaction with multiple instructions
        const transaction = new Transaction();
        
        // Add multiple instructions
        const createAccountIx = SystemProgram.createAccount({
          fromPubkey: keypair.publicKey,
          newAccountPubkey: newAccountKeypair.publicKey,
          lamports: await connection.getMinimumBalanceForRentExemption(165),
          space: 165,
          programId: TOKEN_PROGRAM_ID,
        });
        
        const initializeAccountIx = createInitializeAccountInstruction(
          newAccountKeypair.publicKey,
          mintAddress,
          keypair.publicKey,
          TOKEN_PROGRAM_ID
        );
        
        const transferIx = SystemProgram.transfer({
          fromPubkey: keypair.publicKey,
          toPubkey: recipientPublicKey,
          lamports: 1000000,
        });
        
        transaction.add(createAccountIx);
        transaction.add(initializeAccountIx);
        transaction.add(transferIx);
        
        // 2. Set required fields and serialize
        transaction.recentBlockhash = (await connection.getLatestBlockhash()).blockhash;
        transaction.feePayer = keypair.publicKey;
        const serializedTransaction = bs58.encode(transaction.serialize());
        
        // 3. Get priority fee estimate for complex transaction
        const priorityFee = await getPriorityFeeEstimate(connection, serializedTransaction, "High");
        console.log(`Complex transaction priority fee: ${priorityFee} micro-lamports`);
        
        // 4. Rebuild transaction with priority fee
        transaction.instructions = [];
        
        // Add priority fee instruction first
        const priorityFeeIx = ComputeBudgetProgram.setComputeUnitPrice({
          microLamports: priorityFee
        });
        transaction.add(priorityFeeIx);
        
        // Optional: Set compute unit limit for complex transactions
        const computeLimitIx = ComputeBudgetProgram.setComputeUnitLimit({
          units: 400000 // Adjust based on your transaction complexity
        });
        transaction.add(computeLimitIx);
        
        // Re-add all original instructions
        transaction.add(createAccountIx);
        transaction.add(initializeAccountIx);
        transaction.add(transferIx);
        
        // 5. Update blockhash and send
        transaction.recentBlockhash = (await connection.getLatestBlockhash()).blockhash;
        transaction.sign(keypair, newAccountKeypair);
        
        const signature = await sendAndConfirmTransaction(
          connection,
          transaction,
          [keypair, newAccountKeypair],
          { maxRetries: 0 }
        );
        
        return signature;
      }
      ```
    </Accordion>
  </Tab>
</Tabs>

## Advanced Configuration Options

<AccordionGroup>
  <Accordion title="Include All Priority Levels">
    Get estimates for all priority levels at once:

    ```javascript
    async function getAllPriorityLevels(connection, serializedTransaction) {
      const response = await fetch(connection.rpcEndpoint, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          jsonrpc: "2.0",
          id: "1",
          method: "getPriorityFeeEstimate",
          params: [{
            transaction: serializedTransaction,
            options: { 
              includeAllPriorityFeeLevels: true
            }
          }]
        })
      });
      
      const result = await response.json();
      return result.result.priorityFeeLevels;
    }

    // Usage
    const allLevels = await getAllPriorityLevels(connection, serializedTransaction);
    console.log("All priority levels:", allLevels);
    /*
    Output:
    {
      "min": 0,
      "low": 1000, 
      "medium": 5000,
      "high": 15000,
      "veryHigh": 50000,
      "unsafeMax": 100000
    }
    */
    ```
  </Accordion>

  <Accordion title="Include Detailed Analysis">
    Request detailed information about the fee calculation:

    ```javascript
    async function getDetailedFeeAnalysis(connection, serializedTransaction) {
      const response = await fetch(connection.rpcEndpoint, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          jsonrpc: "2.0",
          id: "1",
          method: "getPriorityFeeEstimate",
          params: [{
            transaction: serializedTransaction,
            options: { 
              includeDetails: true,
              priorityLevel: "Medium"
            }
          }]
        })
      });
      
      const result = await response.json();
      console.log("Detailed analysis:", result.result);
      return result.result;
    }
    ```

    This provides insights into how the fee was calculated, including per-account analysis.
  </Accordion>

  <Accordion title="Custom Lookback Period">
    Adjust the number of slots analyzed:

    ```javascript
    async function getCustomLookbackEstimate(connection, serializedTransaction, lookbackSlots = 50) {
      const response = await fetch(connection.rpcEndpoint, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          jsonrpc: "2.0",
          id: "1",
          method: "getPriorityFeeEstimate",
          params: [{
            transaction: serializedTransaction,
            options: { 
              priorityLevel: "Medium",
              lookbackSlots: lookbackSlots  // 1-150, default is 150
            }
          }]
        })
      });
      
      const result = await response.json();
      return result.result.priorityFeeEstimate;
    }

    // Compare different lookback periods
    const recentEstimate = await getCustomLookbackEstimate(connection, serializedTx, 30);
    const longerEstimate = await getCustomLookbackEstimate(connection, serializedTx, 100);

    console.log(`Recent (30 slots): ${recentEstimate} micro-lamports`);
    console.log(`Longer (100 slots): ${longerEstimate} micro-lamports`);
    ```
  </Accordion>
</AccordionGroup>

## Best Practices

<CardGroup cols={1}>
  <Card title="Transaction Serialization" icon="code">
    **Always serialize your actual transaction**, not a simplified version

    ```javascript
    //  Good - serialize actual transaction
    const transaction = new Transaction();
    transaction.add(actualInstruction1);
    transaction.add(actualInstruction2);
    const serialized = bs58.encode(transaction.serialize());
    ```
  </Card>

  <Card title="Instruction Order" icon="list">
    **Include all instructions except the priority fee** in your estimation transaction

    ```javascript
    //  Good - all business logic included
    transaction.add(createAccountIx);
    transaction.add(initializeIx);
    transaction.add(transferIx);

    //  Don't include priority fee in estimation
    ```
  </Card>
</CardGroup>

## Error Handling Strategies

<Tabs>
  <Tab title="Robust Error Handling">
    ```javascript
    class SerializedTransactionFeeEstimator {
      constructor(connection) {
        this.connection = connection;
        this.fallbackFee = 10000; // 10k micro-lamports
      }

      async getEstimate(serializedTransaction, priorityLevel = "Medium") {
        try {
          // Primary attempt with serialized transaction
          return await this.getPrimaryEstimate(serializedTransaction, priorityLevel);
        } catch (error) {
          console.warn("Serialized transaction estimate failed:", error.message);
          
          // Fallback to account-based estimation
          try {
            return await this.getFallbackEstimate(serializedTransaction, priorityLevel);
          } catch (fallbackError) {
            console.warn("Fallback estimate failed:", fallbackError.message);
            return this.getFallbackFee(priorityLevel);
          }
        }
      }

      async getPrimaryEstimate(serializedTransaction, priorityLevel) {
        const response = await fetch(this.connection.rpcEndpoint, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            jsonrpc: "2.0",
            id: "1",
            method: "getPriorityFeeEstimate",
            params: [{
              transaction: serializedTransaction,
              options: { 
                priorityLevel: priorityLevel,
                recommended: true 
              }
            }]
          })
        });

        const result = await response.json();
        if (result.error) {
          throw new Error(result.error.message);
        }
        
        return result.result.priorityFeeEstimate;
      }

      async getFallbackEstimate(serializedTransaction, priorityLevel) {
        // Extract account keys from transaction and use account-based estimation
        const transaction = Transaction.from(bs58.decode(serializedTransaction));
        const accountKeys = transaction.instructions
          .flatMap(ix => [ix.programId, ...ix.keys.map(k => k.pubkey)])
          .map(key => key.toString());

        const uniqueAccountKeys = [...new Set(accountKeys)];
        
        // Use account-based estimation as fallback
        const response = await fetch(this.connection.rpcEndpoint, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            jsonrpc: "2.0",
            id: "1",
            method: "getPriorityFeeEstimate",
            params: [{
              accountKeys: uniqueAccountKeys,
              options: { 
                priorityLevel: priorityLevel,
                recommended: true 
              }
            }]
          })
        });

        const result = await response.json();
        if (result.error) {
          throw new Error(result.error.message);
        }
        
        return result.result.priorityFeeEstimate;
      }

      getFallbackFee(priorityLevel) {
        const fallbacks = {
          "Low": 1000,
          "Medium": 5000,
          "High": 15000,
          "VeryHigh": 50000
        };
        
        return fallbacks[priorityLevel] || 5000;
      }
    }

    // Usage
    const estimator = new SerializedTransactionFeeEstimator(connection);
    const fee = await estimator.getEstimate(serializedTransaction, "High");
    ```
  </Tab>

  <Tab title="Simple Error Handling">
    ```javascript
    async function safeGetPriorityFeeEstimate(connection, serializedTransaction, priorityLevel = "Medium") {
      try {
        return await getPriorityFeeEstimate(connection, serializedTransaction, priorityLevel);
      } catch (error) {
        console.warn(`Priority fee estimation failed: ${error.message}`);
        
        // Extract account keys and fall back to account-based estimation
        try {
          const transaction = Transaction.from(bs58.decode(serializedTransaction));
          const accountKeys = transaction.instructions
            .flatMap(ix => [ix.programId, ...ix.keys.map(k => k.pubkey)])
            .map(key => key.toString());
          
          const uniqueAccountKeys = [...new Set(accountKeys)];
          return await getAccountBasedEstimate(connection, uniqueAccountKeys, priorityLevel);
        } catch (fallbackError) {
          console.warn(`Fallback estimation failed: ${fallbackError.message}`);
          
          // Return reasonable fallback based on priority level
          const fallbacks = {
            "Low": 1000,
            "Medium": 5000,
            "High": 15000,
            "VeryHigh": 50000
          };
          
          return fallbacks[priorityLevel] || 5000;
        }
      }
    }
    ```
  </Tab>
</Tabs>

## Common Issues & Solutions

<AccordionGroup>
  <Accordion title="Transaction Serialization Errors">
    **Problem**: Error serializing incomplete transactions

    **Solution**: Always set required fields before serialization:

    ```javascript
    //  Always set these fields
    transaction.recentBlockhash = (await connection.getLatestBlockhash()).blockhash;
    transaction.feePayer = keypair.publicKey;

    // Then serialize
    const serialized = bs58.encode(transaction.serialize());
    ```
  </Accordion>

  <Accordion title="Stale Blockhash Issues">
    **Problem**: Using stale blockhash causes transaction failures

    **Solution**: Always get fresh blockhash before final send:

    ```javascript
    // Get estimate with temporary blockhash
    const tempBlockhash = (await connection.getLatestBlockhash()).blockhash;
    transaction.recentBlockhash = tempBlockhash;
    const serialized = bs58.encode(transaction.serialize());

    const priorityFee = await getPriorityFeeEstimate(connection, serialized, "Medium");

    // Reset and rebuild with fresh blockhash
    transaction.instructions = [];
    transaction.add(ComputeBudgetProgram.setComputeUnitPrice({ microLamports: priorityFee }));
    transaction.add(originalInstruction);

    // Get FRESH blockhash before sending
    const freshBlockhash = (await connection.getLatestBlockhash()).blockhash;
    transaction.recentBlockhash = freshBlockhash;
    ```
  </Accordion>

  <Accordion title="Large Transaction Errors">
    **Problem**: Transaction too large for serialization

    **Solution**: Use versioned transactions or break into multiple transactions:

    ```javascript
    import { VersionedTransaction, TransactionMessage } from "@solana/web3.js";

    // For large transactions, use versioned transactions
    const messageV0 = new TransactionMessage({
      payerKey: keypair.publicKey,
      recentBlockhash: (await connection.getLatestBlockhash()).blockhash,
      instructions: [instruction1, instruction2, instruction3] // Many instructions
    }).compileToV0Message();

    const versionedTransaction = new VersionedTransaction(messageV0);
    const serialized = bs58.encode(versionedTransaction.serialize());
    ```
  </Accordion>
</AccordionGroup>

## When to Use vs Account Keys

<CardGroup cols={2}>
  <Card title="Use Serialized Transactions" icon="check">
    **Production applications**

    * Maximum accuracy required
    * Complex multi-instruction transactions
    * Critical operations
    * Performance-sensitive applications

    **Development scenarios**

    * Final integration testing
    * Performance optimization
    * Production deployment
  </Card>

  <Card title="Use Account Keys" icon="info">
    **Development & prototyping**

    * Quick estimates during development
    * Simple transactions
    * Pre-transaction planning
    * Architecture constraints preventing serialization

    **Analysis scenarios**

    * Account-level fee pattern analysis
    * Batch account analysis
    * Quick market research
  </Card>
</CardGroup>

## Related Resources

<CardGroup cols={2}>
  <Card title="Account Keys Method" icon="key" href="/priority-fee/estimating-fees-using-account-keys">
    Advanced method using account keys for specialized use cases
  </Card>

  <Card title="API Reference" icon="book" href="/api-reference/priority-fee/getpriorityfeeestimate">
    Complete API documentation and parameters
  </Card>
</CardGroup>


# Build Your First Solana App with Helius
Source: https://www.helius.dev/docs/quickstart

Learn the fundamentals of building on Solana by creating your first application using Helius APIs. From setup to deployment in minutes.

export const Quickstart = () => {
  const [apiKey, setApiKey] = useState('');
  const [ownerAddress, setOwnerAddress] = useState('86xCnPeV69n6t3DnyGvkKobf9FdN2H9oiVDdaMpo2MMY');
  const [loading, setLoading] = useState(false);
  const [randomNft, setRandomNft] = useState(null);
  const [error, setError] = useState(null);
  const handleSubmit = async e => {
    e.preventDefault();
    setLoading(true);
    setError(null);
    setRandomNft(null);
    try {
      const response = await fetch(`https://mainnet.helius-rpc.com/?api-key=${apiKey}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          jsonrpc: '2.0',
          id: '1',
          method: 'getAssetsByOwner',
          params: {
            ownerAddress
          }
        })
      });
      const data = await response.json();
      if (data.error) {
        setError(data.error.message || 'Error calling API');
      } else if (data.result && data.result.items && data.result.items.length > 0) {
        const randomIndex = Math.floor(Math.random() * data.result.items.length);
        const selectedNft = data.result.items[randomIndex];
        setRandomNft(selectedNft);
      } else {
        setError('No NFTs found for this wallet');
      }
    } catch (err) {
      setError(err.message || 'Failed to fetch data');
    } finally {
      setLoading(false);
    }
  };
  return <div className="p-4 border dark:border-zinc-950/80 rounded-xl bg-white dark:bg-zinc-950/80 shadow-sm">      
      <form onSubmit={handleSubmit} className="space-y-4">
        <div>
          <label className="block text-sm text-zinc-950/70 dark:text-white/70 mb-1">Your API Key</label>
          <input type="text" value={apiKey} onChange={e => setApiKey(e.target.value)} placeholder="Enter your API key" className="w-full p-2 border rounded dark:bg-zinc-900 dark:border-zinc-700" required />
        </div>
        
        <div>
          <label className="block text-sm text-zinc-950/70 dark:text-white/70 mb-1">Owner Address</label>
          <input type="text" value={ownerAddress} onChange={e => setOwnerAddress(e.target.value)} placeholder="Solana wallet address" className="w-full p-2 border rounded dark:bg-zinc-900 dark:border-zinc-700" required />
        </div>
        
        <button type="submit" disabled={loading} className={`px-4 py-2 rounded font-medium rounded-full ${loading ? 'bg-gray-300 dark:bg-gray-700 cursor-not-allowed' : 'bg-primary hover:bg-primary/80 text-white'}`}>
          {loading ? 'Loading...' : 'Get Random NFT'}
        </button>
      </form>
      
      {error && <div className="mt-4 p-3 bg-red-100 dark:bg-red-900/30 border border-red-200 dark:border-red-800 rounded text-red-700 dark:text-red-300">
          <strong>Error:</strong> {error}
        </div>}
      
      {randomNft && <div className="mt-6">
          <div className="text-center mb-4">
            <h3 className="text-lg font-semibold mb-1 text-zinc-950 dark:text-white">
              {randomNft.content?.metadata?.name || 'Unnamed NFT'}
            </h3>
            <div className="flex items-center justify-center gap-2">
              <p className="text-sm text-zinc-600 dark:text-zinc-400">
                {randomNft.id}
              </p>
              <a href={`https://orb.helius.dev/address/${randomNft.id}?cluster=mainnet-beta`} target="_blank" rel="noopener noreferrer" className="text-primary hover:text-primary/80 transition-colors" title="View on Orb Explorer">
                <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14" />
                </svg>
              </a>
            </div>
          </div>
          
          <div className="flex justify-center mb-4">
            {randomNft.content?.files && randomNft.content.files.length > 0 && randomNft.content.files[0].uri ? <img src={randomNft.content.files[0].uri} alt={randomNft.content?.metadata?.name || 'NFT'} className="rounded-lg max-h-64 border border-zinc-200 dark:border-zinc-800 shadow-sm" /> : <div className="bg-gray-200 dark:bg-zinc-800 rounded-lg w-64 h-64 flex items-center justify-center">
                <span className="text-zinc-500 dark:text-zinc-400">No image available</span>
              </div>}
          </div>
          
          
        </div>}
    </div>;
};

Ready to build on Solana? This guide will walk you through creating your first application using Helius APIs. You'll learn how to fetch NFT data, understand the response structure, and see how easy it is to build powerful applications with our infrastructure.

<Steps titleSize="h2">
  <Step title="Create Your Free Helius Account">
    Start by creating your free account at the [Helius Dashboard](https://dashboard.helius.dev/dashboard). Your free tier includes 100,000 DAS API calls per month; perfect for getting started and building prototypes.
  </Step>

  <Step title="Get Your API Key">
    Navigate to the [API Keys](https://dashboard.helius.dev/api-keys) section and copy your key. This key gives you access to all Helius APIs, including RPC nodes, DAS API, and enhanced transaction data.
  </Step>

  <Step title="Make Your First API Call">
    Let's start with a practical example: fetching NFTs from a wallet. We'll use the [getAssetsByOwner](/api-reference/das/getassetsbyowner) method to query assets owned by `86xCno2MMY` (Anatoly Yakovenko's wallet, co-founder of Solana).

    <Quickstart />

    **What's happening here?** The DAS API allows you to query compressed and standard NFTs with a single call. Notice how the response includes metadata, image URLs, and ownership information - all the data you need to build rich user experiences.
  </Step>

  <Step title="Understanding the Response">
    Great! You've successfully fetched NFT data. The response includes:

    * **Asset ID**: Unique identifier for each NFT
    * **Metadata**: Name, symbol, description, and attributes
    * **Content**: Image URLs and file information
    * **Ownership**: Current owner and authority information
  </Step>
</Steps>

## Build It with Code

Now let's implement this in a real application. We'll create a simple NFT portfolio viewer that you can expand upon.

<Note>
  We'll use Node.js for this example. Make sure you have it installed from [nodejs.org](https://nodejs.org/en/download).
</Note>

<Steps titleSize="h3">
  <Step title="Set up your project">
    ```bash
    mkdir solana-nft-viewer
    cd solana-nft-viewer
    npm init -y
    npm install node-fetch
    ```
  </Step>

  <Step title="Create the NFT portfolio viewer">
    ```javascript nft-portfolio.js
    const fetch = require('node-fetch');

    class NFTPortfolioViewer {
      constructor(apiKey) {
        this.apiKey = apiKey;
        this.baseUrl = 'https://mainnet.helius-rpc.com';
      }

      async fetchNFTsByOwner(ownerAddress, limit = 10) {
        try {
          const response = await fetch(`${this.baseUrl}/?api-key=${this.apiKey}`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              jsonrpc: '2.0',
              id: '1',
              method: 'getAssetsByOwner',
              params: {
                ownerAddress,
                page: 1,
                limit,
                displayOptions: {
                  showFungible: false,
                  showNativeBalance: false,
                },
              },
            }),
          });

          const data = await response.json();

          if (data.error) {
            throw new Error(data.error.message);
          }

          return data.result;
        } catch (error) {
          console.error('Error fetching NFTs:', error.message);
          throw error;
        }
      }

      displayNFTPortfolio(nfts) {
        console.log('\n  NFT Portfolio Summary');
        console.log('========================');
        console.log(`Total NFTs: ${nfts.total}`);
        console.log(`Showing: ${nfts.items.length} items\n`);

        nfts.items.forEach((nft, index) => {
          console.log(`${index + 1}. ${nft.content?.metadata?.name || 'Unnamed NFT'}`);
          console.log(`   Collection: ${nft.grouping?.[0]?.group_value || 'Individual'}`);
          console.log(`   Compressed: ${nft.compression?.compressed ? 'Yes' : 'No'}`);
          console.log(`   Image: ${nft.content?.files?.[0]?.uri || 'No image'}`);
          console.log(`   ID: ${nft.id}\n`);
        });
      }

      async getRandomNFT(ownerAddress) {
        const portfolio = await this.fetchNFTsByOwner(ownerAddress, 50);
        
        if (portfolio.items.length === 0) {
          console.log('No NFTs found for this address.');
          return null;
        }

        const randomIndex = Math.floor(Math.random() * portfolio.items.length);
        return portfolio.items[randomIndex];
      }
    }

    // Usage example
    async function main() {
      const viewer = new NFTPortfolioViewer('YOUR_API_KEY');
      
      // Anatoly's wallet address
      const walletAddress = '86xCnPeV69n6t3DnyGvkKobf9FdN2H9oiVDdaMpo2MMY';
      
      console.log(' Fetching NFT portfolio...');
      
      try {
        // Get full portfolio overview
        const portfolio = await viewer.fetchNFTsByOwner(walletAddress);
        viewer.displayNFTPortfolio(portfolio);
        
        // Get a random NFT for featured display
        console.log(' Featured Random NFT:');
        console.log('=====================');
        const randomNFT = await viewer.getRandomNFT(walletAddress);
        
        if (randomNFT) {
          console.log(`Name: ${randomNFT.content?.metadata?.name}`);
          console.log(`Description: ${randomNFT.content?.metadata?.description || 'No description'}`);
          console.log(`Image: ${randomNFT.content?.files?.[0]?.uri}`);
        }
        
      } catch (error) {
        console.error('Failed to fetch NFT data:', error.message);
      }
    }

    main();
    ```
  </Step>

  <Step title="Add your API key">
    Replace `YOUR_API_KEY` with your actual API key from the Helius dashboard.
  </Step>

  <Step title="Run your NFT portfolio viewer">
    ```bash
    node nft-portfolio.js
    ```
  </Step>

  <Step title="Success! ">
    You've built your first Solana application! The output shows:

    * Total NFT count in the wallet
    * Individual NFT details including compression status
    * Collection information
    * A featured random NFT

    **What you've learned:**

    * How to structure API calls to Helius
    * Working with the DAS API response format
    * Handling compressed vs standard NFTs
    * Building reusable code for NFT operations
  </Step>
</Steps>

## Take It Further

Now that you understand the basics, explore these advanced features:

<CardGroup cols={2}>
  <Card title="Send Transactions" icon="paper-plane" href="sending-transactions/quickstart">
    Learn transaction optimization, priority fees, and smart routing for reliable execution.
  </Card>

  <Card title="Advanced NFT Operations" icon="images" href="/das/get-nfts">
    Search NFTs by traits, fetch collection stats, and work with token metadata at scale.
  </Card>

  <Card title="Real-Time Data Streaming" icon="bolt" href="/data-streaming/quickstart">
    Stream live blockchain data with sub-second latency using gRPC or enhanced WebSockets.
  </Card>

  <Card title="Automate with Webhooks" icon="bell" href="/webhooks">
    Set up intelligent notifications for wallet activity, NFT sales, and custom on-chain events.
  </Card>
</CardGroup>

## What's Next?

You've successfully built your first Solana application with Helius! Here are some ideas to expand your project:

* **Add wallet connection**: Integrate with wallets
* **Build a UI**: Create a React/Vue frontend to display the portfolio
* **Add filtering**: Search by collection, traits, or mint date
* **Real-time updates**: Use WebSockets to show live portfolio changes
* **Analytics**: Track portfolio value and NFT price history


# How to Get Devnet SOL
Source: https://www.helius.dev/docs/rpc/devnet-sol

Sign in to your Helius account and visit our Solana Devnet faucet to get free Devnet SOL for testing your Solana programs.

Solana Devnet is a testing environment that replicates Solana Mainnet Beta for developers to test their applications without using real SOL. Devnet SOL is used for testing transactions, deploying programs, and experimenting with on-chain apps before going live on Solana Mainnet Beta.

<Note>
  A paid Helius plan is required to access the Devnet faucet and request Devnet SOL airdrops from Helius.
</Note>

## How to Get Devnet SOL from the CLI

### Prerequisites

To use the CLI method, ensure you have:

* **Paid Helius Plan**: a paid subscription to access the Devnet faucet
* **Solana CLI**: [install the Solana CLI tools](https://solana.com/docs/intro/installation#install-the-solana-cli)
* **Helius Devnet RPC Endpoint**: get your [Devnet RPC URL](https://dashboard.helius.dev/endpoints) from your dashboard

### Step 1: Check your default keypair

First, verify your current keypair and wallet address:

```bash
solana address
```

If you don't have a keypair, create one:

```bash
solana-keygen new
```

### Step 2: Set your CLI config to use the Helius Devnet RPC endpoint

Configure your Solana CLI to use your Helius Devnet RPC URL:

```bash
solana config set --url https://devnet.helius-rpc.com/?api-key=<your-api-key>
```

Verify your configuration:

```bash
solana config get
```

### Step 3: Request a Devnet SOL airdrop

Request an airdrop of Devnet SOL to your wallet:

```bash
solana airdrop 1
```

### Step 4: Check your balance

Verify that the Devnet SOL was successfully added to your wallet:

```bash
solana balance
```

## How to Get Devnet SOL from the UI

### Prerequisites

To use the UI method, ensure you have:

* **Paid Helius Plan**: a paid subscription to access the Devnet faucet

### Step 1: Log in to your dashboard

Sign in to your [Helius Dashboard](https://dashboard.helius.dev).

### Step 2: Go to the Devnet Faucet page

In the sidebar navigation menu, click "Faucet" to access the [Devnet faucet](https://dashboard.helius.dev/faucet) page.

<Frame>
  ![Devnet faucet location in dashboard navigation](https://mintlify.s3.us-west-1.amazonaws.com/helius/images/helius-devnet-faucet.png)
</Frame>

### Step 3: Enter your Solana address

Enter your Solana wallet address in the provided field. You can get your wallet address from your Solana CLI using `solana address` or copy it from your wallet application.

### Step 4: Request Devnet SOL

Click "Airdrop 1 SOL" to receive your Devnet tokens.

### Step 5: Verify the transaction

Once your request is processed, you'll see a confirmation message with the transaction signature. You can verify the transaction on a [Solana explorer](https://orb.helius.dev/) or check your wallet balance.

## Conclusion

Getting Devnet SOL is essential for testing your Solana applications safely before deploying to mainnet. With a paid Helius plan, you can obtain Devnet SOL through either the Solana CLI or the Solana Devnet faucet in your dashboard.

### Next Steps

Continue learning about Solana development with these guides and references:

* [Maximize RPC performance](/rpc/optimization-techniques)
* Land transactions using [Sender](/sending-transactions/sender)
* Stream real-time data using [LaserStream](/laserstream)
* Explore and test [API Reference](/api-reference) for all RPC methods
* Understand [pricing and rate limits](/billing/plans-and-rate-limits) for your Helius plan


# How to Use getAccountInfo
Source: https://www.helius.dev/docs/rpc/guides/getaccountinfo

Learn getAccountInfo use cases, code examples, request parameters, response structure, and tips.

The [`getAccountInfo`](https://www.helius.dev/docs/api-reference/rpc/http/getaccountinfo) RPC method is a fundamental tool for querying the Solana blockchain. It allows you to retrieve all stored information associated with a specific account public key. This includes the account's lamport balance, the program that owns it, whether it's executable, and its stored data.

## Common Use Cases

* **Checking SOL Balance:** Determine the native SOL balance of any account.
* **Verifying Account Existence:** Check if an account with a given public key has been initialized (i.e., has lamports or data).
* **Inspecting Program Accounts:** Retrieve the data stored within an account owned by a program, which is crucial for understanding a program's state.
* **Identifying Account Owner:** Find out which program is the owner of an account. This helps determine how the account's data should be interpreted or if it's a system-owned account.
* **Checking if an Account is Executable:** Identify if an account contains a deployed program.

## Parameters

1. `publicKey` (string, required): The base-58 encoded public key of the account to query.

2. `config` (object, optional): A configuration object with the following fields:
   * `commitment` (string, optional): Specifies the [commitment level](https://www.helius.dev/blog/solana-commitment-levels) to use for the query. Defaults to `finalized`.
     * `finalized`: The node will query the most recent block confirmed by the supermajority of the cluster as having reached maximum lockout.
     * `confirmed`: The node will query the most recent block that has been voted on by a supermajority of the cluster.
     * `processed`: The node will query its most recent block. Note that the block may not be complete.
   * `encoding` (string, optional): The encoding for account data. Defaults to `base64`.
     * `base58` (slow)
     * `base64`
     * `base64+zstd` (if data is compressed)
     * `jsonParsed`: If the account data is a known program state (e.g., token accounts, stake accounts), the node will attempt to parse it into a JSON structure. For generic program accounts, this usually falls back to binary (base64).
   * `dataSlice` (object, optional): Limits the returned account data to a specific slice. Only available for `base58`, `base64`, or `base64+zstd` encodings.
     * `offset` (number): The number of bytes from the start of the account data to begin the slice.
     * `length` (number): The number of bytes to return.
   * `minContextSlot` (number, optional): The minimum slot that the request can be evaluated at.

## Response

If the account is found, the `result` field will contain an object with two main properties:

* `context` (object): Contains metadata about the request.
  * `slot` (number): The slot at which the information was retrieved.
  * `apiVersion` (string, optional): The RPC API version.

* `value` (object | null): If the account does not exist, this will be `null`. Otherwise, it's an object containing:
  * `lamports` (number): The number of lamports (1 SOL = 1,000,000,000 lamports) owned by the account.
  * `owner` (string): The base-58 encoded public key of the program that owns this account.
  * `data` (array | object | string): The data stored in the account. The format depends on the `encoding` parameter used in the request.
    * For `base64` (default), `base58`, `base64+zstd`: This is typically an array `[encoded_string, encoding_format]`, e.g., `["string_data", "base64"]`.
    * For `jsonParsed`: This can be a JSON object if the data is parsable by the RPC node (e.g., for SPL Token accounts). Otherwise, it may default to `["", "base64"]` or similar if the data isn't recognized as a standard layout.
  * `executable` (boolean): `true` if the account contains a program, `false` otherwise.
  * `rentEpoch` (number): The next epoch at which this account will owe rent.
  * `space` (number, optional): The length of the data in bytes. (Note: The official Solana docs list `space`, while some RPC providers might include it. It represents the total space allocated for the account's data). For more details on [account data and deserialization](https://www.helius.dev/blog/solana-dev-101-deserializing-account-data-on-solana), refer to our detailed guide.

If the account is not found, the `value` field in the result will be `null`.

## Example: Fetching Account Information

Let's fetch information for the Serum Program V3 ID (`9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin`) on mainnet.

**Note:** Replace `YOUR_API_KEY` with your actual Helius API key in the examples below.

<CodeGroup>
  ```bash curl
  curl https://mainnet.helius-rpc.com/?api-key=YOUR_API_KEY -X POST -H "Content-Type: application/json" -d \
  '{
    "jsonrpc": "2.0",
    "id": 1,
    "method": "getAccountInfo",
    "params": [
      "9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin",
      {
        "encoding": "jsonParsed"
      }
    ]
  }'
  ```

  ```javascript JavaScript (using @solana/web3.js)
  const { Connection, PublicKey } = require('@solana/web3.js');

  async function getAccountDetails() {
    const rpcUrl = 'https://mainnet.helius-rpc.com/?api-key=YOUR_API_KEY'; // Replace YOUR_API_KEY
    const connection = new Connection(rpcUrl, 'confirmed');
    const accountPubKey = new PublicKey('9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin');

    try {
      const accountInfo = await connection.getAccountInfo(accountPubKey);

      if (accountInfo === null) {
        console.log('Account not found.');
        return;
      }

      console.log('Account Info:');
      console.log(`   Lamports: ${accountInfo.lamports}`);
      console.log(`   Owner: ${accountInfo.owner.toBase58()}`);
      console.log(`   Executable: ${accountInfo.executable}`);
      console.log(`   Rent Epoch: ${accountInfo.rentEpoch}`);
      // Data is a Buffer, you might need to deserialize it based on the account type
      // console.log(`   Data: ${accountInfo.data.toString()}`); 
    } catch (error) {
      console.error('Error fetching account info:', error);
    }
  }

  getAccountDetails();
  ```

  ```typescript Kit
  import { address, createSolanaRpc } from "@solana/kit";

  const rpc_url = "https://mainnet.helius-rpc.com/?api-key=YOUR_API_KEY";
  const rpc = createSolanaRpc(rpc_url);

  const publicKey = address("vines1vzrYbzLMRdu58ou5XTby4qAqVRLmqo36NKPTg");
  const accountInfo = await rpc.getAccountInfo(publicKey).send();

  console.log("Account Info:", accountInfo);
  ```

  ```rust Rust
  use solana_client::nonblocking::rpc_client::RpcClient;
  use solana_sdk::{commitment_config::CommitmentConfig, pubkey::Pubkey};
  use anyhow::Result;
  use std::str::FromStr;

  #[tokio::main]
  async fn main() -> Result<()> {
      let client = RpcClient::new_with_commitment(
          String::from("https://mainnet.helius-rpc.com/?api-key=YOUR_API_KEY"),
          CommitmentConfig::confirmed()
      );
      let pubkey = Pubkey::from_str("vines1vzrYbzLMRdu58ou5XTby4qAqVRLmqo36NKPTg")?;
      let account = client.get_account(&pubkey).await?;

      println!("{:#?}", account);

      Ok(())
  }
  ```
</CodeGroup>

## Developer Tips

* **Performance:** For applications requiring frequent checks of multiple accounts, consider using `getMultipleAccounts` to batch requests and reduce round trips.
* **Data Deserialization:** The `data` field often requires deserialization based on the owning program's data structures. Tools and libraries specific to the program (e.g., SPL Token library for token accounts) are usually needed. Our blog post on [deserializing account data](https://www.helius.dev/blog/solana-dev-101-deserializing-account-data-on-solana) provides helpful techniques and examples.
* **Rate Limits:** Be mindful of RPC node rate limits, especially when querying a large number of accounts or making frequent requests.
* **Cost Management:** `getAccountInfo` is generally a low-cost query, but frequent polling can add up. Optimize your query patterns.
* **Use `jsonParsed` Wisely:** While `jsonParsed` can be convenient, it might not support all account types, and its output can change if a program updates its data structures. For critical applications, parsing binary data with a known layout offers more stability.
* **Consider `dataSlice`:** If you only need a small portion of an account's data, use `dataSlice` to reduce the amount of data transferred and potentially lower query costs.


# How to Use getBalance
Source: https://www.helius.dev/docs/rpc/guides/getbalance

Learn getBalance use cases, code examples, request parameters, response structure, and tips.

The [`getBalance`](https://www.helius.dev/docs/api-reference/rpc/http/getbalance) RPC method is a straightforward way to find out the native SOL balance of any account on the Solana blockchain. It returns the balance in lamports (1 SOL = 1,000,000,000 lamports).

This method is more lightweight than `getAccountInfo` if you *only* need the SOL balance and no other account details.

## Main Use Case

* **Quickly Checking an Account's SOL Holdings:** The primary use is to determine how much SOL an account (wallet, program, etc.) holds.

## Parameters

1. `publicKey` (string, required): The base-58 encoded public key of the account to query.

2. `config` (object, optional): A configuration object with the following fields:
   * `commitment` (string, optional): Specifies the [commitment level](https://www.helius.dev/blog/solana-commitment-levels) to use for the query. Defaults to `finalized`.
     * `finalized`: The node will query the most recent block confirmed by the supermajority of the cluster as having reached maximum lockout.
     * `confirmed`: The node will query the most recent block that has been voted on by a supermajority of the cluster.
     * `processed`: The node will query its most recent block. Note that the block may not be complete.
   * `minContextSlot` (number, optional): The minimum slot that the request can be evaluated at.

## Response

The `result` field of the JSON-RPC response will be an object containing:

* `context` (object):
  * `slot` (number): The slot at which the balance was retrieved.
  * `apiVersion` (string, optional): The RPC API version (may not be present from all nodes).
* `value` (number): The balance of the account in lamports (unsigned 64-bit integer).

If the account does not exist on-chain, `getBalance` will typically return a value of `0` lamports.

## Example: Fetching an Account's Balance

Let's check the SOL balance of the Serum Program V3 ID (`9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin`) on mainnet. This program account itself holds SOL for rent exemption.

**Note:** Replace `YOUR_API_KEY` with your actual Helius API key in the examples below.

<CodeGroup>
  ```bash curl
  curl https://mainnet.helius-rpc.com/?api-key=YOUR_API_KEY -X POST -H "Content-Type: application/json" -d \
  '{
    "jsonrpc": "2.0",
    "id": 1,
    "method": "getBalance",
    "params": [
      "9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin"
    ]
  }'
  ```

  ```javascript JavaScript (using @solana/web3.js)
  const { Connection, PublicKey, LAMPORTS_PER_SOL } = require('@solana/web3.js');

  async function checkBalance() {
    const rpcUrl = 'https://mainnet.helius-rpc.com/?api-key=YOUR_API_KEY'; // Replace YOUR_API_KEY
    const connection = new Connection(rpcUrl, 'confirmed');
    const accountPubKey = new PublicKey('9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin');

    try {
      const lamports = await connection.getBalance(accountPubKey);
      const sol = lamports / LAMPORTS_PER_SOL;

      console.log(`Account PubKey: ${accountPubKey.toBase58()}`);
      console.log(`Balance (Lamports): ${lamports}`);
      console.log(`Balance (SOL): ${sol}`);

    } catch (error) {
      console.error('Error fetching balance:', error);
    }
  }

  checkBalance();
  ```

  ```typescript Kit
  import { address, createSolanaRpc } from "@solana/kit";

  const rpc_url = "https://mainnet.helius-rpc.com/?api-key=YOUR_API_KEY";
  const rpc = createSolanaRpc(rpc_url);

  const publicKey = address("83astBRguLMdt2h5U1Tpdq5tjFoJ6noeGwaY3mDLVcri");
  const balance = await rpc.getBalance(publicKey).send();

  console.log("Account Balance:", balance);
  ```

  ```rust Rust
  use anyhow::Result;
  use solana_client::nonblocking::rpc_client::RpcClient;
  use solana_sdk::{
      commitment_config::CommitmentConfig, native_token::LAMPORTS_PER_SOL, pubkey::Pubkey,
  };
  use std::str::FromStr;

  #[tokio::main]
  async fn main() -> Result<()> {
      let client = RpcClient::new_with_commitment(
          String::from("https://mainnet.helius-rpc.com/?api-key=YOUR_API_KEY"),
          CommitmentConfig::confirmed(),
      );

      let pubkey = Pubkey::from_str("83astBRguLMdt2h5U1Tpdq5tjFoJ6noeGwaY3mDLVcri")?;
      let balance = client.get_balance(&pubkey).await?;

      println!("{:#?} SOL", balance / LAMPORTS_PER_SOL);

      Ok(())
  }
  ```
</CodeGroup>

## Developer Tips

* **Simplicity for SOL Balance:** If you only need an account's SOL balance and no other on-chain data (like owner, data, or executable status), `getBalance` is more efficient than `getAccountInfo` as it fetches less data.
* **Non-Existent Accounts:** If an account does not exist on-chain (has never been initialized or had SOL), `getBalance` will return `0`. This can be a quick way to check for account existence if you only care about its SOL balance.
* **Lamports vs. SOL:** Remember that the balance is returned in lamports. You'll need to divide by `LAMPORTS_PER_SOL` (1,000,000,000) to convert it to SOL.
* **Commitment Levels:** The choice of `commitment` can affect how quickly you get the balance and how confirmed that balance is. For most UI display purposes, `confirmed` offers a good balance. For critical financial transactions, `finalized` provides the highest assurance. See [Solana Commitment Levels](https://www.helius.dev/blog/solana-commitment-levels) for detailed information.
* **Batching with `getMultipleAccounts`:** While `getBalance` is for a single account, if you need balances for many accounts, using `getMultipleAccounts` and then extracting the lamport balance from each account's info can be more performant than many individual `getBalance` calls.


# How to Use getBlock
Source: https://www.helius.dev/docs/rpc/guides/getblock

Learn getBlock use cases, code examples, request parameters, response structure, and tips.

The [`getBlock`](https://www.helius.dev/docs/api-reference/rpc/http/getblock) RPC method allows you to retrieve detailed information about a confirmed block in the Solana ledger. This is essential for block explorers, transaction history analysis, and understanding the state of the chain at a specific point in time.

## Common Use Cases

* **Inspecting Block Contents:** View all transactions included in a specific [block](https://www.helius.dev/blog/solana-slots-blocks-and-epochs).
* **Retrieving Block Hashes:** Get the blockhash for a given slot, its parent's blockhash, and its parent slot.
* **Checking Block Height and Time:** Find out a block's height (its sequence number) and its estimated production time.
* **Analyzing Transaction Details:** With appropriate parameters, you can get full transaction data, including metadata like fees, status, pre/post balances, and inner instructions.
* **Fetching Rewards:** Optionally include reward information for the block.

## Parameters

1. `slot` (number, required): The slot number of the block to query (u64).

2. `config` (object, optional): A configuration object with the following fields:
   * `commitment` (string, optional): Specifies the [commitment level](https://www.helius.dev/blog/solana-commitment-levels) to use. `processed` is not supported for this method. Defaults to `finalized`.
   * `encoding` (string, optional): The encoding for transaction data. Defaults to `json` if `transactionDetails` is `full` or `accounts`, otherwise `base64`.
     * `json`: Returns transactions and accounts data in JSON format (deprecated in favor of `jsonParsed`).
     * `jsonParsed`: Returns transactions and accounts data as parsed JSON. This is recommended as it includes all transaction account keys (including those from Address Lookup Tables).
     * `base58` (slow)
     * `base64`
     * `base64+zstd`
   * `transactionDetails` (string, optional): Specifies the level of transaction detail to return. Defaults to `full`.
     * `full`: Returns full transaction details, including transaction metadata.
     * `accounts`: Returns a list of accounts detailed in each transaction, but not the full transaction data or metadata.
     * `signatures`: Returns only the transaction signatures.
     * `none`: Returns no transaction details.
   * `rewards` (boolean, optional): Whether to include the rewards array in the response. Defaults to `false`.
   * `maxSupportedTransactionVersion` (number, optional): The maximum transaction version to return. If the block contains a transaction with a higher version, an error is returned. If omitted, only legacy transactions are returned, and a block with any versioned transaction will cause an error. Set to `0` to include versioned transactions that use Address Lookup Tables.

## Response

If the specified block is confirmed and found, the `result` field will be an object containing information about the block. If the block is not found or not confirmed, `result` will be `null`.

Key fields in the block object include:

* `blockhash` (string): The base-58 encoded blockhash for this block.
* `previousBlockhash` (string): The base-58 encoded blockhash of the previous block. If the parent is not available (due to ledger cleanup), this might be the system program ID.
* `parentSlot` (number): The slot number of the parent block.
* `transactions` (array): An array of transaction objects included in the block. The structure of these objects depends on the `encoding` and `transactionDetails` parameters.
  * Each transaction object typically contains `meta` (metadata like fee, status, logs, pre/post balances) and `transaction` (the actual transaction data, including message and signatures).
* `rewards` (array, optional): An array of reward objects, present if `rewards: true` was specified. Each object details the `pubkey`, `lamports`, `postBalance`, `rewardType`, and potentially `commission`.
* `blockTime` (number | null): The estimated production time of the block as a Unix timestamp (seconds since epoch), or `null` if not available.
* `blockHeight` (number | null): The height of this block (number of blocks before it in the chain originating from slot 0), or `null` if not available.

Refer to the official Solana RPC documentation for the complete and detailed structure of the transaction and meta objects within the response.

## Example: Fetching Block Information

Let's try to fetch information for an illustrative slot number on Devnet.
**Important:** Slot numbers are processed rapidly. The slot number used below (`250000000`) is a placeholder. You should replace it with a recent, confirmed slot that you know exists on your target network (e.g., Devnet or Mainnet) when you run the example. You can find recent slot numbers using a Solana block explorer.

**Note:** Replace `YOUR_API_KEY` with your actual Helius API key in the examples below.

<CodeGroup>
  ```bash curl
  # Replace 250000000 with a valid, recent slot number on Devnet/Mainnet
  curl https://mainnet.helius-rpc.com/?api-key=YOUR_API_KEY -X POST -H "Content-Type: application/json" -d \
  '{
    "jsonrpc": "2.0",
    "id": 1,
    "method": "getBlock",
    "params": [
      250000000, 
      {
        "encoding": "jsonParsed",
        "transactionDetails": "full",
        "rewards": true,
        "maxSupportedTransactionVersion": 0
      }
    ]
  }'
  ```

  ```javascript JavaScript (using @solana/web3.js)
  const { Connection } = require('@solana/web3.js');

  async function getBlockDetails() {
    const rpcUrl = 'https://mainnet.helius-rpc.com/?api-key=YOUR_API_KEY'; // Replace YOUR_API_KEY
    const connection = new Connection(rpcUrl, 'confirmed');
    
    // Replace with a valid, recent slot number on your target network
    const slotToQuery = 250000000; 

    try {
      const block = await connection.getBlock(slotToQuery, {
        encoding: "jsonParsed",
        transactionDetails: "full",
        rewards: true,
        maxSupportedTransactionVersion: 0 
      });

      if (block) {
        console.log('Block Details:');
        console.log(`   Slot: ${slotToQuery}`);
        console.log(`   Blockhash: ${block.blockhash}`);
        console.log(`   Previous Blockhash: ${block.previousBlockhash}`);
        console.log(`   Parent Slot: ${block.parentSlot}`);
        console.log(`   Block Height: ${block.blockHeight !== null ? block.blockHeight : 'N/A'}`);
        console.log(`   Block Time: ${block.blockTime ? new Date(block.blockTime * 1000).toISOString() : 'N/A'}`);
        console.log(`   Transactions Count: ${block.transactions.length}`);
        // console.log('   Transactions:', JSON.stringify(block.transactions, null, 2)); // Full transaction details
        // console.log('   Rewards:', JSON.stringify(block.rewards, null, 2)); // Reward details
      } else {
        console.log(`Block at slot ${slotToQuery} not found or not confirmed.`);
      }
    } catch (error) {
      console.error(`Error fetching block ${slotToQuery}:`, error);
    }
  }

  getBlockDetails();
  ```

  ```typescript Kit
  import { createSolanaRpc } from "@solana/kit";

  const rpc_url = "https://mainnet.helius-rpc.com/?api-key=YOUR_API_KEY";
  const rpc = createSolanaRpc(rpc_url);

  const slot_number = BigInt(377261141);

  let block = await rpc
    .getBlock(
      slot_number,
      {
        commitment: "finalized",
        encoding: "json",
        transactionDetails: "full",
        maxSupportedTransactionVersion: 0,
        rewards: false,
      },
    )
    .send();

  console.log("block:", block);
  ```

  ```rust Rust
  use anyhow::Result;
  use solana_client::nonblocking::rpc_client::RpcClient;
  use solana_sdk::commitment_config::CommitmentConfig;
  use solana_transaction_status_client_types::{TransactionDetails, UiTransactionEncoding};

  #[tokio::main]
  async fn main() -> Result<()> {
      let client = RpcClient::new_with_commitment(
          String::from("https://mainnet.helius-rpc.com/?api-key=YOUR_API_KEY"),
          CommitmentConfig::confirmed(),
      );

      let slot_number = 377261141;

      let config = solana_client::rpc_config::RpcBlockConfig {
          encoding: UiTransactionEncoding::Base58.into(),
          transaction_details: TransactionDetails::Full.into(),
          rewards: None,
          commitment: CommitmentConfig::finalized().into(),
          max_supported_transaction_version: Some(0),
      };
      let block = client.get_block_with_config(slot_number, config).await?;

      println!("Block: {:#?}", block);

      Ok(())
  }
  ```
</CodeGroup>

## Developer Tips

* **Slot vs. Block Height:** Remember that `getBlock` takes a `slot` number as input, not necessarily a block height. While slots are sequential, some slots might be skipped by leaders. The `blockHeight` field in the response indicates the actual number of blocks before this one.
* **`maxSupportedTransactionVersion` is Crucial:** To inspect blocks with versioned transactions (which are standard now and use Address Lookup Tables), you **must** set `maxSupportedTransactionVersion: 0` (or a higher version if a new standard emerges). Forgetting this will result in errors for most modern blocks.
* **Choosing `transactionDetails`:**
  * `full` is needed for most detailed analysis but returns the most data.
  * `signatures` is useful if you only need to list transactions in a block.
  * `accounts` can be a middle ground if you need to see which accounts were involved without fetching all instruction data.
  * `none` is rare but could be used if you only care about block-level metadata like `blockhash` or `rewards`.
* **`jsonParsed` is Recommended for Encoding:** When requesting transaction details, `jsonParsed` provides the most developer-friendly output and correctly resolves accounts from Address Lookup Tables, which `json` (deprecated) does not.
* **Block Unavailability:** A `null` result means the block at that slot was not found. This could be because the slot was skipped, the block hasn't been confirmed to the level specified by your `commitment`, or the RPC node has pruned that historical block from its ledger (common for older slots).
* **Rewards Information:** Setting `rewards: true` is necessary to see the distribution of block rewards to the validator (and potentially stakers, depending on the reward type). This adds to the response size.
* **Understanding Block Structure:** For a deeper understanding of how blocks fit into Solana's architecture, see [Understanding Slots, Blocks, and Epochs on Solana](https://www.helius.dev/blog/solana-slots-blocks-and-epochs).


# How to Use getBlockCommitment
Source: https://www.helius.dev/docs/rpc/guides/getblockcommitment

Learn getBlockCommitment use cases, code examples, request parameters, response structure, and tips.

The [`getBlockCommitment`](https://www.helius.dev/docs/api-reference/rpc/http/getblockcommitment) RPC method provides information about the [commitment](https://www.helius.dev/blog/solana-commitment-levels) status of a specific block in the Solana ledger. This is useful for understanding how finalized a block is, based on the stake that has voted on it.

## Common Use Cases

* **Assessing Block Finality:** Determine the level of consensus a block has achieved by examining the stake-weighted votes at different confirmation depths.
* **Understanding Cluster Health:** The `totalStake` provides insight into the total active stake in the cluster at the time the block was processed.
* **Advanced Confirmation Logic:** For applications requiring very specific guarantees about block finality beyond standard commitment levels (`confirmed`, `finalized`).

## Parameters

1. `slot` (number, required): The slot number (u64) of the block for which to query commitment information.

## Response

The `result` field of the JSON-RPC response will be an object containing:

* `commitment` (array of u64 integers | null):
  * An array of u64 integers, where each integer represents the amount of cluster stake (in lamports) that has voted on the block at a specific confirmation depth.
  * The array typically has 32 elements (representing depths 0 through `MAX_LOCKOUT_HISTORY`, which is 31).
  * Index `i` of the array shows the stake that has voted for the block, considering votes on the block itself and its descendants up to `i` levels deep.
  * If the block is not found or its commitment information is not available (e.g., it's too old and pruned from commitment tracking), this field will be `null`.
* `totalStake` (number):
  * The total active stake in the cluster (in lamports) at the slot this block was processed. This value is used to calculate the percentage of stake that has committed to the block.

## Developer Tips

* **Interpreting the `commitment` Array:**
  * The `commitment` array shows the stake (in lamports) that has voted for the block at different confirmation depths. Higher values at deeper indices signify stronger finality.
  * A `null` `commitment` array often means the node doesn't have data for the slot, possibly because it's too old or was skipped.
  * You can gauge finality at depth `i` if `commitment[i] / totalStake >= 2/3` (supermajority).
* **Advanced Use Cases:** `getBlockCommitment` is for nuanced finality analysis. For most common scenarios, relying on standard commitment levels (`processed`, `confirmed`, or `finalized`) with other RPC methods (like `getTransaction` or `getBlock`) is simpler and sufficient.
* **Understanding Commitment:** To fully leverage `getBlockCommitment`, a solid understanding of Solana's commitment levels is essential. See [Solana Commitment Levels](https://www.helius.dev/blog/solana-commitment-levels) for detailed information.
* **Pruning:** Be aware that RPC nodes might prune old commitment information, leading to `null` results for older slots.

## Example: Fetching Block Commitment Information

Let's try to fetch commitment information for an illustrative slot number on Devnet.
**Important:** Slot numbers are processed rapidly. The slot number used below (`250000000`) is a placeholder. You should replace it with a recent, confirmed slot that you know exists on your target network (e.g., Devnet or Mainnet) when you run the example. You can find recent slot numbers using a Solana block explorer.

**Note:** Replace `YOUR_API_KEY` with your actual Helius API key in the examples below.

<CodeGroup>
  ```bash curl
  # Replace 250000000 with a valid, recent slot number on Devnet/Mainnet
  curl https://mainnet.helius-rpc.com/?api-key=YOUR_API_KEY -X POST -H "Content-Type: application/json" -d \
  '{
    "jsonrpc": "2.0",
    "id": 1,
    "method": "getBlockCommitment",
    "params": [
      250000000 
    ]
  }'
  ```

  ```javascript JavaScript (using @solana/web3.js)
  const { Connection } = require('@solana/web3.js');

  async function getBlockCommitmentDetails() {
    const rpcUrl = 'https://mainnet.helius-rpc.com/?api-key=YOUR_API_KEY'; // Replace YOUR_API_KEY
    const connection = new Connection(rpcUrl, 'confirmed');
    
    // Replace with a valid, recent slot number on your target network
    const slotToQuery = 250000000; 

    try {
      // Note: getBlockCommitment is not directly available in @solana/web3.js Connection object.
      // You typically need to make a direct RPC call for this method.
      // The example below shows how to construct and send such a raw request.
      const response = await fetch(rpcUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          jsonrpc: '2.0',
          id: 1,
          method: 'getBlockCommitment',
          params: [slotToQuery],
        }),
      });
      const result = await response.json();

      if (result.error) {
        console.error(`Error fetching block commitment for slot ${slotToQuery}:`, result.error.message);
        return;
      }

      const blockCommitment = result.result;

      if (blockCommitment) {
        console.log(`Block Commitment for Slot ${slotToQuery}:`);
        console.log(`   Total Stake (Lamports): ${blockCommitment.totalStake}`);
        console.log(`   Commitment Array:`, blockCommitment.commitment ? blockCommitment.commitment : 'Not available/Unknown block');
        // The commitment array shows lamports committed at different depths.
        // A null commitment array usually means the block is not found or too old.
        // A non-null array where later entries are higher indicates increasing finality.
      } else {
        console.log(`Block commitment data for slot ${slotToQuery} not found.`);
      }
    } catch (error) {
      console.error(`Error fetching block commitment for slot ${slotToQuery}:`, error);
    }
  }

  getBlockCommitmentDetails();
  ```

  ```typescript Kit
  import { createSolanaRpc } from "@solana/kit";

  const rpc_url = "https://mainnet.helius-rpc.com/?api-key=YOUR_API_KEY";
  const rpc = createSolanaRpc(rpc_url);

  const slot_number = BigInt(5);

  let blockCommitment = await rpc.getBlockCommitment(slot_number).send();

  console.log("block commitment:", blockCommitment);
  ```
</CodeGroup>


# How to Use getBlockHeight
Source: https://www.helius.dev/docs/rpc/guides/getblockheight

Learn getBlockHeight use cases, code examples, request parameters, response structure, and tips.

The [`getBlockHeight`](https://www.helius.dev/docs/api-reference/rpc/http/getblockheight) RPC method is a simple way to query a Solana node for its current block height. The block height represents the number of blocks that have been processed since the genesis block (slot 0).

This method is useful for quickly understanding how far the chain has progressed or for referencing the latest block height at a specific commitment level.

## Common Use Cases

* **Monitoring Chain Progression:** Periodically call this method to see the chain advancing.
* **Getting a Snapshot of Chain Length:** Determine the total number of blocks processed up to a certain point (based on commitment).
* **Cross-Referencing with Other Data:** Use the block height as a reference point when analyzing other on-chain data or events.

## Parameters

`getBlockHeight` can optionally take a configuration object as its first parameter (or be called with no parameters to use defaults):

1. `config` (object, optional): A configuration object with the following fields:
   * `commitment` (string, optional): Specifies the commitment level to use for the query. Defaults to `finalized`.
     * `finalized`: The node will query the most recent block confirmed by the supermajority of the cluster as having reached maximum lockout.
     * `confirmed`: The node will query the most recent block that has been voted on by a supermajority of the cluster.
     * `processed`: The node will query its most recent block. Note that the block may not be complete.
   * `minContextSlot` (number, optional): The minimum slot that the request can be evaluated at. This ensures that the block height returned is from a slot equal to or greater than `minContextSlot`.

If no parameters are provided, the method typically defaults to the `finalized` commitment.

## Developer Tips

* **Commitment Levels Matter**: The block height returned can vary based on the `commitment` level specified. `finalized` gives the most stable height, while `processed` might give a more current but potentially transient height.
* **`minContextSlot` for Consistency**: Use `minContextSlot` if you need to ensure the block height is queried from a state that is at least as recent as a specific slot you are tracking.
* **Not a Slot Number**: Remember that block height is different from the slot number. A slot is a period of time, and not every slot produces a block (these are called skipped slots). Block height is the count of actual blocks produced.
* **Basic Chain Health Check**: While simple, `getBlockHeight` can be part of a basic chain health or synchronization check for your application or monitoring system.

## Response

The `result` field of the JSON-RPC response will be a single number:

* `blockHeight` (number): The current block height (u64) of the node according to the specified commitment level.

**Example Response JSON:**

```json
{
  "jsonrpc": "2.0",
  "result": 275123456, // Example block height
  "id": 1
}
```

This value represents the number of blocks on the longest chain from the genesis block (slot 0) to the current head of the chain, as seen by the queried node.

## Example: Fetching the Current Block Height

Let's fetch the current block height from the Helius Devnet RPC.

**Note:** Replace `YOUR_API_KEY` with your actual Helius API key in the examples below.

<CodeGroup>
  ```bash curl
  curl https://mainnet.helius-rpc.com/?api-key=YOUR_API_KEY -X POST -H "Content-Type: application/json" -d \
  '{
    "jsonrpc": "2.0",
    "id": 1,
    "method": "getBlockHeight",
    "params": [] 
  }'
  ```

  ```javascript JavaScript (using @solana/web3.js)
  const { Connection } = require('@solana/web3.js');

  async function getCurrentBlockHeight() {
    const rpcUrl = 'https://mainnet.helius-rpc.com/?api-key=YOUR_API_KEY'; // Replace YOUR_API_KEY
    const connection = new Connection(rpcUrl, 'confirmed');

    try {
      const blockHeight = await connection.getBlockHeight();
      console.log(`Current Block Height: ${blockHeight}`);

    } catch (error) {
      console.error('Error fetching block height:', error);
    }
  }

  getCurrentBlockHeight();
  ```

  ```typescript Kit
  import { createSolanaRpc } from "@solana/kit";

  const rpc_url = "https://mainnet.helius-rpc.com/?api-key=YOUR_API_KEY";
  const rpc = createSolanaRpc(rpc_url);

  let blockHeight = await rpc.getBlockHeight().send();

  console.log("block height:", blockHeight);
  ```

  ```rust Rust
  use anyhow::Result;
  use solana_client::nonblocking::rpc_client::RpcClient;
  use solana_sdk::commitment_config::CommitmentConfig;

  #[tokio::main]
  async fn main() -> Result<()> {
      let client = RpcClient::new_with_commitment(
          String::from("https://mainnet.helius-rpc.com/?api-key=YOUR_API_KEY"),
          CommitmentConfig::confirmed(),
      );

      let block_height = client.get_block_height().await?;

      println!("Block height: {:#?}", block_height);

      Ok(())
  }
  ```
</CodeGroup>


# How to Use getBlockProduction
Source: https://www.helius.dev/docs/rpc/guides/getblockproduction

Learn getBlockProduction use cases, code examples, request parameters, response structure, and tips.

The [`getBlockProduction`](https://www.helius.dev/docs/api-reference/rpc/http/getblockproduction) RPC method provides information about block production in the current epoch or a specified slot range. It can be used to retrieve data for all validators or for a specific validator identity. This is valuable for monitoring validator performance and understanding block production patterns on the network.

## Common Use Cases

* **Monitoring Validator Performance:** Track the number of blocks produced and leader slots for a specific validator.
* **Analyzing Epoch Performance:** Get an overview of block production across all validators in the current or a past epoch.
* **Identifying Missed Slots:** See if validators are missing their assigned leader slots.
* **Network Health Checks:** Gather data on overall block production efficiency.

## Request Parameters

The `getBlockProduction` method accepts an optional configuration object with the following parameters:

1. **`commitment`** (string, optional): Specifies the commitment level to use for the query. If omitted, the default commitment of the node is used.
2. **`range`** (object, optional): Defines a slot range to query.
   * `firstSlot` (u64): The first slot to fetch block production information for (inclusive).
   * `lastSlot` (u64, optional): The last slot to fetch block production information for (inclusive). If omitted, the current epoch's block production up to the current slot will be returned.
3. **`identity`** (string, optional): A base58-encoded public key of a validator identity. If provided, the response will only include block production information for this specific validator. If omitted, information for all validators in the specified range (or current epoch) is returned.

**Note:** At least one of `identity` or `range.firstSlot` must be provided. If `identity` is not provided, the `range` parameter is required.

## Response Structure

The `result` field of the JSON-RPC response will be an object containing:

* `context` (object):
  * `slot` (u64): The slot at which the information was retrieved.
* `value` (object):
  * `byIdentity` (object): An object where keys are validator identity strings (base58-encoded public keys), and values are objects containing:
    * `leaderSlots` (u64): The number of leader slots assigned to this validator in the queried range/epoch.
    * `blocksProduced` (u64): The number of blocks produced by this validator in the queried range/epoch.
  * `range` (object):
    * `firstSlot` (u64): The first slot of the queried range.
    * `lastSlot` (u64): The last slot of the queried range.

## Developer Tips

* **Understand Epoch Boundaries**: When querying by `identity` without a `range`, the data returned is for the current epoch up to the latest processed slot by the node. If you need data for a *full* past epoch for a specific validator, you'll need to determine the `firstSlot` and `lastSlot` for that epoch.
* **Node Data Availability**: The range of historical block production data can vary between RPC nodes. Very old slot ranges might not be available on all nodes.
* **Performance Monitoring**: `getBlockProduction` is key for building dashboards or alerts related to validator uptime and block production success rates.
* **Combining with `getLeaderSchedule`**: For deeper analysis, you can correlate `getBlockProduction` data with the output of `getLeaderSchedule` to see which specific leader slots were made or missed.
* **Identity vs. All Validators**: Querying without an `identity` can return a large amount of data, especially if no `range` or a wide `range` is specified. Be mindful of response sizes and processing requirements.

## Examples

### 1. Get Block Production for the Current Epoch (All Validators)

This example fetches block production data for all validators in the current epoch.

<CodeGroup>
  ```bash cURL
  curl https://mainnet.helius-rpc.com/?api-key=<api-key> -X POST -H "Content-Type: application/json" -d \\
    '{
      "jsonrpc": "2.0",
      "id": 1,
      "method": "getBlockProduction"
    }'
  ```

  ```javascript JavaScript (using @solana/web3.js)
  const { Connection } = require('@solana/web3.js');

  async function getEpochBlockProduction() {
    const connection = new Connection('https://mainnet.helius-rpc.com/?api-key=<api-key>');
    try {
      const blockProduction = await connection.getBlockProduction();
      console.log('Block Production for Current Epoch:', JSON.stringify(blockProduction, null, 2));
      // Example: Accessing data for a specific validator (if present)
      // const specificValidatorIdentity = " deaktivCQ2sV2KF1y7n4qX1xUFk6VXL79CdfjrmLdshs"; // Replace with actual identity
      // if (blockProduction.value.byIdentity[specificValidatorIdentity]) {
      //   console.log(\`Data for \${specificValidatorIdentity}:\`, blockProduction.value.byIdentity[specificValidatorIdentity]);
      // }
    } catch (error) {
      console.error('Error fetching block production:', error);
    }
  }

  getEpochBlockProduction();
  ```
</CodeGroup>

### 2. Get Block Production for a Specific Validator in the Current Epoch

This example fetches block production for a specific validator identity in the current epoch.

<CodeGroup>
  ```bash cURL
  # Replace YOUR_VALIDATOR_IDENTITY_PUBKEY with the actual validator's base58 public key.
  curl https://mainnet.helius-rpc.com/?api-key=<api-key> -X POST -H "Content-Type: application/json" -d \\
    '{
      "jsonrpc": "2.0",
      "id": 1,
      "method": "getBlockProduction",
      "params": [
        {
          "identity": "YOUR_VALIDATOR_IDENTITY_PUBKEY"
        }
      ]
    }'
  ```

  ```javascript JavaScript (using @solana/web3.js)
  const { Connection } = require('@solana/web3.js');

  async function getValidatorBlockProduction(validatorIdentity) {
    const connection = new Connection('https://mainnet.helius-rpc.com/?api-key=<api-key>');
    try {
      const blockProduction = await connection.getBlockProduction({ identity: validatorIdentity });
      console.log(\`Block Production for \${validatorIdentity}:\`, JSON.stringify(blockProduction, null, 2));
    } catch (error) {
      console.error(\`Error fetching block production for \${validatorIdentity}:\`, error);
    }
  }

  // Replace with the validator identity you want to query
  const validatorIdentity = "So11111111111111111111111111111111111111112"; // Example: Solana Foundation
  getValidatorBlockProduction(validatorIdentity);
  ```
</CodeGroup>

### 3. Get Block Production for a Specific Slot Range and Validator

This example fetches block production data for a specific validator within a defined slot range.

<CodeGroup>
  ```bash cURL
  # Replace YOUR_VALIDATOR_IDENTITY_PUBKEY, START_SLOT, and END_SLOT.
  curl https://mainnet.helius-rpc.com/?api-key=<api-key> -X POST -H "Content-Type: application/json" -d \\
    '{
      "jsonrpc": "2.0",
      "id": 1,
      "method": "getBlockProduction",
      "params": [
        {
          "identity": "YOUR_VALIDATOR_IDENTITY_PUBKEY",
          "range": {
            "firstSlot": START_SLOT, # e.g., 200000000
            "lastSlot": END_SLOT    # e.g., 200010000
          }
        }
      ]
    }'
  ```

  ```javascript JavaScript (using @solana/web3.js)
  const { Connection } = require('@solana/web3.js');

  async function getValidatorBlockProductionForRange(validatorIdentity, firstSlot, lastSlot) {
    const connection = new Connection('https://mainnet.helius-rpc.com/?api-key=<api-key>');
    try {
      const blockProduction = await connection.getBlockProduction({
        identity: validatorIdentity,
        range: {
          firstSlot: firstSlot,
          lastSlot: lastSlot,
        },
      });
      console.log(\`Block Production for \${validatorIdentity} in range \${firstSlot}-\${lastSlot}:\`, JSON.stringify(blockProduction, null, 2));
    } catch (error) {
      console.error(\`Error fetching block production for \${validatorIdentity} in range:\`, error);
    }
  }

  // Replace with your desired parameters
  const validatorIdentity = "Beefy1So11111111111111111111111111111111111"; // Example validator
  const firstSlot = 200000000; // Example start slot
  const lastSlot = 200010000;   // Example end slot
  getValidatorBlockProductionForRange(validatorIdentity, firstSlot, lastSlot);
  ```
</CodeGroup>

This guide should give you a solid understanding of how to use the `getBlockProduction` RPC method to analyze block production on Solana.


# How to Use getBlocks
Source: https://www.helius.dev/docs/rpc/guides/getblocks

Learn getBlocks use cases, code examples, request parameters, response structure, and tips.

The [`getBlocks`](https://www.helius.dev/docs/api-reference/rpc/http/getblocks) RPC method allows you to retrieve a list of confirmed block slot numbers between a specified start slot and an optional end [slot](https://www.helius.dev/blog/solana-slots-blocks-and-epochs). This is useful when you need to know which blocks have been confirmed in a particular range without fetching the full content of each block.

## Common Use Cases

* **Identifying Confirmed Blocks in a Range:** Quickly get a list of all block slots that were successfully confirmed between two points in the ledger.
* **Iterating Through Blocks:** Use the returned list of slots to subsequently fetch detailed information for each block using `getBlock` if needed.
* **Basic Block Auditing:** Verify block presence within a certain range.

## Request Parameters

The `getBlocks` method takes the following parameters:

1. **`start_slot`** (u64, required): The first slot to consider for the range (inclusive).
2. **`end_slot`** (u64, optional): The last slot to consider for the range (inclusive).
   * If not provided, the query will return blocks up to the latest confirmed slot from `start_slot`.
   * The range between `start_slot` and `end_slot` (or latest slot if `end_slot` is omitted) **must not exceed 500,000 slots**.
3. **`commitment`** (string, optional): Specifies the commitment level for the query. If omitted, the default commitment of the node is used. This is passed as the sole field in a configuration object as the last parameter.

## Response Structure

The `result` field of the JSON-RPC response will be an array of u64 integers. Each integer in the array represents a confirmed block slot number within the specified range.

* Example: `[5, 6, 7, 8, 9, 10]`

## Examples

### 1. Get Blocks within a Specific Slot Range

This example fetches the list of confirmed block slots between slot `250000000` and `250000010`.

<CodeGroup>
  ```bash cURL
  curl https://mainnet.helius-rpc.com/?api-key=<api-key> -X POST -H "Content-Type: application/json" -d \
    '{
      "jsonrpc": "2.0",
      "id": 1,
      "method": "getBlocks",
      "params": [
        250000000,
        250000010
      ]
    }'
  ```

  ```javascript JavaScript (using @solana/web3.js)
  const { Connection } = require('@solana/web3.js');

  async function getBlocksInRange(startSlot, endSlot) {
    const connection = new Connection('https://mainnet.helius-rpc.com/?api-key=<api-key>');
    try {
      const blocks = await connection.getBlocks(startSlot, endSlot);
      console.log(`Confirmed blocks between slot ${startSlot} and ${endSlot}:`, blocks);
    } catch (error) {
      console.error('Error fetching blocks:', error);
    }
  }

  // Example usage:
  const startSlot = 250000000;
  const endSlot = 250000010;
  getBlocksInRange(startSlot, endSlot);
  ```
</CodeGroup>

### 2. Get Blocks from a Start Slot to the Latest Confirmed Slot

This example fetches confirmed block slots starting from `260000000` up to the latest block confirmed by the node (respecting the 500,000 slot range limit from the start slot).

<CodeGroup>
  ```bash cURL
  curl https://mainnet.helius-rpc.com/?api-key=<api-key> -X POST -H "Content-Type: application/json" -d \
    '{
      "jsonrpc": "2.0",
      "id": 1,
      "method": "getBlocks",
      "params": [
        260000000 
      ]
    }'
  ```

  ```javascript JavaScript (using @solana/web3.js)
  const { Connection } = require('@solana/web3.js');

  async function getBlocksFromStart(startSlot) {
    const connection = new Connection('https://mainnet.helius-rpc.com/?api-key=<api-key>');
    try {
      // The endSlot parameter is omitted to fetch up to the latest confirmed block
      const blocks = await connection.getBlocks(startSlot);
      console.log(`Confirmed blocks from slot ${startSlot} to latest:`, blocks);
      if (blocks.length > 0) {
        console.log(`Latest block in range: ${blocks[blocks.length - 1]}`);
      }
    } catch (error) {
      console.error('Error fetching blocks:', error);
    }
  }

  // Example usage (ensure this doesn't exceed the 500,000 slot limit from latest block):
  const recentStartSlot = 260000000; 
  getBlocksFromStart(recentStartSlot);
  ```
</CodeGroup>

### 3. Get Blocks with a Specific Commitment Level

This example fetches blocks using the `confirmed` commitment level.

<CodeGroup>
  ```bash cURL
  curl https://mainnet.helius-rpc.com/?api-key=<api-key> -X POST -H "Content-Type: application/json" -d \
    '{
      "jsonrpc": "2.0",
      "id": 1,
      "method": "getBlocks",
      "params": [
        270000000,
        270000005,
        { "commitment": "confirmed" }
      ]
    }'
  ```

  ```javascript JavaScript (using @solana/web3.js)
  const { Connection } = require('@solana/web3.js'); 

  async function getBlocksWithCommitment(startSlot, endSlot) {
    const connection = new Connection('https://mainnet.helius-rpc.com/?api-key=<api-key>');
    try {
      const blocks = await connection.getBlocks(startSlot, endSlot, { commitment: 'confirmed' });
      console.log(`Confirmed blocks (with 'confirmed' commitment) between slot ${startSlot} and ${endSlot}:`, blocks);
    } catch (error) {
      console.error('Error fetching blocks with commitment:', error);
    }
  }

  // Example usage:
  const commitStartSlot = 270000000;
  const commitEndSlot = 270000005;
  getBlocksWithCommitment(commitStartSlot, commitEndSlot);
  ```
</CodeGroup>

## Developer Tips

* **Range Limit:** Remember the 500,000 slot range limit. Requesting a larger range will result in an error.
* **Node Data Availability:** Nodes may not retain information for all historical slots. Very old `start_slot` values might return empty arrays or errors depending on the node's configuration and ledger retention.
* **Block Confirmation:** This method returns *confirmed* blocks. The exact set of blocks can vary slightly depending on the chosen `commitment` level and which node you query, especially for very recent slots.
* **Complement to `getBlock`:** `getBlocks` is often used as a first step to identify relevant block slots before using `getBlock` to retrieve the full details of individual blocks within that list.
* **Pagination Alternative:** Since `getBlocks` has a range limit, if you need to scan a very large portion of the chain, you'll need to make multiple calls to `getBlocks`, chunking your desired total range into segments of 500,000 slots or less.

This guide provides a clear overview of how to use the `getBlocks` RPC method to list confirmed block slots on the Solana network.


# How to Use getBlocksWithLimit
Source: https://www.helius.dev/docs/rpc/guides/getblockswithlimit

Learn getBlocksWithLimit use cases, code examples, request parameters, response structure, and tips.

The [`getBlocksWithLimit`](https://www.helius.dev/docs/api-reference/rpc/http/getblockswithlimit) RPC method allows you to retrieve a list of confirmed block slot numbers, starting from a specified slot and returning up to a given limit. This is useful when you need a specific number of subsequent confirmed [blocks](https://www.helius.dev/blog/solana-slots-blocks-and-epochs) from a certain point in the ledger.

## Common Use Cases

* **Fetching a Fixed Number of Subsequent Blocks:** Get a defined number of block slots that were confirmed after a particular start slot.
* **Paginated Block Exploration:** Retrieve blocks in chunks when analyzing a segment of the blockchain.
* **Recent Block Monitoring:** Get the last N blocks from a known recent slot.

## Request Parameters

The `getBlocksWithLimit` method takes the following parameters:

1. **`start_slot`** (u64, required): The first slot to consider (inclusive).
2. **`limit`** (u64, required): The maximum number of block slots to return. The total number of slots queried (from `start_slot` up to `limit` blocks after it) **must not exceed 500,000 slots**.
3. **`commitment`** (string, optional): Specifies the commitment level for the query. If omitted, the default commitment of the node is used. This is passed as the sole field in a configuration object as the last parameter.

## Response Structure

The `result` field of the JSON-RPC response will be an array of u64 integers. Each integer in the array represents a confirmed block slot number, starting from `start_slot` up to the specified `limit`.

* Example: If `start_slot` is 5 and `limit` is 3, a possible result is `[5, 6, 7]`.

## Examples

### 1. Get a Limited Number of Blocks from a Start Slot

This example fetches a list of up to 5 confirmed block slots starting from slot `280000000`.

<CodeGroup>
  ```bash cURL
  curl https://mainnet.helius-rpc.com/?api-key=<api-key> -X POST -H "Content-Type: application/json" -d \
    '{
      "jsonrpc": "2.0",
      "id": 1,
      "method": "getBlocksWithLimit",
      "params": [
        280000000, 
        5 
      ]
    }'
  ```

  ```javascript JavaScript (using @solana/web3.js)
  const { Connection } = require('@solana/web3.js');

  async function getBlocksWithLimitExample(startSlot, limit) {
    const connection = new Connection('https://mainnet.helius-rpc.com/?api-key=<api-key>');
    try {
      const blocks = await connection.getBlocksWithLimit(startSlot, limit);
      console.log(`Up to ${limit} confirmed blocks starting from slot ${startSlot}:`, blocks);
    } catch (error) {
      console.error('Error fetching blocks with limit:', error);
    }
  }

  // Example usage:
  const startSlot = 280000000;
  const limit = 5;
  getBlocksWithLimitExample(startSlot, limit);
  ```
</CodeGroup>

### 2. Get Blocks With Limit and a Specific Commitment Level

This example fetches up to 3 blocks starting from slot `290000000` using the `confirmed` commitment level.

<CodeGroup>
  ```bash cURL
  curl https://mainnet.helius-rpc.com/?api-key=<api-key> -X POST -H "Content-Type: application/json" -d \
    '{
      "jsonrpc": "2.0",
      "id": 1,
      "method": "getBlocksWithLimit",
      "params": [
        290000000,
        3,
        { "commitment": "confirmed" }
      ]
    }'
  ```

  ```javascript JavaScript (using @solana/web3.js)
  const { Connection } = require('@solana/web3.js');

  async function getBlocksWithLimitAndCommitment(startSlot, limit) {
    const connection = new Connection('https://mainnet.helius-rpc.com/?api-key=<api-key>');
    try {
      const blocks = await connection.getBlocksWithLimit(startSlot, limit, { commitment: 'confirmed' });
      console.log(`Up to ${limit} confirmed blocks (with 'confirmed' commitment) starting from slot ${startSlot}:`, blocks);
    } catch (error) {
      console.error('Error fetching blocks with limit and commitment:', error);
    }
  }

  // Example usage:
  const commitStartSlot = 290000000;
  const commitLimit = 3;
  getBlocksWithLimitAndCommitment(commitStartSlot, commitLimit);
  ```
</CodeGroup>

## Developer Tips

* **Range Clarification:** The `limit` parameter dictates the maximum number of block *slots* to return. The 500,000 slot constraint applies to the conceptual range scanned (i.e., from `start_slot` to `start_slot + limit - 1`). Ensure this conceptual range doesn't exceed 500,000 slots, even if fewer actual blocks are found and returned within that range.
* **Node Data Availability:** Nodes may not retain information for all historical slots. A very old `start_slot` might return fewer blocks than the specified `limit`, or an empty array, depending on the node's ledger retention.
* **Block Confirmation:** This method returns *confirmed* blocks. The exact set of blocks can vary slightly depending on the chosen `commitment` level and which node you query, especially for very recent slots.
* **Use Case Specificity:** `getBlocksWithLimit` is ideal when you know the starting point and need a fixed number of subsequent blocks. If you need all blocks in a known slot range, `getBlocks` might be more appropriate.

This guide provides a clear overview of how to use the `getBlocksWithLimit` RPC method to list a specific number of confirmed block slots on the Solana network.


# How to Use getBlockTime
Source: https://www.helius.dev/docs/rpc/guides/getblocktime

Learn getBlockTime use cases, code examples, request parameters, response structure, and tips.

The [`getBlockTime`](https://www.helius.dev/docs/api-reference/rpc/http/getblocktime) RPC method provides the estimated production time of a specified block, identified by its slot number. The time is returned as a Unix timestamp (seconds since the Unix epoch).

This method is useful when you need to correlate block production with real-world time.

## Common Use Cases

* **Timestamping Events:** Determine when a particular block was produced to timestamp on-chain events.
* **Analyzing Block Production Intervals:** Calculate the time difference between blocks (though for more detailed analysis, other methods might be combined).
* **Correlating Off-Chain Data:** Align off-chain events or data with on-chain activity by matching block production times.

## Request Parameters

The `getBlockTime` method takes a single parameter:

1. **`slot`** (u64, required): The slot number of the block for which to retrieve the estimated production time.

## Response Structure

The `result` field of the JSON-RPC response will be either:

* **`timestamp`** (i64): The estimated production time as a Unix timestamp (seconds since the Unix epoch).
* **`null`**: If the timestamp is not available for the specified block (e.g., the block is very old and the data has been pruned, or the block was skipped and has no associated timestamp).

## Examples

### 1. Get the Estimated Time of a Specific Block

This example fetches the estimated production time for a specific slot. Remember to replace `SLOT_NUMBER_TO_QUERY` with an actual, recent, and confirmed slot on the network you are targeting (e.g., Mainnet Beta or Devnet).

<CodeGroup>
  ```bash cURL
  # Replace SLOT_NUMBER_TO_QUERY with a valid slot, e.g., a recent one from an explorer
  curl https://mainnet.helius-rpc.com/?api-key=<api-key> -X POST -H "Content-Type: application/json" -d \
    '{
      "jsonrpc": "2.0",
      "id": 1,
      "method": "getBlockTime",
      "params": [
        SLOT_NUMBER_TO_QUERY 
      ]
    }'
  ```

  ```javascript JavaScript (using @solana/web3.js)
  const { Connection } = require('@solana/web3.js');

  async function getSpecificBlockTime(slotToQuery) {
    const connection = new Connection('https://mainnet.helius-rpc.com/?api-key=<api-key>');
    try {
      const blockTime = await connection.getBlockTime(slotToQuery);
      if (blockTime !== null) {
        console.log(`Estimated time for slot ${slotToQuery}: ${new Date(blockTime * 1000).toISOString()} (Unix: ${blockTime})`);
      } else {
        console.log(`Timestamp not available for slot ${slotToQuery}.`);
      }
    } catch (error) {
      console.error('Error fetching block time:', error);
    }
  }

  // Example usage: Replace with a recent, valid slot number from Mainnet Beta
  // You can find recent slots on Solana explorers like Solscan or SolanaFM
  const slotToQuery = 300000000; // Replace with an actual slot number
  getSpecificBlockTime(slotToQuery);
  ```
</CodeGroup>

## Developer Tips

* **Timestamp Availability:** Timestamps might not be available for all blocks, especially very old ones or slots that were skipped. In such cases, the method returns `null`.
* **Estimation:** The time is an *estimate*. It's derived from stake-weighted mean of Vote timestamps from validators. While generally accurate, it's not a guaranteed, cryptographically secure timestamp for every single block in the same way a blockhash is.
* **Node Dependence:** The availability and precision might slightly vary depending on the RPC node queried, especially for very recent (not yet finalized) blocks.

This guide explains how to use `getBlockTime` to retrieve the estimated production timestamp for any given block on the Solana network.


# How to Use getClusterNodes
Source: https://www.helius.dev/docs/rpc/guides/getclusternodes

Learn getClusterNodes use cases, code examples, request parameters, response structure, and tips.

The [`getClusterNodes`](https://www.helius.dev/docs/api-reference/rpc/http/getclusternodes) RPC method returns a list of all known nodes currently participating in the Solana cluster. This information can be useful for network analysis, discovering alternative RPC endpoints, or understanding the current topology of the network from the perspective of the queried node.

## Common Use Cases

* **Network Topology Analysis:** Get a snapshot of the known nodes in the cluster, including their public keys and network addresses (gossip, TPU, RPC).
* **Discovering RPC Endpoints:** Identify other potential RPC servers within the cluster (though availability and rate limits might vary).
* **Monitoring Node Versions:** Observe the software versions being run by different nodes in the cluster.

## Request Parameters

This method does not take any parameters.

## Response Structure

The `result` field of the JSON-RPC response will be an array of objects. Each object represents a node and contains the following fields:

* **`pubkey`** (string): The public key (identity) of the node, base58 encoded.
* **`gossip`** (string | null): The IP address and port for the node's gossip service. Can be `null` if not available.
* **`tpu`** (string | null): The IP address and port for the node's Transaction Processing Unit (TPU). This is used for submitting transactions directly. Can be `null`.
* **`rpc`** (string | null): The IP address and port for the node's JSON-RPC service. Can be `null` if the RPC service is not enabled or advertised by this node.
* **`version`** (string | null): The software version of the node. Can be `null` if version information is not available.
* **`featureSet`** (u32 | null): The unique identifier of the node's feature set. Can be `null`.
* **`shredVersion`** (u16 | null): The version of the data structure used by this node to store and transmit blocks (shreds). Can be `null`.

## Examples

### 1. Get All Known Cluster Nodes

This example fetches the list of all nodes known to the queried RPC endpoint.

<CodeGroup>
  ```bash cURL
  curl https://mainnet.helius-rpc.com/?api-key=<api-key> -X POST -H "Content-Type: application/json" -d \
    '{
      "jsonrpc": "2.0",
      "id": 1,
      "method": "getClusterNodes"
    }'
  ```

  ```javascript JavaScript (using @solana/web3.js)
  const { Connection } = require('@solana/web3.js');

  async function getNodesInCluster() {
    const connection = new Connection('https://mainnet.helius-rpc.com/?api-key=<api-key>');
    try {
      const clusterNodes = await connection.getClusterNodes();
      console.log(`Found ${clusterNodes.length} cluster nodes:`);
      clusterNodes.forEach(node => {
        console.log(
          `  PubKey: ${node.pubkey}, Gossip: ${node.gossip || 'N/A'}, RPC: ${node.rpc || 'N/A'}, Version: ${node.version || 'N/A'}`
        );
      });
      // For full details:
      // console.log(JSON.stringify(clusterNodes, null, 2));
    } catch (error) {
      console.error('Error fetching cluster nodes:', error);
    }
  }

  getNodesInCluster();
  ```
</CodeGroup>

## Developer Tips

* **Node's Perspective:** The returned list reflects the nodes known to the specific RPC node you are querying. Different RPC nodes might have slightly different views of the cluster, especially during network changes.
* **RPC Availability:** Not all nodes listed will necessarily have their RPC ports open or publicly accessible. The `rpc` field being non-null indicates an advertised RPC endpoint, but it doesn't guarantee accessibility or performance.
* **Dynamic List:** The cluster topology is dynamic. Nodes can join and leave, so the list can change over time.
* **Large Response:** On a large network like Mainnet Beta, the response can be quite extensive, listing many nodes.

This guide provides the necessary information to use the `getClusterNodes` RPC method for discovering and understanding the nodes within a Solana cluster.


# How to Use getEpochInfo
Source: https://www.helius.dev/docs/rpc/guides/getepochinfo

Learn getEpochInfo use cases, code examples, request parameters, response structure, and tips.

The [`getEpochInfo`](https://www.helius.dev/docs/api-reference/rpc/http/getepochinfo) RPC method returns information about the current epoch. This can be useful for understanding the current state of the network, how far into the current epoch the network has progressed, and when the next epoch might begin. To better understand how [epochs, slots, and blocks](https://www.helius.dev/blog/solana-slots-blocks-and-epochs) work together on Solana, refer to our detailed article.

## Common Use Cases

* **Monitoring Epoch Progress:** Track the current slot index within the epoch and the total slots in the epoch to estimate the time remaining.
* **Network State Analysis:** Get the current epoch number, the block height, and the number of transactions processed in the current epoch.
* **Synchronization Checks:** Verify if a node is reasonably synchronized with the network by comparing its epoch information.

## Request Parameters

The `getEpochInfo` method can optionally take a configuration object with the following parameters:

* **`commitment`** (string, optional): Specifies the [commitment level](https://www.helius.dev/blog/solana-commitment-levels) to use when querying the ledger.
  * `finalized`: The node will query the most recent block confirmed by the supermajority of the cluster as having reached maximum lockout.
  * `confirmed`: The node will query the most recent block that has been voted on by a supermajority of the cluster.
  * `processed`: The node will query its most recent block. Note that the block may not be complete.
  * If not provided, the default commitment is `finalized`.
* **`minContextSlot`** (number, optional): The minimum slot at which the request can be evaluated. This can be used to ensure the response is from a recent enough state.

## Response Structure

The `result` field of the JSON-RPC response will be an object containing the following fields:

* **`absoluteSlot`** (u64): The current absolute slot number.
* **`blockHeight`** (u64): The current block height.
* **`epoch`** (u64): The current epoch number.
* **`slotIndex`** (u64): The current slot relative to the start of the current epoch.
* **`slotsInEpoch`** (u64): The total number of slots in the current epoch.
* **`transactionCount`** (u64 | null): The total number of transactions processed in the current epoch. Can be `null` if the data is not available.

## Examples

### 1. Get Current Epoch Information (No Parameters)

This example fetches information about the current epoch using default commitment.

<CodeGroup>
  ```bash cURL
  curl https://mainnet.helius-rpc.com/?api-key=<api-key> -X POST -H "Content-Type: application/json" -d \
    '{
      "jsonrpc": "2.0",
      "id": 1,
      "method": "getEpochInfo"
    }'
  ```

  ```javascript JavaScript (using @solana/web3.js)
  const { Connection } = require('@solana/web3.js');

  async function getCurrentEpochInfo() {
    const connection = new Connection('https://mainnet.helius-rpc.com/?api-key=<api-key>');
    try {
      const epochInfo = await connection.getEpochInfo();
      console.log(JSON.stringify(epochInfo, null, 2));
    } catch (error) {
      console.error('Error fetching epoch information:', error);
    }
  }

  getCurrentEpochInfo();
  ```
</CodeGroup>

### 2. Get Current Epoch Information with 'confirmed' Commitment

This example fetches epoch information using `confirmed` commitment.

<CodeGroup>
  ```bash cURL
  curl https://mainnet.helius-rpc.com/?api-key=<api-key> -X POST -H "Content-Type: application/json" -d \
    '{
      "jsonrpc": "2.0",
      "id": 1,
      "method": "getEpochInfo",
      "params": [
        {
          "commitment": "confirmed"
        }
      ]
    }'
  ```

  ```javascript JavaScript (using @solana/web3.js)
  const { Connection } = require('@solana/web3.js');

  async function getConfirmedEpochInfo() {
    const connection = new Connection('https://mainnet.helius-rpc.com/?api-key=<api-key>');
    try {
      const epochInfo = await connection.getEpochInfo('confirmed'); // Or connection.getEpochInfo({ commitment: 'confirmed' });
      console.log(JSON.stringify(epochInfo, null, 2));
    } catch (error) {
      console.error('Error fetching confirmed epoch information:', error);
    }
  }

  getConfirmedEpochInfo();
  ```
</CodeGroup>

## Developer Tips

* **Commitment Levels:** The choice of `commitment` can affect the timeliness and finality of the data. `processed` is the fastest but least safe, while `finalized` is the safest but may lag slightly. Learn more about [commitment levels](https://www.helius.dev/blog/solana-commitment-levels) for detailed information.
* **`transactionCount` Availability:** The `transactionCount` field might be `null` if the node doesn't have this information readily available or if it's not tracked for the specific commitment level.
* **Epoch Length:** The number of `slotsInEpoch` can vary. You can use `getEpochSchedule` to get more details about the epoch schedule.

This guide provides the necessary information to use the `getEpochInfo` RPC method for retrieving details about the current epoch on the Solana network.


# How to Use getEpochSchedule
Source: https://www.helius.dev/docs/rpc/guides/getepochschedule

Learn getEpochSchedule use cases, code examples, request parameters, response structure, and tips.

The [`getEpochSchedule`](https://www.helius.dev/docs/api-reference/rpc/http/getepochschedule) RPC method returns the [epoch](https://www.helius.dev/blog/solana-slots-blocks-and-epochs) schedule information from the cluster's genesis configuration. This data defines how epochs are structured, including their length and how the leader schedule is determined relative to an epoch's start.

Understanding the epoch schedule is crucial for applications that need to align with network events, predict epoch boundaries, or understand the leader rotation mechanism.

## Common Use Cases

* **Predicting Epoch Boundaries:** Determine the number of slots in an epoch to estimate when the current epoch will end and the next will begin.
* **Leader Schedule Calculation:** Understand the `leaderScheduleSlotOffset` to know how far in advance leader schedules are generated for an upcoming epoch.
* **Analyzing Network Initialization:** Observe `warmup`, `firstNormalEpoch`, and `firstNormalSlot` to understand the initial ramp-up phase of the cluster's epoch lengths if applicable.
* **Building Network Monitoring Tools:** Use this information to display epoch timing and progression accurately.

## Request Parameters

This method does not take any parameters.

## Response Structure

The `result` field of the JSON-RPC response will be an object containing the following fields:

* **`slotsPerEpoch`** (u64): The maximum number of slots in each epoch (after the warmup period, if any).
* **`leaderScheduleSlotOffset`** (u64): The number of slots before the start of an epoch for which the leader schedule for that epoch is generated.
* **`warmup`** (boolean): A boolean indicating whether the cluster has a warmup period where epochs start shorter and gradually increase in length.
* **`firstNormalEpoch`** (u64): The first epoch number that has the full `slotsPerEpoch` length. This is relevant if `warmup` is true.
* **`firstNormalSlot`** (u64): The slot index of the first slot in the `firstNormalEpoch`. This is relevant if `warmup` is true.

## Examples

### 1. Get the Epoch Schedule for the Cluster

This example fetches the epoch schedule.

<CodeGroup>
  ```bash cURL
  curl https://mainnet.helius-rpc.com/?api-key=<api-key> -X POST -H "Content-Type: application/json" -d \
    '{
      "jsonrpc": "2.0",
      "id": 1,
      "method": "getEpochSchedule"
    }'
  ```

  ```javascript JavaScript (using @solana/web3.js)
  const { Connection } = require('@solana/web3.js');

  async function getClusterEpochSchedule() {
    const connection = new Connection('https://mainnet.helius-rpc.com/?api-key=<api-key>');
    try {
      const epochSchedule = await connection.getEpochSchedule();
      console.log(JSON.stringify(epochSchedule, null, 2));
    } catch (error) {
      console.error('Error fetching epoch schedule:', error);
    }
  }

  getClusterEpochSchedule();
  ```
</CodeGroup>

## Developer Tips

* **Static Information:** The epoch schedule is determined by the genesis configuration of the cluster and generally does not change unless there is a significant network upgrade or a new cluster launch with different parameters.
* **Mainnet vs. Testnet/Devnet:** The epoch schedule, particularly `slotsPerEpoch` and warmup parameters, can differ significantly between Mainnet Beta, Testnet, and Devnet. Always query the specific cluster you are interested in.
* **Warmup Period:** If `warmup` is `true`, epochs before `firstNormalEpoch` will have fewer slots than `slotsPerEpoch`. The exact calculation for warmup epoch lengths is `2^N * MINIMUM_SLOTS_PER_EPOCH` where N is the epoch number (starting from 0) up until `firstNormalEpoch` is reached. The `MINIMUM_SLOTS_PER_EPOCH` is typically 32.

This guide provides the necessary information to use the `getEpochSchedule` RPC method to understand the fundamental timing and structure of epochs within a Solana cluster.


# How to Use getFeeForMessage
Source: https://www.helius.dev/docs/rpc/guides/getfeeformessage

Learn getFeeForMessage use cases, code examples, request parameters, response structure, and tips.

The [`getFeeForMessage`](https://www.helius.dev/docs/api-reference/rpc/http/getfeeformessage) RPC method allows you to estimate the fee the network will charge for processing a given transaction message. This is useful for understanding [transaction costs](https://www.helius.dev/blog/solana-fees-in-theory-and-practice) before they are submitted to the network.

**Version Note:** This method is available in `solana-core` v1.9 or newer. For older versions, consider using `getFees`.

## Common Use Cases

* **Fee Estimation:** Determine the likely transaction fee (in lamports) for a specific message.
* **Cost Optimization:** Analyze fees for different transaction structures or at different times.
* **User Interface Display:** Show users an estimated transaction cost before they sign and send a transaction.

## Request Parameters

1. **`message`** (string, required): The transaction message, base64 encoded. You can obtain this by compiling a transaction.
2. **`config`** (object, optional): A configuration object with the following fields:
   * **`commitment`** (string, optional): Specifies the [commitment level](https://www.helius.dev/blog/solana-commitment-levels) to use. Defaults to `finalized`.
   * **`minContextSlot`** (number, optional): The minimum slot at which the request can be evaluated.

## Response Structure

The `result` field of the JSON-RPC response is an object with the following structure:

* **`context`** (object):
  * **`slot`** (u64): The slot at which the fee was evaluated.
* **`value`** (u64 | null): The estimated fee in lamports. This can be `null` if the fee cannot be determined (e.g., if the blockhash used in the message is too old or invalid).

## Examples

### 1. Estimate Fee for a Simple Transfer Message

This example demonstrates how to construct a simple transfer, compile its message, and then fetch the estimated fee.

<CodeGroup>
  ```bash cURL
  # First, you need a base64 encoded message. 
  # This typically involves creating a transaction, compiling its message, 
  # and then base64 encoding the serialized message.
  # The example message below is illustrative.
  # Replace "MESSAGE_BASE64_ENCODED" with your actual encoded message.
  curl https://mainnet.helius-rpc.com/?api-key=<api-key> -X POST -H "Content-Type: application/json" -d \
    '{
      "jsonrpc": "2.0",
      "id": 1,
      "method": "getFeeForMessage",
      "params": [
        "MESSAGE_BASE64_ENCODED", // Replace with your actual base64 encoded message
        { "commitment": "processed" }
      ]
    }'
  ```

  ```javascript JavaScript (using @solana/web3.js)
  const { Connection, Keypair, SystemProgram, Transaction, LAMPORTS_PER_SOL } = require('@solana/web3.js');

  async function estimateTransactionFee() {
    const connection = new Connection('https://devnet.helius-rpc.com/?api-key=<api-key>');

    try {
      const fromPublicKey = Keypair.generate().publicKey;
      const toPublicKey = Keypair.generate().publicKey;

      let transaction = new Transaction().add(
        SystemProgram.transfer({
          fromPubkey: fromPublicKey,
          toPubkey: toPublicKey,
          lamports: 1000,
        })
      );

      transaction.feePayer = fromPublicKey;
      const { blockhash } = await connection.getLatestBlockhash('confirmed');
      transaction.recentBlockhash = blockhash;

      const message = transaction.compileMessage();
      const messageBase64 = message.serialize().toString('base64');

      console.log(`Compiled Message (Base64): ${messageBase64}`);

      const feeResult = await connection.getFeeForMessage(message, 'confirmed');

      if (feeResult && feeResult.value !== null) {
        console.log(`Estimated Fee: ${feeResult.value} lamports`);
      } else {
        console.log('Could not estimate fee. The value was null.');
        console.log('This might happen if the blockhash is too old or the message is invalid.');
      }

    } catch (error) {
      console.error('Error estimating transaction fee:', error);
      if (error.message.includes('failed to get recent blockhash')) {
          console.error('Ensure your RPC endpoint is responsive or try a different commitment level for getLatestBlockhash.');
      }
    }
  }

  estimateTransactionFee();
  ```
</CodeGroup>

## Developer Tips

* **Message Construction:** The key to using `getFeeForMessage` is to correctly construct and serialize the transaction `Message`. This involves setting the fee payer, instructions, and a recent blockhash.
* **Recent Blockhash:** The message must be constructed with a recent blockhash. If the blockhash is too old, the `value` in the response might be `null`.
* **Fee vs. Priority Fee:** This method returns the base network fee. It does not include any additional priority fees you might add to a transaction to increase its likelihood of being processed quickly during times of network congestion. Use `getRecentPrioritizationFees` to estimate [priority fees](https://www.helius.dev/blog/priority-fees-understanding-solanas-transaction-fee-mechanics).
* **Lamports:** The fee is returned in lamports (1 SOL = 1,000,000,000 lamports).
* **Null Value:** A `null` value for the fee can indicate issues with the message (e.g., invalid blockhash, malformed message) or that the node cannot calculate a fee for it at the given commitment level or slot.

This guide provides the necessary steps to utilize the `getFeeForMessage` RPC method for estimating transaction fees on the Solana network.


# How to Use getFirstAvailableBlock
Source: https://www.helius.dev/docs/rpc/guides/getfirstavailableblock

Learn getFirstAvailableBlock use cases, code examples, request parameters, response structure, and tips.

The [`getFirstAvailableBlock`](https://www.helius.dev/docs/api-reference/rpc/http/getfirstavailableblock) RPC method returns the slot number of the lowest (oldest) confirmed block that has not yet been purged from the ledger by the queried node. This is useful for understanding the range of historical data a particular node currently stores.

## Common Use Cases

* **Historical Data Queries:** Determine the starting point from which you can begin querying historical block or transaction data on a specific node.
* **Node Synchronization Checks:** While not a direct measure of synchronization, it can give an idea of how much historical data a node is retaining compared to others.
* **Ledger Analysis:** Understand the depth of the ledger available on a given RPC endpoint.

## Request Parameters

This method does not take any parameters.

## Response Structure

The `result` field of the JSON-RPC response will be a `u64` (unsigned 64-bit integer) representing the slot number of the first available block.

## Examples

### 1. Get the First Available Block Slot

This example fetches the slot of the oldest block available on the queried node.

<CodeGroup>
  ```bash cURL
  curl https://mainnet.helius-rpc.com/?api-key=<api-key> -X POST -H "Content-Type: application/json" -d \
    '{
      "jsonrpc": "2.0",
      "id": 1,
      "method": "getFirstAvailableBlock"
    }'
  ```

  ```javascript JavaScript (using @solana/web3.js)
  const { Connection } = require('@solana/web3.js');

  async function logFirstAvailableBlock() {
    const connection = new Connection('https://mainnet.helius-rpc.com/?api-key=<api-key>');
    try {
      const firstAvailableBlock = await connection.getFirstAvailableBlock();
      console.log(`First Available Block Slot: ${firstAvailableBlock}`);
    } catch (error) {
      console.error('Error fetching first available block:', error);
    }
  }

  logFirstAvailableBlock();
  ```
</CodeGroup>

## Developer Tips

* **Node Specific:** The first available block can vary significantly between different RPC nodes. Nodes can be configured to prune ledger data at different rates, so one node might have a much deeper history than another.
* **Not Fixed:** The value returned by `getFirstAvailableBlock` will increase over time as older slots are eventually purged from the ledger to save space.
* **Confirmed Blocks:** This method refers to confirmed blocks. Blocks that are processed but not yet confirmed or finalized are not considered.

This guide explains how to use the `getFirstAvailableBlock` RPC method to identify the oldest available block slot on a Solana node.


# How to Use getGenesisHash
Source: https://www.helius.dev/docs/rpc/guides/getgenesishash

Learn getGenesisHash use cases, code examples, request parameters, response structure, and tips.

The [`getGenesisHash`](https://www.helius.dev/docs/api-reference/rpc/http/getgenesishash) RPC method returns the genesis hash of the Solana cluster to which you are connected. The genesis hash is a unique identifier for a specific Solana network (e.g., Mainnet Beta, Devnet, Testnet, or a private cluster).

## Common Use Cases

* **Network Verification:** Confirm that your application is connected to the intended Solana cluster (e.g., ensuring you are not accidentally interacting with Mainnet Beta when you intend to use Devnet).
* **Client Configuration:** Some tools or client-side applications might use the genesis hash to configure themselves for a specific network.
* **Cache Invalidation:** Use the genesis hash as part of a cache key to ensure that cached data is specific to a particular cluster, preventing data from one network from being mistakenly used on another.

## Request Parameters

This method does not take any parameters.

## Response Structure

The `result` field of the JSON-RPC response will be a string containing the base-58 encoded genesis hash.

## Examples

### 1. Get the Genesis Hash of the Connected Cluster

This example fetches the genesis hash from the RPC endpoint.

<CodeGroup>
  ```bash cURL
  curl https://mainnet.helius-rpc.com/?api-key=<api-key> -X POST -H "Content-Type: application/json" -d \
    '{
      "jsonrpc": "2.0",
      "id": 1,
      "method": "getGenesisHash"
    }'
  ```

  ```javascript JavaScript (using @solana/web3.js)
  const { Connection } = require('@solana/web3.js');

  async function logGenesisHash() {
    const connection = new Connection('https://mainnet.helius-rpc.com/?api-key=<api-key>');
    try {
      const genesisHash = await connection.getGenesisHash();
      console.log(`Genesis Hash: ${genesisHash}`);
    } catch (error) {
      console.error('Error fetching genesis hash:', error);
    }
  }

  logGenesisHash();
  ```
</CodeGroup>

## Developer Tips

* **Uniqueness:** Each Solana cluster (Mainnet Beta, Devnet, Testnet, and any private clusters) will have its own unique genesis hash.
* **Constant Value:** For a given cluster, the genesis hash is a constant value defined when the cluster was first initialized. It does not change over time.
* **Client-Side Verification:** It's a good practice for client applications to fetch the genesis hash and compare it against an expected value to prevent accidental operations on the wrong network, especially when dealing with sensitive operations or real funds.

This guide shows how to use the `getGenesisHash` RPC method to retrieve the unique identifier for a Solana cluster.


# How to Use getHealth
Source: https://www.helius.dev/docs/rpc/guides/gethealth

Learn getHealth use cases, code examples, request parameters, response structure, and tips.

The [`getHealth`](https://www.helius.dev/docs/api-reference/rpc/http/gethealth) endpoint is used to check the current health status of a Solana RPC node. A healthy node is generally considered to be one that is operational and reasonably synchronized with the rest of the cluster (specifically, within a certain slot distance of the latest cluster confirmed slot, known as `HEALTH_CHECK_SLOT_DISTANCE`).

This endpoint is crucial for monitoring node health, especially for applications or infrastructure that rely on the availability and reliability of an RPC node.

## How it Works

The `getHealth` method uses the standard JSON-RPC POST mechanism with the method `getHealth`. This method checks if the RPC node is healthy and synchronized with the Solana cluster.

## Common Use Cases

* **Node Monitoring:** Regularly check the health of RPC nodes to ensure they are operational and synchronized.
* **Load Balancing:** Use health checks to determine if a node should receive traffic in a load-balanced setup.
* **Failover Systems:** Trigger failover to a backup node if a primary node becomes unhealthy.
* **Debugging Connectivity:** Quickly ascertain if an RPC node is responsive.

## Request Parameters

This method does not take any parameters.

## Response Structure

* **For JSON-RPC `getHealth` POST:**
  * **`result`**: `"ok"` if the node is healthy.
  * It might return an error object or other string values (like `"behind"` or `"unknown"`) if unhealthy, though the exact error response for an unhealthy node can be unstable or vary between providers.

## Examples

### 1. Check Node Health using JSON-RPC (POST with cURL)

<CodeGroup>
  ```bash cURL (JSON-RPC POST)
  curl https://mainnet.helius-rpc.com/?api-key=<api-key> -X POST -H "Content-Type: application/json" -d \
    '{
      "jsonrpc": "2.0",
      "id": 1,
      "method": "getHealth"
    }'
  ```

  ```javascript JavaScript (using @solana/web3.js)
  const { Connection } = require('@solana/web3.js');

  async function checkRpcHealth(rpcUrl) {
      const connection = new Connection(rpcUrl);
      try {
          const health = await connection.rpcRequest('getHealth', []);
          console.log(`getHealth result for ${rpcUrl}:`, health);
          return health.result;
      } catch (error) {
          console.error(`Error calling getHealth for ${rpcUrl}:`, error.message);
          return null;
      }
  }

  // Example usage:
  checkRpcHealth('https://mainnet.helius-rpc.com/?api-key=<api-key>');
  ```
</CodeGroup>

**Expected JSON-RPC response (for a healthy node):**

```json
{
  "jsonrpc": "2.0",
  "result": "ok",
  "id": 1
}
```

## Developer Tips

* **Definition of Healthy:** "Healthy" generally means the node is responsive and not too far behind the cluster's tip. The exact slot difference (`HEALTH_CHECK_SLOT_DISTANCE`) can be configured on the node.
* **Interpreting `"behind"` or `"unknown"`:** If you receive `"behind {distance}"` or `"unknown"`, the node is operational but may not be fully caught up or able to ascertain its status relative to the cluster. Depending on your application's requirements, you might treat these states differently.
* **Provider Differences:** The exact behavior and response codes/bodies for an unhealthy node might vary slightly between RPC providers.
* **Error Handling:** Always implement proper error handling when calling `getHealth`, as network issues or node problems can cause the request to fail entirely.

This guide provides the necessary information to use the `getHealth` endpoint for monitoring the status of a Solana RPC node.


# How to Use getHighestSnapshotSlot
Source: https://www.helius.dev/docs/rpc/guides/gethighestsnapshotslot

Learn getHighestSnapshotSlot use cases, code examples, request parameters, response structure, and tips.

The [`getHighestSnapshotSlot`](https://www.helius.dev/docs/api-reference/rpc/http/gethighestsnapshotslot) RPC method returns information about the highest slot for which the queried Solana node has ledger snapshots. This includes both the latest full snapshot slot and, if available, the latest incremental snapshot slot that is based on that full snapshot.

Snapshots are crucial for nodes to quickly sync with the network and for ledger maintenance.

**Version Note:** This method is available in `solana-core` v1.9 or newer. For older versions (v1.8 and below), use `getSnapshotSlot`.

## Common Use Cases

* **Node Monitoring:** Determine how up-to-date a node's snapshots are.
* **Understanding Node State:** Get insights into a node's ledger retention and snapshotting process.
* **Debugging Sync Issues:** Help diagnose if a node is falling behind in generating or retrieving snapshots.

## Request Parameters

This method does not take any parameters.

## Response Structure

The `result` field of the JSON-RPC response will be an object with the following fields:

* **`full`** (u64): The slot number of the highest full snapshot available on the node.
* **`incremental`** (u64 | null): The slot number of the highest incremental snapshot that builds upon the `full` snapshot. This can be `null` if no incremental snapshot is available for the latest full snapshot or if incremental snapshots are not enabled/generated.

If the node does not have any snapshots, the behavior might vary (e.g., an error or specific null-like values, depending on the RPC provider's implementation).

## Examples

### 1. Get the Highest Snapshot Slot Information

This example fetches the highest snapshot slot details from the RPC endpoint.

<CodeGroup>
  ```bash cURL
  curl https://mainnet.helius-rpc.com/?api-key=<api-key> -X POST -H "Content-Type: application/json" -d \
    '{
      "jsonrpc": "2.0",
      "id": 1,
      "method": "getHighestSnapshotSlot"
    }'
  ```

  ```javascript JavaScript (using @solana/web3.js)
  const { Connection } = require('@solana/web3.js');

  async function logHighestSnapshotSlot() {
    const connection = new Connection('https://mainnet.helius-rpc.com/?api-key=<api-key>');
    try {
      const snapshotSlotInfo = await connection.getHighestSnapshotSlot();
      console.log('Highest Snapshot Slot Information:');
      console.log(`  Full Snapshot Slot: ${snapshotSlotInfo.full}`);
      console.log(`  Incremental Snapshot Slot: ${snapshotSlotInfo.incremental !== null ? snapshotSlotInfo.incremental : 'N/A'}`);
    } catch (error) {
      console.error('Error fetching highest snapshot slot:', error);
    }
  }

  logHighestSnapshotSlot();
  ```
</CodeGroup>

## Developer Tips

* **Node Specific:** The snapshot information is specific to the node being queried. Different nodes in the cluster might have different highest snapshot slots depending on their configuration and operational status.
* **Snapshotting Frequency:** Nodes create snapshots at configured intervals. The highest snapshot slot will advance as new snapshots are generated.
* **Full vs. Incremental Snapshots:**
  * A **full snapshot** contains all ledger state up to a certain slot.
  * An **incremental snapshot** contains only the changes since a previous (usually full) snapshot, making them smaller and faster to create and restore from, assuming the base full snapshot is available.
* **Availability:** This method is available on `solana-core` versions 1.9 and newer. Ensure your node or RPC provider supports this version if you intend to use it.

This guide explains how to use the `getHighestSnapshotSlot` RPC method to retrieve information about the latest snapshots available on a Solana node.


# How to Use getIdentity
Source: https://www.helius.dev/docs/rpc/guides/getidentity

Learn getIdentity use cases, code examples, request parameters, response structure, and tips.

The [`getIdentity`](https://www.helius.dev/docs/api-reference/rpc/http/getidentity) RPC method returns the public key (also known as the identity or node ID) of the specific Solana RPC node to which you are connected. Each node in the Solana network has a unique cryptographic keypair, and its public key serves as its identifier.

## Common Use Cases

* **Node Identification:** Uniquely identify the RPC node you are communicating with, especially in distributed setups or when interacting with multiple RPC providers.
* **Network Analysis:** When combined with `getClusterNodes`, you can match the identity from `getIdentity` to a node in the cluster list to find more details about the specific node you are querying.
* **Debugging and Logging:** Log the identity of the node for debugging purposes or to track which node served a particular request.
* **Verification (Advanced):** In some specific scenarios, the node identity might be used in higher-level protocols or for verification purposes, though this is less common for typical dApp interactions.

## Request Parameters

This method does not take any parameters.

## Response Structure

The `result` field of the JSON-RPC response will be an object containing a single field:

* **`identity`** (string): The base-58 encoded public key of the RPC node.

## Examples

### 1. Get the Identity of the Connected RPC Node

This example fetches the public key of the RPC node.

<CodeGroup>
  ```bash cURL
  curl https://mainnet.helius-rpc.com/?api-key=<api-key> -X POST -H "Content-Type: application/json" -d \
    '{
      "jsonrpc": "2.0",
      "id": 1,
      "method": "getIdentity"
    }'
  ```

  ```javascript JavaScript (using @solana/web3.js)
  const { Connection } = require('@solana/web3.js');

  async function logNodeIdentity() {
    const connection = new Connection('https://mainnet.helius-rpc.com/?api-key=<api-key>');
    try {
      const identityInfo = await connection.getIdentity();
      console.log(`Node Identity (Public Key): ${identityInfo.identity}`);
    } catch (error) {
      console.error('Error fetching node identity:', error);
    }
  }

  logNodeIdentity();
  ```
</CodeGroup>

## Developer Tips

* **Node Specific:** The returned identity is unique to the specific RPC node instance you are connected to. If you connect to a different RPC endpoint (even if it's part of the same cluster or operated by the same provider but load-balanced), you might get a different identity.
* **Not for User Wallets:** The identity returned is for the RPC node itself, not for any user wallet or account on the Solana network.
* **Stability:** The identity of a given node is generally stable but could change if the node operator reconfigures or replaces the node's keypair.

This guide demonstrates how to use the `getIdentity` RPC method to retrieve the unique public key of the Solana node you are interacting with.


# How to Use getInflationGovernor
Source: https://www.helius.dev/docs/rpc/guides/getinflationgovernor

Learn getInflationGovernor use cases, code examples, request parameters, response structure, and tips.

The [`getInflationGovernor`](https://www.helius.dev/docs/api-reference/rpc/http/getinflationgovernor) RPC method returns the current [inflation](https://www.helius.dev/blog/solana-issuance-inflation-schedule) parameters for the Solana cluster. These parameters define how the issuance of new SOL (inflation) is managed over time, including the initial rate, how it tapers, the long-term terminal rate, and allocations for the foundation.

Understanding these parameters is important for analyses related to tokenomics, staking rewards, and the overall economic model of Solana.

## Common Use Cases

* **Economic Analysis:** Retrieve the current parameters governing SOL inflation for research or modeling.
* **Staking Reward Calculation:** While `getInflationRate` gives the current annual rate, `getInflationGovernor` provides the underlying parameters that determine this rate and its future trajectory.
* **Understanding Tokenomics:** Gain insight into the planned token supply changes over time.

## Request Parameters

This method can optionally take a configuration object with the following parameter:

* **`commitment`** (string, optional): Specifies the [commitment level](https://www.helius.dev/blog/solana-commitment-levels) to use when querying the ledger. If not provided, the default commitment of the node is used (usually `finalized`).

## Response Structure

The `result` field of the JSON-RPC response will be an object containing the following inflation parameters (all are `f64` floating-point numbers representing percentages or terms):

* **`initial`**: The initial inflation rate (e.g., 0.15 for 15%).
* **`terminal`**: The long-term, terminal inflation rate (e.g., 0.015 for 1.5%).
* **`taper`**: The rate at which the inflation rate decreases from the `initial` to the `terminal` rate. This is a yearly percentage decrease in the inflation rate itself (e.g., a taper of 0.15 means the inflation rate decreases by 15% each year until it reaches the terminal rate).
* **`foundation`**: The proportion of the newly inflated SOL allocated to the Solana Foundation (e.g., 0.05 for 5%).
* **`foundationTerm`**: The period, in years, over which the `foundation` allocation is distributed.

## Examples

### 1. Get Current Inflation Governor Parameters

This example fetches the current inflation governor settings using the default commitment.

<CodeGroup>
  ```bash cURL
  curl https://mainnet.helius-rpc.com/?api-key=<api-key> -X POST -H "Content-Type: application/json" -d \
    '{
      "jsonrpc": "2.0",
      "id": 1,
      "method": "getInflationGovernor"
    }'
  ```

  ```javascript JavaScript (using @solana/web3.js)
  const { Connection } = require('@solana/web3.js');

  async function logInflationGovernor() {
    const connection = new Connection('https://mainnet.helius-rpc.com/?api-key=<api-key>');
    try {
      const inflationGovernor = await connection.getInflationGovernor();
      console.log('Current Inflation Governor Parameters:');
      console.log(`  Initial Rate: ${(inflationGovernor.initial * 100).toFixed(2)}%`);
      console.log(`  Terminal Rate: ${(inflationGovernor.terminal * 100).toFixed(2)}%`);
      console.log(`  Taper Rate: ${(inflationGovernor.taper * 100).toFixed(2)}% per year`);
      console.log(`  Foundation Allocation: ${(inflationGovernor.foundation * 100).toFixed(2)}%`);
      console.log(`  Foundation Term: ${inflationGovernor.foundationTerm} years`);
      // For full raw details:
      // console.log(JSON.stringify(inflationGovernor, null, 2));
    } catch (error) {
      console.error('Error fetching inflation governor:', error);
    }
  }

  logInflationGovernor();
  ```
</CodeGroup>

### 2. Get Inflation Governor Parameters with 'confirmed' Commitment

<CodeGroup>
  ```bash cURL
  curl https://mainnet.helius-rpc.com/?api-key=<api-key> -X POST -H "Content-Type: application/json" -d \
    '{
      "jsonrpc": "2.0",
      "id": 1,
      "method": "getInflationGovernor",
      "params":[{"commitment":"confirmed"}]
    }'
  ```

  ```javascript JavaScript (using @solana/web3.js)
  const { Connection } = require('@solana/web3.js');

  async function logConfirmedInflationGovernor() {
    const connection = new Connection('https://mainnet.helius-rpc.com/?api-key=<api-key>');
    try {
      const inflationGovernor = await connection.getInflationGovernor('confirmed');
      console.log('Confirmed Inflation Governor Parameters:');
      console.log(`  Initial Rate: ${(inflationGovernor.initial * 100).toFixed(2)}%`);
      console.log(`  Terminal Rate: ${(inflationGovernor.terminal * 100).toFixed(2)}%`);
      // console.log(JSON.stringify(inflationGovernor, null, 2));
    } catch (error) {
      console.error('Error fetching confirmed inflation governor:', error);
    }
  }

  logConfirmedInflationGovernor();
  ```
</CodeGroup>

## Developer Tips

* **Static Parameters:** These inflation parameters are set at the genesis of the cluster or by network upgrades and are generally not expected to change frequently without a formal governance process and network update.
* **Impact on Staking Rewards:** These parameters collectively determine the overall inflation schedule, which in turn affects the Annual Percentage Rate (APR) for staking SOL.
* **Foundation Allocation:** The `foundation` and `foundationTerm` parameters describe a specific portion of the inflation directed towards the Solana Foundation for a defined period to support ecosystem development and operations.

This guide provides an overview of how to use the `getInflationGovernor` RPC method to retrieve and understand the core parameters governing inflation on the Solana network.


# How to Use getInflationRate
Source: https://www.helius.dev/docs/rpc/guides/getinflationrate

Learn getInflationRate use cases, code examples, request parameters, response structure, and tips.

The [`getInflationRate`](https://www.helius.dev/docs/api-reference/rpc/http/getinflationrate) RPC method returns a breakdown of the [inflation](https://www.helius.dev/blog/solana-issuance-inflation-schedule) rates for the current epoch. This includes the total inflation rate, the portion allocated to validators, the portion allocated to the foundation, and the epoch number these rates apply to.

This method provides a snapshot of the current rewards distribution from new token issuance (inflation).

## Common Use Cases

* **Staking Reward Estimation:** Understand the current annualized inflation rate being distributed to validators, which is a key component in calculating staking APR.
* **Monitoring Foundation Allocation:** Observe the portion of current inflation directed towards the Solana Foundation.
* **Current Epoch Analysis:** Get a quick overview of the inflation metrics for the active epoch.

## Request Parameters

This method does not take any parameters.

## Response Structure

The `result` field of the JSON-RPC response will be an object containing:

* **`total`** (f64): The total inflation rate for the current epoch (e.g., 0.065 for 6.5%).
* **`validator`** (f64): The portion of the total inflation rate allocated to validators for the current epoch (e.g., 0.06 for 6%).
* **`foundation`** (f64): The portion of the total inflation rate allocated to the foundation for the current epoch (e.g., 0.005 for 0.5%).
* **`epoch`** (u64): The epoch number for which these inflation rates are valid.

## Examples

### 1. Get Current Epoch Inflation Rates

This example fetches the inflation rate details for the current epoch.

<CodeGroup>
  ```bash cURL
  curl https://mainnet.helius-rpc.com/?api-key=<api-key> -X POST -H "Content-Type: application/json" -d \
    '{
      "jsonrpc": "2.0",
      "id": 1,
      "method": "getInflationRate"
    }'
  ```

  ```javascript JavaScript (using @solana/web3.js)
  const { Connection } = require('@solana/web3.js');

  async function logCurrentInflationRate() {
    const connection = new Connection('https://mainnet.helius-rpc.com/?api-key=<api-key>');
    try {
      const inflationRate = await connection.getInflationRate();
      console.log(`Inflation Rate for Epoch ${inflationRate.epoch}:`);
      console.log(`  Total: ${(inflationRate.total * 100).toFixed(4)}%`);
      console.log(`  Validator: ${(inflationRate.validator * 100).toFixed(4)}%`);
      console.log(`  Foundation: ${(inflationRate.foundation * 100).toFixed(4)}%`);
      // For full raw details:
      // console.log(JSON.stringify(inflationRate, null, 2));
    } catch (error) {
      console.error('Error fetching inflation rate:', error);
    }
  }

  logCurrentInflationRate();
  ```
</CodeGroup>

## Developer Tips

* **Epoch Specific:** The returned values are specific to the current epoch at the time of the query. These rates are derived from the overall inflation schedule defined by `getInflationGovernor` but represent the annualized rate for this specific epoch.
* **Annualized Rates:** The rates are typically expressed as annualized percentages, even though they apply to the current epoch.
* **Dynamic Values:** While the underlying inflation schedule (`getInflationGovernor`) changes infrequently, the calculated `getInflationRate` will vary epoch by epoch as the overall inflation tapers.

This guide explains how to use the `getInflationRate` RPC method to get a snapshot of the current epoch's inflation distribution.


# How to Use getInflationReward
Source: https://www.helius.dev/docs/rpc/guides/getinflationreward

Learn getInflationReward use cases, code examples, request parameters, response structure, and tips.

The [`getInflationReward`](https://www.helius.dev/docs/api-reference/rpc/http/getinflationreward) RPC method allows you to query the [inflation](https://www.helius.dev/blog/solana-issuance-inflation-schedule) rewards (commonly known as staking rewards) that were credited to one or more addresses for a specific epoch.

This is useful for verifying rewards received by stake accounts or any account that might have received inflation rewards.

## Common Use Cases

* **Verify Staking Rewards:** Check if a stake account received the expected rewards for a past epoch.
* **Track Reward History:** Query rewards for multiple epochs to build a history for an address.
* **Audit Validator Payouts:** Validators can use this to verify reward distribution (though rewards are paid to stake accounts, not directly to validator identities).

## Request Parameters

The method takes two main parameters:

1. **`addresses`** (array of strings): A list of base-58 encoded public keys for the accounts you want to query. The maximum number of addresses allowed may vary depending on the RPC provider (e.g., Helius allows up to 1005 for paid plans).
2. **`config`** (object, optional): A configuration object with the following optional fields:
   * **`commitment`** (string, optional): Specifies the [commitment level](https://www.helius.dev/blog/solana-commitment-levels). Defaults to `finalized` if not provided.
   * **`epoch`** (integer, optional): The epoch number for which to fetch the rewards. If omitted, the RPC node will typically use the most recently completed epoch for which rewards have been distributed.
   * **`minContextSlot`** (integer, optional): The minimum slot that the request can be evaluated at. This ensures the query is made against a ledger state that has processed up to at least this slot.

## Response Structure

The `result` field of the JSON-RPC response will be an array corresponding to the input `addresses` array. Each element in the result array will either be:

* An **object** containing the inflation reward details if the address received a reward for the specified epoch.
* **`null`** if the address did not receive an inflation reward for that epoch or if the account did not exist.

The reward object has the following fields:

* **`epoch`** (u64): The epoch for which this reward was credited.
* **`effectiveSlot`** (u64): The slot in which the reward was applied and became effective.
* **`amount`** (u64): The amount of the reward, in lamports.
* **`postBalance`** (u64): The balance of the account, in lamports, after the reward was credited.
* **`commission`** (u8 | undefined): For vote accounts, this is the commission percentage (0-100) taken by the validator at the time the reward was credited. It will be `undefined` for non-vote accounts.

## Examples

### 1. Get Inflation Reward for a Single Address (Previous Epoch)

This example fetches the inflation reward for a specific address for the most recently completed epoch.

<CodeGroup>
  ```bash cURL
  # Replace YOUR_VOTE_ACCOUNT_PUBKEY with an actual vote account public key
  # Replace <api-key> with your Helius API key
  curl https://mainnet.helius-rpc.com/?api-key=<api-key> -X POST -H "Content-Type: application/json" -d \
    '{
      "jsonrpc": "2.0",
      "id": 1,
      "method": "getInflationReward",
      "params": [
        ["YOUR_VOTE_ACCOUNT_PUBKEY"]
      ]
    }'
  ```

  ```javascript JavaScript (using @solana/web3.js)
  // Replace YOUR_VOTE_ACCOUNT_PUBKEY with an actual vote account public key
  // Replace <api-key> with your Helius API key
  const { Connection, PublicKey } = require('@solana/web3.js');

  async function checkInflationReward() {
    const connection = new Connection('https://mainnet.helius-rpc.com/?api-key=<api-key>');
    const voteAccountPubkey = new PublicKey('YOUR_VOTE_ACCOUNT_PUBKEY'); // Example: 'Vote111111111111111111111111111111111111111'

    try {
      const rewards = await connection.getInflationReward([voteAccountPubkey]);
      if (rewards && rewards[0]) {
        const rewardInfo = rewards[0];
        console.log(`Reward for Epoch ${rewardInfo.epoch}:`);
        console.log(`  Amount: ${rewardInfo.amount} lamports`);
        console.log(`  Effective Slot: ${rewardInfo.effectiveSlot}`);
        console.log(`  Post Balance: ${rewardInfo.postBalance} lamports`);
        if (rewardInfo.commission !== undefined) {
          console.log(`  Commission: ${rewardInfo.commission}%`);
        }
      } else {
        console.log('No inflation reward found for the address in the previous epoch.');
      }
      // console.log(JSON.stringify(rewards, null, 2));
    } catch (error) {
      console.error('Error fetching inflation reward:', error);
    }
  }

  checkInflationReward();
  ```
</CodeGroup>

### 2. Get Inflation Rewards for Multiple Addresses for a Specific Epoch

<CodeGroup>
  ```bash cURL
  # Replace <api-key> with your Helius API key
  # Replace PUBKEY_1 and PUBKEY_2 with actual public keys
  curl https://mainnet.helius-rpc.com/?api-key=<api-key> -X POST -H "Content-Type: application/json" -d \
    '{
      "jsonrpc": "2.0",
      "id": 1,
      "method": "getInflationReward",
      "params": [
        ["PUBKEY_1", "PUBKEY_2"],
        { "epoch": 450, "commitment": "confirmed" }
      ]
    }'
  ```

  ```javascript JavaScript (using @solana/web3.js)
  // Replace <api-key> with your Helius API key
  // Replace PUBKEY_1 and PUBKEY_2 with actual public keys
  const { Connection, PublicKey } = require('@solana/web3.js');

  async function checkMultipleRewards() {
    const connection = new Connection('https://mainnet.helius-rpc.com/?api-key=<api-key>');
    const address1 = new PublicKey('PUBKEY_1'); 
    const address2 = new PublicKey('PUBKEY_2');
    const specificEpoch = 450;

    try {
      const rewards = await connection.getInflationReward(
        [address1, address2],
        specificEpoch,
        { commitment: 'confirmed' }
      );
      rewards.forEach((rewardInfo, index) => {
        const address = index === 0 ? 'PUBKEY_1' : 'PUBKEY_2';
        if (rewardInfo) {
          console.log(`Reward for ${address} in Epoch ${rewardInfo.epoch}:`);
          console.log(`  Amount: ${rewardInfo.amount} lamports`);
        } else {
          console.log(`No inflation reward found for ${address} in Epoch ${specificEpoch}.`);
        }
      });
      // console.log(JSON.stringify(rewards, null, 2));
    } catch (error) {
      console.error('Error fetching inflation rewards for epoch ', specificEpoch, error);
    }
  }

  checkMultipleRewards();
  ```
</CodeGroup>

## Developer Tips

* **Epoch Specificity:** Rewards are credited once per epoch. Ensure you are querying for the correct epoch number.
* **Timing of Rewards:** Inflation rewards are calculated at the end of an epoch and applied at the beginning of the next. The `effectiveSlot` indicates when this happens.
* **Null Results:** A `null` result for an address means no reward was found for that address in the specified epoch. This could be because the account wasn't eligible (e.g., not a sufficiently staked stake account), the reward was zero, or the account didn't exist at that time.
* **Rate Limits:** Be mindful of RPC provider rate limits, especially when querying for a large number of addresses.

This guide helps you use the `getInflationReward` method to accurately retrieve and verify staking rewards on the Solana network.


# How to Use getLargestAccounts
Source: https://www.helius.dev/docs/rpc/guides/getlargestaccounts

Learn getLargestAccounts use cases, code examples, request parameters, response structure, and tips.

The [`getLargestAccounts`](https://www.helius.dev/docs/api-reference/rpc/http/getlargestaccounts) RPC method returns a list of the top 20 accounts on the Solana network, ranked by their lamport balance. This method can be useful for network analysis, understanding wealth distribution, or identifying significant holders of SOL.

Note that the results from this method may be cached by the RPC node for up to two hours.

## Common Use Cases

* **Network Health Monitoring:** Observe the concentration of SOL in the largest accounts.
* **Economic Analysis:** Study the distribution of wealth on the Solana network.
* **Identifying Whales:** Find accounts holding significant amounts of SOL.

## Request Parameters

This method can optionally take a configuration object with the following parameters:

* **`commitment`** (string, optional): Specifies the [commitment level](https://www.helius.dev/blog/solana-commitment-levels) to use when querying the ledger. If not provided, the default commitment of the node is used.
* **`filter`** (string, optional): Filters the results by account type. Accepted values are:
  * `circulating`: Returns the largest accounts that are part of the circulating supply.
  * `nonCirculating`: Returns the largest accounts that are not part of the circulating supply (e.g., locked accounts, foundation accounts).
    If omitted, all accounts are considered without this specific filter.

## Response Structure

The `result` field of the JSON-RPC response will be an `RpcResponse` object. The `value` field within this object is an array of up to 20 account objects, each containing:

* **`address`** (string): The base-58 encoded public key of the account.
* **`lamports`** (u64): The balance of the account in lamports.

The response also includes a `context` object with the `slot` at which the information was retrieved.

## Examples

### 1. Get the Top 20 Largest Accounts (No Filter)

This example fetches the top 20 largest accounts by lamport balance without any supply filter.

<CodeGroup>
  ```bash cURL
  # Replace <api-key> with your Helius API key
  curl https://mainnet.helius-rpc.com/?api-key=<api-key> -X POST -H "Content-Type: application/json" -d \
    '{
      "jsonrpc": "2.0",
      "id": 1,
      "method": "getLargestAccounts"
    }'
  ```

  ```javascript JavaScript (using @solana/web3.js)
  // Replace <api-key> with your Helius API key
  const { Connection } = require('@solana/web3.js');

  async function logLargestAccounts() {
    const connection = new Connection('https://mainnet.helius-rpc.com/?api-key=<api-key>');
    try {
      const largestAccounts = await connection.getLargestAccounts();
      console.log(`Largest Accounts (Slot: ${largestAccounts.context.slot}):`);
      largestAccounts.value.forEach((account, index) => {
        console.log(
          `  ${index + 1}. Address: ${account.address}, Balance: ${account.lamports / 10**9} SOL`
        );
      });
      // For full raw details:
      // console.log(JSON.stringify(largestAccounts, null, 2));
    } catch (error) {
      console.error('Error fetching largest accounts:', error);
    }
  }

  logLargestAccounts();
  ```
</CodeGroup>

### 2. Get the Top 20 Largest Circulating Accounts

This example fetches the top 20 largest accounts that are considered part of the circulating supply.

<CodeGroup>
  ```bash cURL
  # Replace <api-key> with your Helius API key
  curl https://mainnet.helius-rpc.com/?api-key=<api-key> -X POST -H "Content-Type: application/json" -d \
    '{
      "jsonrpc": "2.0",
      "id": 1,
      "method": "getLargestAccounts",
      "params": [{ "filter": "circulating" }]
    }'
  ```

  ```javascript JavaScript (using @solana/web3.js)
  // Replace <api-key> with your Helius API key
  const { Connection } = require('@solana/web3.js');

  async function logLargestCirculatingAccounts() {
    const connection = new Connection('https://mainnet.helius-rpc.com/?api-key=<api-key>');
    try {
      const largestAccounts = await connection.getLargestAccounts({ filter: 'circulating' });
      console.log(`Largest Circulating Accounts (Slot: ${largestAccounts.context.slot}):`);
      largestAccounts.value.forEach((account, index) => {
        console.log(
          `  ${index + 1}. Address: ${account.address}, Balance: ${account.lamports / 10**9} SOL`
        );
      });
      // console.log(JSON.stringify(largestAccounts, null, 2));
    } catch (error) {
      console.error('Error fetching largest circulating accounts:', error);
    }
  }

  logLargestCirculatingAccounts();
  ```
</CodeGroup>

## Developer Tips

* **Cached Data:** The results can be cached by the RPC node for up to two hours. This means the data might not be real-time to the latest block.
* **Limited to Top 20:** This method only returns the top 20 accounts. For a more comprehensive analysis of wealth distribution, other data sources or methods might be needed.
* **Filter Behavior:** The `circulating` and `nonCirculating` filters depend on the RPC node's definition and data sources for these classifications.

This guide provides the necessary information to use the `getLargestAccounts` RPC method for querying the largest SOL holders on the Solana network.


# How to Use getLatestBlockhash
Source: https://www.helius.dev/docs/rpc/guides/getlatestblockhash

Learn getLatestBlockhash use cases, code examples, request parameters, response structure, and tips.

The [`getLatestBlockhash`](https://www.helius.dev/docs/api-reference/rpc/http/getlatestblockhash) RPC method is essential for preparing and sending transactions on the Solana network. It retrieves the most recent blockhash processed by the node, along with the last block height at which this blockhash will remain valid. For more details on how to effectively use blockhashes and ensure your [transactions land](https://www.helius.dev/blog/how-to-land-transactions-on-solana), refer to our comprehensive guide.

Every transaction on Solana must reference a recent blockhash. This mechanism helps prevent certain types of attacks, such as transaction replay on a forked chain.

**Version Note:** This method is available in `solana-core` v1.9 or newer. For nodes running `solana-core` v1.8 or older, use the `getRecentBlockhash` method instead.

## Common Use Cases

* **Transaction Building:** Obtain a recent blockhash to include in a new transaction before signing and sending it.
* **Transaction Lifetime Management:** Use `lastValidBlockHeight` to understand how long a transaction referencing the fetched blockhash can be expected to remain valid.
* **Preflight Checks:** While `simulateTransaction` can do this implicitly, applications might fetch a blockhash to manually prepare a transaction for simulation.

## Request Parameters

This method can optionally take a configuration object with the following parameters:

* **`commitment`** (string, optional): Specifies the [commitment level](https://www.helius.dev/blog/solana-commitment-levels) for the query. If omitted, the node's default commitment is used. For transactions, it's common to use `confirmed` or `finalized` to ensure the blockhash is from a reasonably stable part of the chain.
* **`minContextSlot`** (integer, optional): The minimum slot that the request can be evaluated at. This ensures the query is made against a ledger state that has processed up to at least this slot.

## Response Structure

The `result` field of the JSON-RPC response will be an `RpcResponse` object. The `value` field within this object contains:

* **`blockhash`** (string): A base-58 encoded string representing the latest blockhash.
* **`lastValidBlockHeight`** (u64): The block height at which the `blockhash` will expire. A transaction citing this `blockhash` is valid until the network reaches this `lastValidBlockHeight`.

The response also includes a `context` object with the `slot` at which the information was retrieved.

## Examples

### 1. Get the Latest Blockhash with Default Commitment

This example fetches the latest blockhash using the node's default commitment.

<CodeGroup>
  ```bash cURL
  # Replace <api-key> with your Helius API key
  curl https://mainnet.helius-rpc.com/?api-key=<api-key> -X POST -H "Content-Type: application/json" -d \
    '{
      "jsonrpc": "2.0",
      "id": 1,
      "method": "getLatestBlockhash"
    }'
  ```

  ```javascript JavaScript (using @solana/web3.js)
  // Replace <api-key> with your Helius API key
  const { Connection } = require('@solana/web3.js');

  async function fetchLatestBlockhash() {
    const connection = new Connection('https://mainnet.helius-rpc.com/?api-key=<api-key>');
    try {
      const { blockhash, lastValidBlockHeight } = await connection.getLatestBlockhash();
      console.log('Latest Blockhash Info:');
      console.log(`  Blockhash: ${blockhash}`);
      console.log(`  Last Valid Block Height: ${lastValidBlockHeight}`);
      // This blockhash can now be used in a transaction
    } catch (error) {
      console.error('Error fetching latest blockhash:', error);
    }
  }

  fetchLatestBlockhash();
  ```
</CodeGroup>

### 2. Get the Latest Blockhash with 'confirmed' Commitment

This example explicitly requests the latest blockhash with `confirmed` commitment.

<CodeGroup>
  ```bash cURL
  # Replace <api-key> with your Helius API key
  curl https://mainnet.helius-rpc.com/?api-key=<api-key> -X POST -H "Content-Type: application/json" -d \
    '{
      "jsonrpc": "2.0",
      "id": 1,
      "method": "getLatestBlockhash",
      "params": [{ "commitment": "confirmed" }]
    }'
  ```

  ```javascript JavaScript (using @solana/web3.js)
  // Replace <api-key> with your Helius API key
  const { Connection } = require('@solana/web3.js');

  async function fetchConfirmedBlockhash() {
    const connection = new Connection('https://mainnet.helius-rpc.com/?api-key=<api-key>');
    try {
      const { blockhash, lastValidBlockHeight } = await connection.getLatestBlockhash('confirmed');
      console.log('Confirmed Blockhash Info:');
      console.log(`  Blockhash: ${blockhash}`);
      console.log(`  Last Valid Block Height: ${lastValidBlockHeight}`);
    } catch (error) {
      console.error('Error fetching confirmed blockhash:', error);
    }
  }

  fetchConfirmedBlockhash();
  ```
</CodeGroup>

## Developer Tips

* **Blockhash Validity:** A blockhash is valid for a limited time, approximately 2 minutes (though this can vary). Transactions must be confirmed by the network before their `lastValidBlockHeight` is passed. Always fetch a fresh blockhash if considerable time has passed since the last one was obtained.
* **Choosing Commitment:** For critical transactions, using `finalized` commitment provides the strongest guarantee that the blockhash is from the main chain fork, but it may be slightly older. `confirmed` offers a good balance. Learn more about [commitment levels](https://www.helius.dev/blog/solana-commitment-levels) for detailed information.
* **Transaction Fees:** Remember to also calculate and include appropriate transaction fees. The blockhash itself does not determine the fee.
* **Retry Logic:** If a transaction expires because its `lastValidBlockHeight` is passed, you must re-sign it with a new, more recent blockhash and resubmit.

This guide provides the steps to use `getLatestBlockhash` effectively, a cornerstone for interacting with the Solana network through transactions.


# How to Use getLeaderSchedule
Source: https://www.helius.dev/docs/rpc/guides/getleaderschedule

Learn getLeaderSchedule use cases, code examples, request parameters, response structure, and tips.

The [`getLeaderSchedule`](https://www.helius.dev/docs/api-reference/rpc/http/getleaderschedule) RPC method returns the assignment of block production leadership to validators for a specific epoch. Understanding the leader schedule can be useful for network analysis, predicting which validator will produce blocks at certain times, or for tools that interact with specific leaders.

## Common Use Cases

* **Network Monitoring:** Observe the distribution of leader slots among validators in an epoch.
* **Transaction Routing (Advanced):** Some advanced applications might try to route transactions to the current or upcoming leader, though this is generally handled by the network and RPC nodes.
* **Validator Performance Analysis:** Correlate the leader schedule with actual block production to assess validator uptime and performance.
* **Understanding Epoch Progression:** See which validators are responsible for producing blocks throughout an epoch.

## Request Parameters

The method can take up to two optional parameters:

1. **`slot`** (u64, optional): A slot number. If provided, the leader schedule for the epoch containing this slot will be fetched. If `null` or omitted, the leader schedule for the current epoch is fetched.
2. **`config`** (object, optional): A configuration object that can contain:
   * **`commitment`** (string, optional): Specifies the [commitment level](https://www.helius.dev/blog/solana-commitment-levels). If not provided, the node's default commitment is used.
   * **`identity`** (string, optional): A base-58 encoded public key of a validator. If provided, the returned schedule will only include slots assigned to this specific validator.

## Response Structure

The `result` field of the JSON-RPC response will be:

* `null`: If the epoch corresponding to the requested `slot` (or current epoch if no slot is provided) is not found or its leader schedule is not available (e.g., for a future, uncalculated epoch).
* An **object**: If a schedule is found. This object is a map where:
  * Each **key** is the base-58 encoded public key (identity) of a validator.
  * The corresponding **value** is an array of numbers. Each number is a slot index *relative to the start of the epoch* for which that validator is the leader.

For example, if an epoch starts at slot `1000` and a validator has `[0, 1, 5]` in its schedule, it means that validator is the leader for slots `1000`, `1001`, and `1005`.

## Examples

### 1. Get Leader Schedule for the Current Epoch

This example fetches the complete leader schedule for the current epoch.

<CodeGroup>
  ```bash cURL
  # Replace <api-key> with your Helius API key
  curl https://mainnet.helius-rpc.com/?api-key=<api-key> -X POST -H "Content-Type: application/json" -d \
    '{
      "jsonrpc": "2.0",
      "id": 1,
      "method": "getLeaderSchedule"
    }'
  ```

  ```javascript JavaScript (using @solana/web3.js)
  // Replace <api-key> with your Helius API key
  const { Connection } = require('@solana/web3.js');

  async function fetchCurrentLeaderSchedule() {
    const connection = new Connection('https://mainnet.helius-rpc.com/?api-key=<api-key>');
    try {
      const leaderSchedule = await connection.getLeaderSchedule(); // Fetches for current epoch by default
      if (leaderSchedule) {
        console.log('Leader Schedule for Current Epoch:');
        for (const [validatorIdentity, slots] of Object.entries(leaderSchedule)) {
          console.log(`  Validator: ${validatorIdentity}`);
          console.log(`    Slots (relative to epoch start): ${slots.join(', ')}`);
        }
      } else {
        console.log('Leader schedule for the current epoch not found or not yet available.');
      }
      // console.log(JSON.stringify(leaderSchedule, null, 2));
    } catch (error) {
      console.error('Error fetching leader schedule:', error);
    }
  }

  fetchCurrentLeaderSchedule();
  ```
</CodeGroup>

### 2. Get Leader Schedule for a Specific Validator in a Specific Epoch (by Slot)

This example fetches the leader schedule for a given validator identity for the epoch containing slot `200000`.

<CodeGroup>
  ```bash cURL
  # Replace <api-key> with your Helius API key
  # Replace VALIDATOR_PUBKEY with an actual validator identity public key
  curl https://mainnet.helius-rpc.com/?api-key=<api-key> -X POST -H "Content-Type: application/json" -d \
    '{
      "jsonrpc": "2.0",
      "id": 1,
      "method": "getLeaderSchedule",
      "params": [
        200000,
        { "identity": "VALIDATOR_PUBKEY" }
      ]
    }'
  ```

  ```javascript JavaScript (using @solana/web3.js)
  // Replace <api-key> with your Helius API key
  // Replace VALIDATOR_PUBKEY with an actual validator identity public key
  const { Connection, PublicKey } = require('@solana/web3.js');

  async function fetchValidatorEpochSchedule() {
    const connection = new Connection('https://mainnet.helius-rpc.com/?api-key=<api-key>');
    const targetSlot = 200000;
    const validatorIdentity = 'VALIDATOR_PUBKEY'; // e.g., 'Vote111111111111111111111111111111111111111'

    try {
      const leaderSchedule = await connection.getLeaderSchedule(targetSlot, { identity: validatorIdentity });
      if (leaderSchedule && leaderSchedule[validatorIdentity]) {
        console.log(`Leader Schedule for Validator ${validatorIdentity} in epoch of slot ${targetSlot}:`);
        console.log(`  Slots (relative to epoch start): ${leaderSchedule[validatorIdentity].join(', ')}`);
      } else {
        console.log(`No leader slots found for validator ${validatorIdentity} in epoch of slot ${targetSlot}, or schedule not available.`);
      }
      // console.log(JSON.stringify(leaderSchedule, null, 2));
    } catch (error) {
      console.error('Error fetching validator leader schedule:', error);
    }
  }

  fetchValidatorEpochSchedule();
  ```
</CodeGroup>

## Developer Tips

* **Epoch Boundaries:** The leader schedule is fixed for an entire epoch. You can use `getEpochInfo` to find the start and end slots of an epoch.
* **Future Epochs:** Requesting the schedule for an epoch far in the future might return `null` if the network hasn't calculated it yet.
* **Relative Slot Indices:** Remember that the slot numbers in the response are relative to the first slot of the *requested* epoch, not absolute slot numbers on the blockchain.
* **Large Response:** For a full epoch schedule without an identity filter, the response can be large, listing all validators and their assigned slots.

This guide provides the necessary information to use `getLeaderSchedule` to query block producer assignments for any given epoch on the Solana network.


# How to Use getMaxRetransmitSlot
Source: https://www.helius.dev/docs/rpc/guides/getmaxretransmitslot

Learn getMaxRetransmitSlot use cases, code examples, request parameters, response structure, and tips.

The [`getMaxRetransmitSlot`](https://www.helius.dev/docs/api-reference/rpc/http/getmaxretransmitslot) RPC method returns the highest slot number that the queried RPC node has processed or is aware of from its retransmit stage. The retransmit stage is a crucial part of Solana's block propagation protocol, known as [Turbine](https://www.helius.dev/blog/turbine-block-propagation-on-solana), where validators request and receive missing shreds (parts of blocks) from their peers to reconstruct full blocks.

This value can give an indication of how up-to-date a node is with the tip of the network from the perspective of block data propagation and repair.

## Common Use Cases

* **Node Health/Synchronization Check:** Monitor this value to understand if a node is actively receiving and processing information about recent slots. A significantly lagging `maxRetransmitSlot` compared to the cluster's actual highest slot might indicate synchronization issues for that node.
* **Network Analysis (Advanced):** Researchers or sophisticated monitoring tools might use this metric as one of several indicators of overall network health or the speed of block propagation.
* **Debugging Connectivity Issues:** If a node consistently reports a low `maxRetransmitSlot`, it might point to problems with its peer connections or its ability to participate in the retransmit protocol.

## Request Parameters

This method does not take any parameters.

## Response Structure

The `result` field of the JSON-RPC response will be a `u64` (unsigned 64-bit integer) representing the maximum slot number seen by the node from the retransmit stage.

## Examples

### 1. Get the Maximum Retransmit Slot

This example fetches the maximum slot seen from the retransmit stage by the connected node.

<CodeGroup>
  ```bash cURL
  # Replace <api-key> with your Helius API key
  curl https://mainnet.helius-rpc.com/?api-key=<api-key> -X POST -H "Content-Type: application/json" -d \
    '{
      "jsonrpc": "2.0",
      "id": 1,
      "method": "getMaxRetransmitSlot"
    }'
  ```

  ```javascript JavaScript (using @solana/web3.js)
  // Replace <api-key> with your Helius API key
  const { Connection } = require('@solana/web3.js');

  async function fetchMaxRetransmitSlot() {
    const connection = new Connection('https://mainnet.helius-rpc.com/?api-key=<api-key>');
    try {
      const maxRetransmitSlot = await connection.getMaxRetransmitSlot();
      console.log(`Maximum Slot seen from Retransmit Stage: ${maxRetransmitSlot}`);
    } catch (error) {
      console.error('Error fetching maximum retransmit slot:', error);
    }
  }

  fetchMaxRetransmitSlot();
  ```
</CodeGroup>

## Developer Tips

* **Node-Specific Value:** This value is specific to the RPC node you are querying. Different nodes in the cluster might have slightly different values at any given moment due to network latency and their individual view of the retransmit process.
* **Not the Absolute Highest Slot:** This value represents the highest slot the node has *seen data for in retransmit*. It may not be the same as the absolute highest slot confirmed by the cluster (which can be obtained via methods like `getSlot` with `finalized` commitment or `getBlockHeight`). It is more of an indicator of the progress of data propagation to this specific node.
* **Dynamic Value:** This number will continuously increase as the network produces new slots and data is retransmitted.

This guide provides the necessary steps to use the `getMaxRetransmitSlot` RPC method, which can be a useful tool for monitoring the synchronization status and health of a Solana node in relation to block data propagation.


# How to Use getMaxShredInsertSlot
Source: https://www.helius.dev/docs/rpc/guides/getmaxshredinsertslot

Learn getMaxShredInsertSlot use cases, code examples, request parameters, response structure, and tips.

The [`getMaxShredInsertSlot`](https://www.helius.dev/docs/api-reference/rpc/http/getmaxshredinsertslot) RPC method returns the highest slot number for which the queried RPC node has successfully received and processed (inserted) shreds. Shreds are the constituent parts of Solana blocks, propagated via [Turbine](https://www.helius.dev/blog/turbine-block-propagation-on-solana). This value provides insight into how current the node is with the network's block production from the perspective of data ingestion.

Understanding this metric is useful for assessing a node's ability to keep up with the rest of the network.

## Common Use Cases

* **Node Synchronization Status:** Determine how up-to-date a specific node is by comparing its `maxShredInsertSlot` with the cluster's latest slot. A significant lag can indicate that the node is falling behind in processing incoming block data.
* **Performance Monitoring:** Track this value over time to monitor a node's shred processing performance. Consistent or growing discrepancies relative to other nodes or the network tip might signal performance bottlenecks or connectivity problems.
* **Identifying Ingestion Issues:** If a node reports a `maxShredInsertSlot` that isn't advancing or is far behind other nodes, it could point to issues with its shred intake process, potentially related to network connectivity or local processing capacity.

## Request Parameters

This method does not take any parameters.

## Response Structure

The `result` field of the JSON-RPC response will be a `u64` (unsigned 64-bit integer) representing the maximum slot for which the node has inserted shreds.

## Examples

### 1. Get the Maximum Shred Insert Slot

This example fetches the maximum slot for which shreds have been inserted by the connected node.

<CodeGroup>
  ```bash cURL
  # Replace <api-key> with your Helius API key
  curl https://mainnet.helius-rpc.com/?api-key=<api-key> -X POST -H "Content-Type: application/json" -d \
    '{
      "jsonrpc": "2.0",
      "id": 1,
      "method": "getMaxShredInsertSlot"
    }'
  ```

  ```javascript JavaScript (using @solana/web3.js)
  // Replace <api-key> with your Helius API key
  const { Connection } = require('@solana/web3.js');

  async function fetchMaxShredInsertSlot() {
    const connection = new Connection('https://mainnet.helius-rpc.com/?api-key=<api-key>');
    try {
      const maxShredInsertSlot = await connection.getMaxShredInsertSlot();
      console.log(`Maximum Slot for Shred Insertion: ${maxShredInsertSlot}`);
    } catch (error) {
      console.error('Error fetching maximum shred insert slot:', error);
    }
  }

  fetchMaxShredInsertSlot();
  ```
</CodeGroup>

## Developer Tips

* **Node-Specific Value:** The `maxShredInsertSlot` is particular to the RPC node being queried. Different nodes can have varying values at the same moment due to differences in network latency and processing speeds.
* **Indicator of Ingestion, Not Finality:** This slot reflects the progress of shred *ingestion* by the node. It is not a measure of block finality. A slot might have its shreds inserted on one node but not yet be confirmed or finalized by the broader cluster. Use methods like `getSlot` with `finalized` commitment for finality checks.
* **Relationship with `maxRetransmitSlot`:** Typically, `maxShredInsertSlot` will be less than or equal to `maxRetransmitSlot`. A node first sees shreds via retransmit and then processes and inserts them.
* **Constantly Updating:** As the network produces new blocks and the node processes incoming shreds, this value will continuously increase.

By using `getMaxShredInsertSlot`, you can gain valuable insights into a Solana node's progress in receiving and processing block data, which is essential for monitoring its health and synchronization with the network.


# How to Use getMinimumBalanceForRentExemption
Source: https://www.helius.dev/docs/rpc/guides/getminimumbalanceforrentexemption

Learn getMinimumBalanceForRentExemption use cases, code examples, request parameters, response structure, and tips.

The [`getMinimumBalanceForRentExemption`](https://www.helius.dev/docs/api-reference/rpc/http/getminimumbalanceforrentexemption) RPC method allows you to calculate this minimum lamport balance required for an account of a specific data size to become rent-exempt.

In Solana, accounts must maintain a minimum balance to cover storage costs over time, a concept known as rent. Accounts holding a balance equivalent to two years of rent payments are considered "rent-exempt" and do not have their balances depleted by [rent](https://www.helius.dev/blog/solana-executive-overview).

## Common Use Cases

* **Account Creation:** Before creating a new account (e.g., for a new token account, program-derived address, or custom data storage), use this method to determine the necessary lamports to allocate to make it rent-exempt from the start. This prevents the account from being garbage-collected if its balance falls too low.
* **Dynamic Account Sizing:** If your application deals with accounts that can grow in data size, you can use this method to periodically check if additional lamports are needed to maintain rent exemption.
* **Cost Estimation:** Estimate the SOL cost associated with deploying programs or creating data accounts of various sizes.
* **Wallet and SDK Integration:** Wallets and SDKs use this to ensure they fund new accounts appropriately.

## Request Parameters

1. **`dataLength`** (`usize`, required): The length of the account's data in bytes. This is the primary factor determining the rent-exempt minimum.
   * Example: `165` (for a standard SPL Token account).

2. **`commitment`** (`object`, optional): Specifies the [commitment level](https://www.helius.dev/blog/solana-commitment-levels) for the query. If omitted, the default commitment of the RPC node is used.
   * Fields:
     * `commitment` (string): e.g., `"finalized"`, `"confirmed"`, or `"processed"`.

## Response Structure

The `result` field of the JSON-RPC response will be a `u64` (unsigned 64-bit integer) representing the minimum number of lamports required for an account with the specified `dataLength` to be rent-exempt.

## Examples

### 1. Get Rent Exemption for a Standard Token Account (165 bytes)

This example queries the minimum balance needed for a typical SPL Token account (which has a data size of 165 bytes) to be rent-exempt.

<CodeGroup>
  ```bash cURL
  # Replace <api-key> with your Helius API key
  curl https://mainnet.helius-rpc.com/?api-key=<api-key> -X POST -H "Content-Type: application/json" -d \
    '{
      "jsonrpc": "2.0",
      "id": 1,
      "method": "getMinimumBalanceForRentExemption",
      "params": [
        165
      ]
    }'
  ```

  ```javascript JavaScript (using @solana/web3.js)
  // Replace <api-key> with your Helius API key
  const { Connection } = require('@solana/web3.js');

  async function fetchMinimumBalanceForRentExemption() {
    const connection = new Connection('https://mainnet.helius-rpc.com/?api-key=<api-key>');
    const dataLength = 165; // Data length for a typical SPL token account

    try {
      const lamports = await connection.getMinimumBalanceForRentExemption(dataLength);
      console.log(`Minimum lamports for rent exemption (data length ${dataLength} bytes): ${lamports} SOL: (${lamports / 1_000_000_000})`);
    } catch (error) {
      console.error(`Error fetching minimum balance for rent exemption for data length ${dataLength}:`, error);
    }
  }

  fetchMinimumBalanceForRentExemption();
  ```
</CodeGroup>

### 2. Get Rent Exemption for a Zero-Byte Account

This shows the base rent exemption for an account with no data, often the absolute minimum for any account.

<CodeGroup>
  ```bash cURL
  # Replace <api-key> with your Helius API key
  curl https://mainnet.helius-rpc.com/?api-key=<api-key> -X POST -H "Content-Type: application/json" -d \
    '{
      "jsonrpc": "2.0",
      "id": 1,
      "method": "getMinimumBalanceForRentExemption",
      "params": [
        0
      ]
    }'
  ```

  ```javascript JavaScript (using @solana/web3.js)
  // Replace <api-key> with your Helius API key
  const { Connection } = require('@solana/web3.js');

  async function fetchMinimumBalanceForZeroByteAccount() {
    const connection = new Connection('https://mainnet.helius-rpc.com/?api-key=<api-key>');
    const dataLength = 0;

    try {
      const lamports = await connection.getMinimumBalanceForRentExemption(dataLength);
      console.log(`Minimum lamports for rent exemption (data length ${dataLength} bytes): ${lamports} SOL: (${lamports / 1_000_000_000})`);
    } catch (error) {
      console.error(`Error fetching minimum balance for rent exemption for data length ${dataLength}:`, error);
    }
  }

  fetchMinimumBalanceForZeroByteAccount();
  ```
</CodeGroup>

## Developer Tips

* **Rent Varies by Data Size:** The larger the account's data, the higher the rent-exempt minimum will be.
* **Network Parameter:** The underlying cost of rent (lamports per byte-year) is a network parameter that can theoretically change via a cluster vote, though this is rare. The `getMinimumBalanceForRentExemption` method will always return the current value based on the cluster's state.
* **Lamports vs. SOL:** The response is in lamports. Remember that 1 SOL = 1,000,000,000 lamports.
* **Essential for Longevity:** Ensuring accounts are rent-exempt is crucial for the long-term persistence of data on the Solana blockchain.

This guide helps you understand and use the `getMinimumBalanceForRentExemption` RPC method to manage account rent effectively in your Solana applications.


# How to Use getMultipleAccounts
Source: https://www.helius.dev/docs/rpc/guides/getmultipleaccounts

Learn getMultipleAccounts use cases, code examples, request parameters, response structure, and tips.

The [`getMultipleAccounts`](https://www.helius.dev/docs/api-reference/rpc/http/getmultipleaccounts) RPC method is a highly efficient way to fetch information for a list of Solana accounts simultaneously. Instead of making individual `getAccountInfo` requests for each account, `getMultipleAccounts` allows you to batch these requests, reducing network overhead and improving the responsiveness of your application.

## Common Use Cases

* **Batch Loading Account Data:** When your application needs to display or process data from multiple known accounts (e.g., a user's token accounts, a list of on-chain program configurations).
* **Portfolio Trackers:** Fetching balances and states for numerous token accounts owned by a user.
* **Marketplace UIs:** Displaying details of multiple NFTs or listed items by fetching their account data in one go.
* **Improving dApp Performance:** Significantly reducing the number of RPC calls, leading to faster load times and a better user experience, especially when dealing with many accounts.

## Request Parameters

1. **`pubkeys`** (`array` of `string`, required):
   * An array of base-58 encoded public key strings for the accounts you want to query.
   * Maximum of 100 public keys per request.
   * Example: `["So11111111111111111111111111111111111111112", "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"]`

2. **`options`** (`object`, optional): A configuration object containing one or more of the following fields:
   * **`commitment`** (`string`): Specifies the [commitment level](https://www.helius.dev/blog/solana-commitment-levels) for the query (e.g., `"finalized"`, `"confirmed"`, `"processed"`).
   * **`encoding`** (`string`): The encoding for the account data. Options include:
     * `"base64"` (default): Standard base64 encoding.
     * `"base58"`: Slower, but may be useful in some contexts.
     * `"base64+zstd"`: Base64 encoded zstd compressed data.
     * `"jsonParsed"`: If the account is owned by a program for which the RPC node has a parser (e.g., SPL Token Program, Stake Program), the `data` field will be a JSON object. This is very useful for structured data.
   * **`dataSlice`** (`object`): Allows you to fetch only a specific portion of the account data. This is useful for large accounts where you only need a small piece of information.
     * `offset` (`usize`): The offset in bytes from the start of the account data.
     * `length` (`usize`): The number of bytes to return from the offset.
     * *Note: `dataSlice` is only available for `base58`, `base64`, or `base64+zstd` encodings.*
   * **`minContextSlot`** (`u64`): The minimum slot that the request can be evaluated at.

## Response Structure

The JSON-RPC response object will have a `result` field containing:

* **`context`** (`object`):
  * `slot` (`u64`): The slot at which the information was retrieved.
  * `apiVersion` (`string`, optional): The API version of the node.
* **`value`** (`array`):
  * An array where each element corresponds to the public key at the same index in the request's `pubkeys` array.
  * Each element will either be:
    * `null`: If the account at the specified public key does not exist or an error occurred for that specific account.
    * An **Account Object** with the following fields:
      * `lamports` (`u64`): The number of lamports owned by the account.
      * `owner` (`string`): The base-58 encoded public key of the program that owns the account.
      * `data` (`array` or `object`): The account data. If `encoding` is `jsonParsed` and a parser exists, this will be a JSON object. Otherwise, it's typically an array `["encoded_string", "encoding_format"]` (e.g., `["SGVsbG8=", "base64"]`).
      * `executable` (`boolean`): Whether the account contains a program (is executable).
      * `rentEpoch` (`u64`): The next epoch at which this account will owe rent.
      * `space` (`u64`): The data length of the account in bytes.

## Examples

### 1. Fetch Basic Info for Two Accounts

This example fetches data for two accounts: the SOL Llama (an NFT) and the Serum Dex Program v3.

<CodeGroup>
  ```bash cURL
  # Replace <api-key> with your Helius API key
  # SOL Llama Mint: Abug4qgG1x23AEdjS2h9CEJ1m6ha2Z22LdK2kL2pys3F
  # Serum Dex Program v3: 9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin
  curl https://mainnet.helius-rpc.com/?api-key=<api-key> -X POST -H "Content-Type: application/json" -d \
    '{
      "jsonrpc": "2.0",
      "id": 1,
      "method": "getMultipleAccounts",
      "params": [
        [
          "Abug4qgG1x23AEdjS2h9CEJ1m6ha2Z22LdK2kL2pys3F",
          "9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin"
        ]
      ]
    }'
  ```

  ```javascript JavaScript (using @solana/web3.js)
  // Replace <api-key> with your Helius API key
  const { Connection, PublicKey } = require('@solana/web3.js');

  async function fetchMultipleAccountInfo() {
    const connection = new Connection('https://mainnet.helius-rpc.com/?api-key=<api-key>');
    const accountPubkeys = [
      new PublicKey('Abug4qgG1x23AEdjS2h9CEJ1m6ha2Z22LdK2kL2pys3F'), // SOL Llama
      new PublicKey('9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin')  // Serum Dex Program v3
    ];

    try {
      const accountsInfo = await connection.getMultipleAccountsInfo(accountPubkeys);
      
      accountsInfo.forEach((account, index) => {
        console.log(`--- Account ${index + 1} (${accountPubkeys[index].toBase58()}) ---`);
        if (account) {
          console.log(`  Owner: ${account.owner.toBase58()}`);
          console.log(`  Lamports: ${account.lamports}`);
          console.log(`  Executable: ${account.executable}`);
          console.log(`  Data length: ${account.data.length}`);
          // For brevity, not logging full data buffer
        } else {
          console.log("  Account not found or error fetching.");
        }
      });
    } catch (error) {
      console.error('Error fetching multiple accounts:', error);
    }
  }

  fetchMultipleAccountInfo();
  ```
</CodeGroup>

### 2. Fetch Parsed Token Account Data

This example fetches data for two SPL Token accounts and requests `jsonParsed` encoding to get structured data.

<CodeGroup>
  ```bash cURL
  # Replace <api-key> with your Helius API key
  # Example USDC Token Account 1: GqoZ2MCrdTtygoX1F2b8X7F2tDXxNxyvMvykR9RzQW8p
  # Example USDT Token Account 2: HYnLMbkaPMh9W2aPNy2yP4LzLSWWw9zSCYEZdX2g2E7m
  curl https://mainnet.helius-rpc.com/?api-key=<api-key> -X POST -H "Content-Type: application/json" -d \
    '{
      "jsonrpc": "2.0",
      "id": 1,
      "method": "getMultipleAccounts",
      "params": [
        [
          "GqoZ2MCrdTtygoX1F2b8X7F2tDXxNxyvMvykR9RzQW8p",
          "HYnLMbkaPMh9W2aPNy2yP4LzLSWWw9zSCYEZdX2g2E7m"
        ],
        {
          "encoding": "jsonParsed"
        }
      ]
    }'
  ```

  ```javascript JavaScript (using @solana/web3.js)
  // Replace <api-key> with your Helius API key
  const { Connection, PublicKey } = require('@solana/web3.js');

  async function fetchParsedTokenAccounts() {
    const connection = new Connection('https://mainnet.helius-rpc.com/?api-key=<api-key>');
    const tokenAccountPubkeys = [
      new PublicKey('GqoZ2MCrdTtygoX1F2b8X7F2tDXxNxyvMvykR9RzQW8p'), // Example USDC account
      new PublicKey('HYnLMbkaPMh9W2aPNy2yP4LzLSWWw9zSCYEZdX2g2E7m')  // Example USDT account
    ];

    try {
      const accountsInfo = await connection.getMultipleAccountsInfo(tokenAccountPubkeys, 'confirmed'); // Can also pass commitment here
      // Note: @solana/web3.js's getMultipleAccountsInfo automatically requests jsonParsed if the node supports it for token accounts.
      // For explicit control with raw RPC, you use the options object as in the cURL example.

      accountsInfo.forEach((account, index) => {
        console.log(`--- Token Account ${index + 1} (${tokenAccountPubkeys[index].toBase58()}) ---`);
        if (account && account.data && typeof account.data !== 'string') { // Check if data is parsed
          // The actual structure of account.data depends on the program (e.g., SPL Token)
          // For SPL Token accounts, you'd typically find parsed data in account.data.parsed.info
          const parsedInfo = (account.data as any).parsed?.info;
          if (parsedInfo) {
              console.log(`  Mint: ${parsedInfo.mint}`);
              console.log(`  Owner: ${parsedInfo.owner}`);
              console.log(`  Amount: ${parsedInfo.tokenAmount.uiAmountString} (decimals: ${parsedInfo.tokenAmount.decimals})`);
          } else {
              console.log("  Account data is not in the expected parsed format or is not a token account.");
              // console.log("Raw data:", account.data.toString('base64')); // if buffer
          }
        } else if (account) {
          console.log("  Account found, but data is not parsed or is a string (binary data).");
          // console.log("  Raw data:", account.data.toString()); // if string
        } else {
          console.log("  Account not found or error fetching.");
        }
      });
    } catch (error) {
      console.error('Error fetching parsed token accounts:', error);
    }
  }

  fetchParsedTokenAccounts();
  ```
</CodeGroup>

## Developer Tips

* **Maximum 100 Accounts:** You can request a maximum of 100 accounts per call.
* **Atomicity:** The request is not atomic in the sense that if one account lookup fails, others might still succeed. Check each element in the `value` array for `null`.
* **`jsonParsed` Convenience:** Using `jsonParsed` encoding is highly recommended when dealing with common account types like SPL Token accounts, as it saves you from manual deserialization.
* **`dataSlice` for Large Accounts:** For very large accounts (e.g., some program state accounts), use `dataSlice` to fetch only the necessary bytes to avoid excessive data transfer.
* **Error Handling:** Be prepared to handle `null` entries in the response `value` array, indicating that an account was not found or could not be fetched.

By leveraging `getMultipleAccounts`, you can build more performant and scalable Solana applications.


# How to Use getProgramAccounts
Source: https://www.helius.dev/docs/rpc/guides/getprogramaccounts

Learn getProgramAccounts use cases, code examples, request parameters, response structure, and tips.

The [`getProgramAccounts`](https://www.helius.dev/docs/api-reference/rpc/http/getprogramaccounts) RPC method is a powerful tool for querying the Solana blockchain. It allows you to retrieve all accounts that are owned by a specific on-chain program. This is essential for a wide range of applications, from finding all token accounts associated with a user for a particular token mint, to discovering all user-specific data accounts for a decentralized application. Helius provides documentation on [how to use getProgramAccounts efficiently](https://www.helius.dev/docs/rpc/http/get-program-accounts) and has also [announced performance improvements for this call](https://www.helius.dev/blog/faster-getprogramaccounts).

Due to the potentially large number of accounts a program might own, `getProgramAccounts` provides robust filtering capabilities to help you narrow down your search and retrieve only the data you need efficiently.

## Common Use Cases

* **Finding All Token Accounts for a Mint:** Discover all holders of a specific SPL token.
* **Retrieving User-Specific Data:** Fetch all accounts created by a program for a particular user (e.g., a user's positions in a DeFi protocol, their game state in a Play-to-Earn game).
* **Listing All Instances of a Custom Account Type:** If your program defines a specific account structure, `getProgramAccounts` can find all instances of that structure.
* **Monitoring Program State:** Observing all accounts related to a program to track its overall state or activity.
* **Building Explorers and Analytics Tools:** Aggregating data about programs and their associated accounts.

## Request Parameters

1. **`programId`** (`string`, required):
   * The base-58 encoded public key of the program whose accounts you want to fetch.
   * Example: `"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"` (for the SPL Token Program).

2. **`options`** (`object`, optional): A configuration object with the following fields:
   * **`commitment`** (`string`): Specifies the [commitment level](https://www.helius.dev/blog/solana-commitment-levels) (e.g., `"finalized"`, `"confirmed"`).
   * **`encoding`** (`string`): Encoding for the `data` field within each returned account. Defaults to `"base64"`.
     * `"base58"`: Slower alternative for binary data.
     * `"base64"`: Standard base64 encoding for binary data.
     * `"base64+zstd"`: Base64 encoded, zstd-compressed binary data.
     * `"jsonParsed"`: If the RPC node has a parser for the program's account type (e.g., SPL Token, Stake), the `data` field will be a structured JSON object. This is highly recommended for readability and ease of use.
   * **`filters`** (`array`): An array of filter objects to apply to the accounts. This is crucial for performance and relevance. You can use up to 4 filters. Common filters include:
     * **`dataSize`** (`object`):
       * `dataSize` (`u64`): Filters accounts by their data length in bytes. Example: `{ "dataSize": 165 }` (for SPL Token accounts).
     * **`memcmp`** (`object`): Memory comparison. Compares a slice of the account's data with the provided bytes.
       * `offset` (`usize`): The byte offset into the account data at which to start the comparison.
       * `bytes` (`string`): A base-58 encoded string of the bytes to match. The byte string must be less than 129 bytes.
       * Example: To find token accounts for a specific mint, you'd use `memcmp` with `offset: 0` (where the mint address is stored in a token account) and `bytes` set to the mint's public key.
   * **`dataSlice`** (`object`): Returns only a specific slice of each account's data. Useful for large accounts when you only need partial data.
     * `offset` (`usize`): The byte offset from which to start slicing.
     * `length` (`usize`): The number of bytes to return.
     * *Note: `dataSlice` is primarily for binary encodings, not `jsonParsed`.*
   * **`withContext`** (`boolean`): If `true`, the response will be an `RpcResponse` object containing a `context` (with `slot`) and the `value` (the array of accounts). If `false` or omitted, it typically returns just the array of accounts. Behavior can vary slightly by RPC provider.
   * **`minContextSlot`** (`u64`): The minimum slot that the request can be evaluated at.

## Response Structure

The response is an array of objects, where each object represents an account found and includes:

* **`pubkey`** (`string`): The base-58 encoded public key of the account.
* **`account`** (`object`):
  * `lamports` (`u64`): Balance of the account in lamports.
  * `owner` (`string`): Base-58 encoded public key of the program that owns this account (this will be the `programId` you queried by).
  * `data` (`string`, `array`, or `object`): The account's data, formatted according to the `encoding` parameter.
    * For `jsonParsed`: A JSON object representing the deserialized account state.
    * For `base64`: An array `["encoded_string", "base64"]`.
  * `executable` (`boolean`): Whether the account is executable (i.e., a program itself).
  * `rentEpoch` (`u64`): The epoch at which this account will next owe rent.
  * `space` (`u64`, optional): The data length of the account in bytes. Sometimes referred to as `data.length` if data is a buffer, or part of the parsed structure.

If `withContext: true` is used, this array will be nested under the `value` field of an `RpcResponse` object.

## Examples

### 1. Find All Token Accounts for a Specific Mint (USDC)

This example finds all SPL Token accounts that hold USDC. It uses `dataSize` to filter for token accounts (165 bytes) and `memcmp` to match the USDC mint address at offset 0.

<CodeGroup>
  ```bash cURL
  # Replace <api-key> with your Helius API key
  # USDC Mint: EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v
  # Token Program ID: TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA
  curl https://mainnet.helius-rpc.com/?api-key=<api-key> -X POST -H "Content-Type: application/json" -d \
    '{
      "jsonrpc": "2.0",
      "id": 1,
      "method": "getProgramAccounts",
      "params": [
        "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA",
        {
          "encoding": "jsonParsed",
          "filters": [
            { "dataSize": 165 },
            {
              "memcmp": {
                "offset": 0, 
                "bytes": "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"
              }
            }
          ]
        }
      ]
    }'
  ```

  ```javascript JavaScript (using @solana/web3.js)
  // Replace <api-key> with your Helius API key
  const { Connection, PublicKey } = require('@solana/web3.js');
  const { TOKEN_PROGRAM_ID } = require('@solana/spl-token');

  const USDC_MINT_ADDRESS = 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v';

  async function findUsdcTokenAccounts() {
    const connection = new Connection('https://mainnet.helius-rpc.com/?api-key=<api-key>');

    try {
      const accounts = await connection.getProgramAccounts(TOKEN_PROGRAM_ID, {
        encoding: 'jsonParsed',
        filters: [
          {
            dataSize: 165, // Standard token account size
          },
          {
            memcmp: {
              offset: 0, // Offset for the mint address in a token account
              bytes: USDC_MINT_ADDRESS, // Base-58 encoded mint address
            },
          },
        ],
      });

      console.log(`Found ${accounts.length} USDC token accounts.`);
      accounts.forEach((accountInfo, index) => {
        console.log(`--- Account ${index + 1} ---`);
        console.log(`  Pubkey: ${accountInfo.pubkey.toBase58()}`);
        // Accessing parsed data
        const parsedData = accountInfo.account.data.parsed.info;
        console.log(`  Owner: ${parsedData.owner}`);
        console.log(`  Amount: ${parsedData.tokenAmount.uiAmountString}`);
      });
    } catch (error) {
      console.error('Error fetching USDC token accounts:', error);
    }
  }

  findUsdcTokenAccounts();
  ```
</CodeGroup>

### 2. Find All Token Accounts Owned by a Specific Wallet

This example finds all SPL Token accounts owned by a specific wallet address. It uses `dataSize` (165 bytes) and `memcmp` at offset 32 (where the owner pubkey is stored in a token account).

<CodeGroup>
  ```bash cURL
  # Replace <api-key> with your Helius API key
  # Example Wallet Address: Helioo21241PANoNdeG55722hgUnp2VawDgsz2g
  # Token Program ID: TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA
  curl https://mainnet.helius-rpc.com/?api-key=<api-key> -X POST -H "Content-Type: application/json" -d \
    '{
      "jsonrpc": "2.0",
      "id": 1,
      "method": "getProgramAccounts",
      "params": [
        "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA",
        {
          "encoding": "jsonParsed",
          "filters": [
            { "dataSize": 165 },
            {
              "memcmp": {
                "offset": 32, 
                "bytes": "Helioo21241PANoNdeG55722hgUnp2VawDgsz2g"
              }
            }
          ]
        }
      ]
    }'
  ```

  ```javascript JavaScript (using @solana/web3.js)
  // Replace <api-key> with your Helius API key
  const { Connection, PublicKey } = require('@solana/web3.js');
  const { TOKEN_PROGRAM_ID } = require('@solana/spl-token');

  const TARGET_WALLET_ADDRESS = 'Helioo21241PANoNdeG55722hgUnp2VawDgsz2g';

  async function findWalletTokenAccounts() {
    const connection = new Connection('https://mainnet.helius-rpc.com/?api-key=<api-key>');

    try {
      const accounts = await connection.getProgramAccounts(TOKEN_PROGRAM_ID, {
        encoding: 'jsonParsed',
        filters: [
          {
            dataSize: 165, // Standard token account size
          },
          {
            memcmp: {
              offset: 32, // Offset for the owner address in a token account
              bytes: TARGET_WALLET_ADDRESS, // Base-58 encoded wallet address
            },
          },
        ],
      });

      console.log(`Found ${accounts.length} token accounts for wallet ${TARGET_WALLET_ADDRESS}.`);
      accounts.forEach((accountInfo, index) => {
        console.log(`--- Account ${index + 1} (${accountInfo.pubkey.toBase58()}) ---`);
        const parsedData = accountInfo.account.data.parsed.info;
        console.log(`  Mint: ${parsedData.mint}`);
        console.log(`  Amount: ${parsedData.tokenAmount.uiAmountString}`);
      });
    } catch (error) {
      console.error('Error fetching token accounts for wallet:', error);
    }
  }

  findWalletTokenAccounts();
  ```
</CodeGroup>

## Developer Tips

* **Performance:** `getProgramAccounts` can be resource-intensive on RPC nodes, especially without filters or for programs with many accounts. Always use filters (`dataSize`, `memcmp`) and `dataSlice` where possible to reduce the query scope and response size.
* **No Pagination:** This method does not currently support pagination. If a query returns too many results, the response might be truncated or the request might time out. Design your queries carefully.
* **Rate Limits:** Be mindful of RPC provider rate limits, as frequent or heavy `getProgramAccounts` calls can hit these limits.
* **Data Layout Knowledge:** Effective use of `memcmp` requires understanding the byte layout of the account data you are querying.
* **`jsonParsed` Availability:** The `jsonParsed` encoding depends on the RPC node having a parser for the specific program's account types. It's widely supported for common programs like SPL Token.

`getProgramAccounts` is an indispensable method for developers needing to query and interact with sets of accounts owned by a program. Mastering its filtering options is key to building efficient and robust Solana applications.


# How to Use getRecentPerformanceSamples
Source: https://www.helius.dev/docs/rpc/guides/getrecentperformancesamples

Learn getRecentPerformanceSamples use cases, code examples, request parameters, response structure, and tips.

The [`getRecentPerformanceSamples`](https://www.helius.dev/docs/api-reference/rpc/http/getrecentperformancesamples) RPC method provides a snapshot of the Solana network's recent performance. It returns a list of samples, taken approximately every 60 seconds, detailing the number of transactions and slots processed within those periods. This data is invaluable for monitoring network throughput and health. For more context on Solana's performance metrics like TPS and slot times, you can read the [Solana for Enterprise guide](https://www.helius.dev/blog/evaluating-solana-for-enterprise-use-a-comprehensive-guide).

## Common Use Cases

* **Network Health Monitoring:** Track transaction processing rates and slot production to assess overall network health and identify potential congestion or slowdowns.
* **Performance Analysis:** Analyze historical performance data to understand network behavior under different conditions.
* **Dashboarding:** Display key performance indicators (KPIs) like transactions per second (TPS) and slots per minute on monitoring dashboards.
* **Capacity Planning:** Observe trends in network load to inform scaling decisions for applications or infrastructure.

## Request Parameters

1. **`limit`** (`usize`, optional):
   * The number of most recent performance samples to return.
   * Maximum value: `720` (representing approximately 12 hours of data, as samples are taken every 60 seconds).
   * If omitted, the RPC node will return a default number of samples (the exact default can vary by RPC provider).

## Response Structure

The `result` field of the JSON-RPC response is an array of performance sample objects, returned in reverse chronological order (most recent sample first). Each object has the following structure:

* **`slot`** (`u64`): The slot number in which this performance sample was recorded.
* **`numTransactions`** (`u64`): The total number of transactions (including vote and non-vote transactions) processed during the `samplePeriodSecs` leading up to this `slot`.
* **`numSlots`** (`u64`): The number of slots that were processed during the `samplePeriodSecs` leading up to this `slot`.
* **`samplePeriodSecs`** (`u16`): The duration, in seconds, over which this sample was taken (typically `60`).
* **`numNonVoteTransactions`** (`u64`): The number of transactions that were not consensus vote transactions, processed during the `samplePeriodSecs`.

## Examples

### 1. Get the Last 5 Performance Samples

This example requests the five most recent performance samples from the network.

<CodeGroup>
  ```bash cURL
  # Replace <api-key> with your Helius API key
  curl https://mainnet.helius-rpc.com/?api-key=<api-key> -X POST -H "Content-Type: application/json" -d \
    '{
      "jsonrpc": "2.0",
      "id": 1,
      "method": "getRecentPerformanceSamples",
      "params": [5]
    }'
  ```

  ```javascript JavaScript (using @solana/web3.js)
  // Replace <api-key> with your Helius API key
  const { Connection } = require('@solana/web3.js');

  async function fetchRecentPerformance() {
    const connection = new Connection('https://mainnet.helius-rpc.com/?api-key=<api-key>');
    try {
      const samples = await connection.getRecentPerformanceSamples(5);
      if (samples && samples.length > 0) {
        console.log(`Fetched ${samples.length} performance samples:`);
        samples.forEach((sample, index) => {
          console.log(`--- Sample ${index + 1} ---`);
          console.log(`  Slot: ${sample.slot}`);
          console.log(`  Number of Slots in Period: ${sample.numSlots}`);
          console.log(`  Total Transactions: ${sample.numTransactions}`);
          console.log(`  Non-Vote Transactions: ${sample.numNonVoteTransactions}`);
          console.log(`  Sample Period (seconds): ${sample.samplePeriodSecs}`);
          const tps = sample.numTransactions / sample.samplePeriodSecs;
          const nonVoteTps = sample.numNonVoteTransactions / sample.samplePeriodSecs;
          console.log(`  Average TPS (Total): ${tps.toFixed(2)}`);
          console.log(`  Average TPS (Non-Vote): ${nonVoteTps.toFixed(2)}`);
        });
      } else {
        console.log('No performance samples returned.');
      }
    } catch (error) {
      console.error('Error fetching recent performance samples:', error);
    }
  }

  fetchRecentPerformance();
  ```
</CodeGroup>

### 2. Get Default Number of Performance Samples

This example omits the `limit` parameter, requesting the RPC node's default number of samples.

<CodeGroup>
  ```bash cURL
  # Replace <api-key> with your Helius API key
  curl https://mainnet.helius-rpc.com/?api-key=<api-key> -X POST -H "Content-Type: application/json" -d \
    '{
      "jsonrpc": "2.0",
      "id": 1,
      "method": "getRecentPerformanceSamples"
    }'
  ```

  ```javascript JavaScript (using @solana/web3.js)
  // Replace <api-key> with your Helius API key
  const { Connection } = require('@solana/web3.js');

  async function fetchDefaultPerformanceSamples() {
    const connection = new Connection('https://mainnet.helius-rpc.com/?api-key=<api-key>');
    try {
      const samples = await connection.getRecentPerformanceSamples(); // No limit parameter
      if (samples && samples.length > 0) {
        console.log(`Fetched ${samples.length} (default) performance samples:`);
        // Process or log samples as needed - e.g., the first one
        const sample = samples[0];
        console.log(`--- Most Recent Sample ---`);
        console.log(`  Slot: ${sample.slot}`);
        console.log(`  Total Transactions: ${sample.numTransactions}`);
        console.log(`  Non-Vote Transactions: ${sample.numNonVoteTransactions}`);
        console.log(`  Slots in Period: ${sample.numSlots}`);
        console.log(`  Sample Period (seconds): ${sample.samplePeriodSecs}`);
      } else {
        console.log('No performance samples returned.');
      }
    } catch (error) {
      console.error('Error fetching default performance samples:', error);
    }
  }

  fetchDefaultPerformanceSamples();
  ```
</CodeGroup>

## Developer Tips

* **Sampling Interval:** Samples are typically taken every 60 seconds, but this is an approximation. The `samplePeriodSecs` field in the response indicates the actual duration for each sample.
* **Historical Data Limit:** The maximum `limit` of 720 samples provides a window of approximately 12 hours of historical data. For longer-term performance analysis, external data logging and aggregation are necessary.
* **Vote vs. Non-Vote Transactions:** `numTransactions` includes all transactions, while `numNonVoteTransactions` specifically counts those that are not part of the consensus voting process. The latter is often a better indicator of user-driven network activity.
* **Node Variability:** The exact data might vary slightly between different RPC nodes depending on their synchronization state and local view of the network when a sample is taken.

By utilizing `getRecentPerformanceSamples`, developers and network observers can gain valuable insights into the operational status and throughput of the Solana network.


# How to Use getRecentPrioritizationFees
Source: https://www.helius.dev/docs/rpc/guides/getrecentprioritizationfees

Learn getRecentPrioritizationFees use cases, code examples, request parameters, response structure, and tips.

The [`getRecentPrioritizationFees`](https://www.helius.dev/docs/api-reference/rpc/http/getrecentprioritizationfees) RPC method provides insights into the prioritization fees paid in recent blocks on the Solana network. By examining these fees, developers can make more informed decisions about the additional fee ([priority fee](https://www.helius.dev/blog/priority-fees-understanding-solanas-transaction-fee-mechanics)) to attach to their transactions to increase their likelihood of being processed promptly, especially during periods of high network activity.

Nodes typically cache prioritization fee data for up to 150 recent blocks.

## Common Use Cases

* **Dynamic Fee Estimation:** Determine a competitive priority fee for a transaction by observing what fees have been successful recently.
* **Congestion Analysis:** Understand the current state of network congestion by looking at the level of priority fees being paid.
* **Wallet Integration:** Allow wallets to suggest appropriate priority fees to users based on recent network conditions.
* **Arbitrage Bots:** For time-sensitive operations like arbitrage, setting an optimal priority fee is crucial for timely execution.

## Request Parameters

1. **`lockedWritableAccounts`** (`array` of `string`, optional):
   * An array of base-58 encoded public keys of accounts that your transaction intends to write-lock.
   * Maximum of 128 addresses can be provided.
   * If provided, the method returns prioritization fees paid by transactions that locked **all** of the specified accounts as writable.
   * If omitted or an empty array is passed, the method returns a more general view of prioritization fees observed across recent blocks, not specific to any particular set of accounts.

## Response Structure

The `result` field of the JSON-RPC response is an array of prioritization fee objects. Each object details fees from a specific recent slot and has the following structure:

* **`slot`** (`u64`): The slot number in which the transactions contributing to this fee data were processed.
* **`prioritizationFee`** (`u64`): The minimum prioritization fee (in micro-Lamports per Compute Unit) paid by at least one transaction in this slot (and matching the `lockedWritableAccounts` filter, if any). A value of `0` often means that no transactions in that slot (matching the criteria) paid an additional priority fee beyond the base fee, or the node did not observe any for the given accounts.

## Examples

### 1. Get Recent Global Prioritization Fees

This example fetches a general list of recent prioritization fees without specifying any locked accounts.

<CodeGroup>
  ```bash cURL
  # Replace <api-key> with your Helius API key
  curl https://mainnet.helius-rpc.com/?api-key=<api-key> -X POST -H "Content-Type: application/json" -d \
    '{
      "jsonrpc": "2.0",
      "id": 1,
      "method": "getRecentPrioritizationFees",
      "params": [[]] # Empty array for global fees
    }'
  ```

  ```javascript JavaScript (using @solana/web3.js)
  // Replace <api-key> with your Helius API key
  const { Connection } = require('@solana/web3.js');

  async function fetchGlobalPrioritizationFees() {
    const connection = new Connection('https://mainnet.helius-rpc.com/?api-key=<api-key>');
    try {
      // Pass an empty array or omit the parameter for global fees
      const fees = await connection.getRecentPrioritizationFees([]); 
      if (fees && fees.length > 0) {
        console.log(`Fetched ${fees.length} recent prioritization fee samples (global):`);
        fees.forEach((feeInfo, index) => {
          console.log(`--- Sample ${index + 1} ---`);
          console.log(`  Slot: ${feeInfo.slot}`);
          console.log(`  Prioritization Fee (micro-lamports/CU): ${feeInfo.prioritizationFee}`);
        });
        // Example: Calculate the median of non-zero fees
        const nonZeroFees = fees.filter(f => f.prioritizationFee > 0).map(f => f.prioritizationFee).sort((a,b) => a - b);
        if (nonZeroFees.length > 0) {
          const mid = Math.floor(nonZeroFees.length / 2);
          const medianFee = nonZeroFees.length % 2 !== 0 ? nonZeroFees[mid] : (nonZeroFees[mid - 1] + nonZeroFees[mid]) / 2;
          console.log(`\nMedian non-zero priority fee: ${medianFee} micro-lamports/CU`);
        }
      } else {
        console.log('No recent prioritization fee data returned.');
      }
    } catch (error) {
      console.error('Error fetching global prioritization fees:', error);
    }
  }

  fetchGlobalPrioritizationFees();
  ```
</CodeGroup>

### 2. Get Recent Prioritization Fees for Specific Writable Accounts

This example fetches prioritization fees relevant for a transaction that needs to write-lock two specific accounts.

<CodeGroup>
  ```bash cURL
  # Replace <api-key> with your Helius API key
  # Replace with actual public keys you are interested in
  curl https://mainnet.helius-rpc.com/?api-key=<api-key> -X POST -H "Content-Type: application/json" -d \
    '{
      "jsonrpc": "2.0",
      "id": 1,
      "method": "getRecentPrioritizationFees",
      "params": [[
        "Vote111111111111111111111111111111111111111", 
        "Stake11111111111111111111111111111111111111"
      ]]
    }'
  ```

  ```javascript JavaScript (using @solana/web3.js)
  // Replace <api-key> with your Helius API key
  const { Connection, PublicKey } = require('@solana/web3.js');

  async function fetchPrioritizationFeesForAccounts() {
    const connection = new Connection('https://mainnet.helius-rpc.com/?api-key=<api-key>');
    
    // Replace with actual public keys your transaction will lock
    const accountsToLock = [
      new PublicKey('Vote111111111111111111111111111111111111111'),
      new PublicKey('Stake11111111111111111111111111111111111111')
    ];

    try {
      const fees = await connection.getRecentPrioritizationFees(accountsToLock.map(pk => pk.toBase58()));
      if (fees && fees.length > 0) {
        console.log(`Fetched ${fees.length} recent prioritization fee samples for specified accounts:`);
        fees.forEach((feeInfo, index) => {
          console.log(`--- Sample ${index + 1} ---`);
          console.log(`  Slot: ${feeInfo.slot}`);
          console.log(`  Prioritization Fee (micro-lamports/CU): ${feeInfo.prioritizationFee}`);
        });
      } else {
        console.log('No recent prioritization fee data returned for the specified accounts.');
      }
    } catch (error) {
      console.error('Error fetching prioritization fees for accounts:', error);
    }
  }

  fetchPrioritizationFeesForAccounts();
  ```
</CodeGroup>

## Developer Tips

* **Fee Units:** Prioritization fees are expressed in micro-Lamports (0.000001 Lamports) per Compute Unit (CU).
* **Cache Window:** RPC nodes typically cache these fees for about 150 blocks. This means you are looking at a relatively short historical window (roughly 1-2 minutes).
* **Zero Fees:** A `prioritizationFee` of `0` doesn't necessarily mean no fees were paid, but rather that for the given slot and account(s), the sampled transactions did not include a priority fee, or were below a threshold the node considers significant.
* **Strategic Use:** Don't just pick the highest recent fee. Analyze the distribution (e.g., median, 75th percentile of non-zero fees) to make a cost-effective choice. Overpaying doesn't guarantee faster inclusion beyond a certain point if the block is already full of high-priority transactions.
* **Compute Units:** The total priority fee for your transaction will be `prioritizationFee_per_CU * your_transaction_compute_units`. You also need to set the compute unit limit for your transaction (`ComputeBudgetProgram.setComputeUnitLimit`) and the price (`ComputeBudgetProgram.setComputeUnitPrice`).

Using `getRecentPrioritizationFees` effectively can significantly improve transaction confirmation reliability in dynamic network conditions.


# How to Use getSignaturesForAddress
Source: https://www.helius.dev/docs/rpc/guides/getsignaturesforaddress

Learn getSignaturesForAddress use cases, code examples, request parameters, response structure, and tips.

The [`getSignaturesForAddress`](https://www.helius.dev/docs/api-reference/rpc/http/getsignaturesforaddress) RPC method allows you to retrieve a list of confirmed transaction signatures that involve a specific account address. This is useful for fetching the transaction history of an account. Signatures are returned in reverse chronological order (newest first).

## Common Use Cases

* **Account Transaction History:** Displaying the past transactions for a user's wallet. For more advanced parsing of transaction history, consider using Helius's [Enhanced Transactions API](https://www.helius.dev/docs/enhanced-transactions).
* **Activity Auditing:** Reviewing all transactions associated with a particular smart contract or account.
* **Specific Transaction Lookup:** Finding a specific transaction by iterating through an account's history if only the involved address is known.
* **Data Indexing:** Building a localized index of transactions for faster querying and analysis.

## Request Parameters

1. **`address`** (`string`): (Required) The base-58 encoded public key of the account for which to retrieve transaction signatures.
2. **`options`** (`object`, optional): An optional configuration object with the following fields:
   * **`limit`** (`number`, optional): The maximum number of signatures to return. The default is 1000, and the maximum allowed is 1000.
   * **`before`** (`string`, optional): A base-58 encoded transaction signature. If provided, the query will start searching for transactions before this signature.
   * **`until`** (`string`, optional): A base-58 encoded transaction signature. If provided, the query will search for transactions until this signature is reached (exclusive).
   * **`commitment`** (`string`, optional): Specifies the [commitment level](https://www.helius.dev/blog/solana-commitment-levels) to use for the query. Supported values are `finalized`, `confirmed`, or `processed`. If omitted, the default commitment of the RPC node is used (usually `finalized`).
   * **`minContextSlot`** (`number`, optional): The minimum slot that the request can be evaluated at. This is not a filter on historical transactions but sets the minimum slot for the node's context.

## Response Structure

The `result` field of the JSON-RPC response is an array of signature information objects. Each object has the following structure:

* **`signature`** (`string`): The base-58 encoded transaction signature.
* **`slot`** (`u64`): The slot in which the transaction was processed.
* **`err`** (`object` | `null`): An error object if the transaction failed, or `null` if it succeeded.
* **`memo`** (`string` | `null`): The memo associated with the transaction, if any.
* **`blockTime`** (`i64` | `null`): The estimated production time of the block containing the transaction, as a Unix timestamp (seconds since epoch). `null` if not available.
* **`confirmationStatus`** (`string` | `null`): The confirmation status of the transaction (e.g., `processed`, `confirmed`, `finalized`). `null` if not available (e.g., for older Helius responses).

## Examples

### 1. Get the Latest Signatures for an Address

This example fetches the most recent (up to 1000) transaction signatures for a given address.

<CodeGroup>
  ```bash cURL
  # Replace <api-key> with your Helius API key
  # Replace SYSTEM_PROGRAM_ID with the address you want to query
  curl https://mainnet.helius-rpc.com/?api-key=<api-key> -X POST -H "Content-Type: application/json" -d \
    '{
      "jsonrpc": "2.0",
      "id": 1,
      "method": "getSignaturesForAddress",
      "params": [
        "11111111111111111111111111111111" 
      ]
    }'
  ```

  ```javascript JavaScript (using @solana/web3.js)
  // Replace <api-key> with your Helius API key
  const { Connection, PublicKey } = require('@solana/web3.js');

  async function getLatestSignatures() {
    const connection = new Connection('https://mainnet.helius-rpc.com/?api-key=<api-key>');
    // Replace with the public key you want to query
    const address = new PublicKey('11111111111111111111111111111111'); 

    try {
      const signatures = await connection.getSignaturesForAddress(address);
      if (signatures && signatures.length > 0) {
        console.log(`Found ${signatures.length} signatures:`);
        signatures.forEach((sigInfo, index) => {
          console.log(`--- Signature ${index + 1} ---`);
          console.log(`  Signature: ${sigInfo.signature}`);
          console.log(`  Slot: ${sigInfo.slot}`);
          console.log(`  Block Time: ${sigInfo.blockTime ? new Date(sigInfo.blockTime * 1000).toLocaleString() : 'N/A'}`);
          console.log(`  Error: ${JSON.stringify(sigInfo.err)}`);
          console.log(`  Memo: ${sigInfo.memo || 'N/A'}`);
          console.log(`  Confirmation Status: ${sigInfo.confirmationStatus || 'N/A'}`);
        });
      } else {
        console.log('No signatures found for this address.');
      }
    } catch (error) {
      console.error('Error fetching signatures:', error);
    }
  }

  getLatestSignatures();
  ```
</CodeGroup>

### 2. Get Signatures with a Limit

This example fetches a specified number of recent transaction signatures for an address.

<CodeGroup>
  ```bash cURL
  # Replace <api-key> with your Helius API key
  # Replace TARGET_ACCOUNT_ADDRESS with the address you want to query
  curl https://mainnet.helius-rpc.com/?api-key=<api-key> -X POST -H "Content-Type: application/json" -d \
    '{
      "jsonrpc": "2.0",
      "id": 1,
      "method": "getSignaturesForAddress",
      "params": [
        "TARGET_ACCOUNT_ADDRESS",
        {
          "limit": 5 
        }
      ]
    }'
  ```

  ```javascript JavaScript (using @solana/web3.js)
  // Replace <api-key> with your Helius API key
  const { Connection, PublicKey } = require('@solana/web3.js');

  async function getLimitedSignatures() {
    const connection = new Connection('https://mainnet.helius-rpc.com/?api-key=<api-key>');
    // Replace with the public key you want to query
    const address = new PublicKey('Vote111111111111111111111111111111111111111'); 
    const limit = 5;

    try {
      const signatures = await connection.getSignaturesForAddress(address, { limit });
      console.log(`Fetched up to ${limit} signatures:`);
      signatures.forEach((sigInfo, index) => {
        console.log(`${index + 1}. Signature: ${sigInfo.signature}, Slot: ${sigInfo.slot}`);
      });
    } catch (error) {
      console.error(`Error fetching limited signatures for ${address.toBase58()}:`, error);
    }
  }

  getLimitedSignatures();
  ```
</CodeGroup>

### 3. Paginating Through Transaction History

This example demonstrates how to fetch transaction history in batches using the `before` parameter.

<CodeGroup>
  ```bash cURL
  # Initial request (get the latest 2)
  # Replace <api-key> with your Helius API key
  # Replace TARGET_ACCOUNT_ADDRESS with the address you want to query
  curl https://mainnet.helius-rpc.com/?api-key=<api-key> -X POST -H "Content-Type: application/json" -d \
    '{
      "jsonrpc": "2.0",
      "id": 1,
      "method": "getSignaturesForAddress",
      "params": [
        "TARGET_ACCOUNT_ADDRESS",
        { "limit": 2 }
      ]
    }'

  # Suppose the last signature from the above response was LAST_SIGNATURE_FROM_PREVIOUS_BATCH
  # Fetch the next 2 transactions before that one
  curl https://mainnet.helius-rpc.com/?api-key=<api-key> -X POST -H "Content-Type: application/json" -d \
    '{
      "jsonrpc": "2.0",
      "id": 1,
      "method": "getSignaturesForAddress",
      "params": [
        "TARGET_ACCOUNT_ADDRESS",
        { 
          "limit": 2,
          "before": "LAST_SIGNATURE_FROM_PREVIOUS_BATCH" 
        }
      ]
    }'
  ```

  ```javascript JavaScript (using @solana/web3.js)
  // Replace <api-key> with your Helius API key
  const { Connection, PublicKey } = require('@solana/web3.js');

  async function paginateSignatures() {
    const connection = new Connection('https://mainnet.helius-rpc.com/?api-key=<api-key>');
    // Replace with the public key you want to query - e.g. a known active address
    const address = new PublicKey('Vote111111111111111111111111111111111111111'); 
    const batchSize = 2;
    let lastSignature = null;
    let allSignatures = [];
    const maxPages = 3; // Limit how many pages we fetch for this example

    try {
      for (let i = 0; i < maxPages; i++) {
        console.log(`Fetching page ${i + 1}...`);
        const options = { limit: batchSize };
        if (lastSignature) {
          options.before = lastSignature;
        }

        const signatures = await connection.getSignaturesForAddress(address, options);
        
        if (signatures.length === 0) {
          console.log('No more signatures found.');
          break;
        }

        signatures.forEach(sigInfo => {
          allSignatures.push(sigInfo.signature);
          console.log(`  Found: ${sigInfo.signature} in slot ${sigInfo.slot}`);
        });
        
        lastSignature = signatures[signatures.length - 1]?.signature;

        if (signatures.length < batchSize || !lastSignature) {
           console.log('Fetched all available signatures or reached end of page.');
           break;
        }
        // Optional: Add a small delay if making many sequential requests
        // await new Promise(resolve => setTimeout(resolve, 200)); 
      }
      console.log(`
  Total signatures fetched (${allSignatures.length}):`);
      allSignatures.forEach((sig, idx) => console.log(`${idx + 1}. ${sig}`));

    } catch (error) {
      console.error('Error paginating signatures:', error);
    }
  }

  paginateSignatures();
  ```
</CodeGroup>

## Developer Tips

* **Pagination:** To get a complete transaction history for an active account, you'll likely need to make multiple requests, using the `before` parameter with the last signature received in the previous batch and a `limit`.
* **Rate Limits:** Be mindful of RPC node rate limits when fetching extensive transaction histories.
* **Order:** Signatures are always returned from newest to oldest.
* **`limit` Parameter:** The `limit` parameter can be between 1 and 1000. If not specified, it defaults to 1000.
* **`until` Parameter:** This parameter can be used to stop fetching signatures if a known older signature is reached, which can be useful if you only need transactions up to a certain point.
* **`minContextSlot`:** This parameter does not filter historical transactions. It specifies the minimum slot the RPC node should use for its context when evaluating the request. If the node's state is older than this slot, it may return an error.
* **Transaction Details:** This method only returns signatures and basic information. To get full transaction details, you would use the `getTransaction` method with each signature.

By using `getSignaturesForAddress` with its pagination options, you can effectively retrieve and manage transaction histories for any Solana address.


# How to Use getSignatureStatuses
Source: https://www.helius.dev/docs/rpc/guides/getsignaturestatuses

Learn getSignatureStatuses use cases, code examples, request parameters, response structure, and tips.

The [`getSignatureStatuses`](https://www.helius.dev/docs/api-reference/rpc/http/getsignaturestatuses) RPC method allows you to retrieve the processing and confirmation status of a list of transaction signatures. This is useful for determining if transactions have been [processed, confirmed, or finalized](https://www.helius.dev/blog/solana-commitment-levels) by the network.

Unless the `searchTransactionHistory` option is enabled, this method primarily queries a recent status cache on the RPC node. For older transactions, enabling `searchTransactionHistory` is crucial.

## Common Use Cases

* **Confirming Transaction Finality:** Verifying if a submitted transaction has reached a desired level of confirmation (e.g., `confirmed` or `finalized`).
* **Batch Status Lookup:** Efficiently checking the status of multiple transactions at once, for example, after a batch send.
* **Updating UI based on Transaction State:** Reflecting the real-time status of a transaction to the user.
* **Error Checking:** Identifying if any of a list of transactions failed and why.

## Request Parameters

1. **`signatures`** (`array` of `string`): (Required) An array of base-58 encoded transaction signatures. You can query up to 256 signatures in a single request.
2. **`options`** (`object`, optional): An optional configuration object with the following field:
   * **`searchTransactionHistory`** (`boolean`, optional): If `true`, the RPC node will search its full transaction history for the signatures. If `false` (the default), it only searches a recent status cache. For old or potentially dropped transactions, set this to `true`.

## Response Structure

The `result` field of the JSON-RPC response contains an object with two fields:

* **`context`** (`object`): An object containing:
  * **`slot`** (`u64`): The slot in which the RPC node processed this request.
* **`value`** (`array` of `object` | `null`): An array of status objects, corresponding to the order of signatures in the request. Each element can be:
  * An **object** with the following fields if the signature is found:
    * **`slot`** (`u64`): The slot in which the transaction was processed.
    * **`confirmations`** (`number` | `null`): The number of blocks that have been confirmed since the transaction was processed. `null` if the transaction is finalized (as finality implies it won't be rolled back, so a specific confirmation count isn't as relevant).
    * **`err`** (`object` | `null`): An error object if the transaction failed (e.g., `{"InstructionError":[0,{"Custom":1}]}`), or `null` if it succeeded.
    * **`status`** (`object`): An object indicating the transaction's execution status. Usually `{"Ok":null}` for successful transactions or an object detailing the error for failed ones.
    * **`confirmationStatus`** (`string` | `null`): The cluster's confirmation status for the transaction (e.g., `processed`, `confirmed`, `finalized`). Can be `null` if status is not available in the cache and `searchTransactionHistory` is false.
  * **`null`**: If a signature is not found in the status cache and `searchTransactionHistory` is `false` (or if it truly doesn't exist even with history search).

## Examples

### 1. Get Status for a List of Signatures (Recent Cache)

This example fetches the status for two signatures, relying on the node's recent cache.

<CodeGroup>
  ```bash cURL
  # Replace <api-key> with your Helius API key
  # Replace with actual transaction signatures
  curl https://mainnet.helius-rpc.com/?api-key=<api-key> -X POST -H "Content-Type: application/json" -d \
    '{
      "jsonrpc": "2.0",
      "id": 1,
      "method": "getSignatureStatuses",
      "params": [
        [
          "5VERv8NMvzbJMEkV8xnrLkEaWRtSz9CosKDYjCJjBRnbJLgp8uirBgmQpjKhoR4tjF3ZpRzrFmBV6UjKdiSZkQUW",
          "2x5YfV29N4p9K2kEFK2gFfC5T5acbs2z2MytTZqrgq17pYjCMfYjW4sAUpkWMkMzxGztD2Qv5v7n92uYJcQY9c7a" 
        ]
      ]
    }'
  ```

  ```javascript JavaScript (using @solana/web3.js)
  // Replace <api-key> with your Helius API key
  const { Connection } = require('@solana/web3.js');

  async function checkRecentSignatures() {
    const connection = new Connection('https://mainnet.helius-rpc.com/?api-key=<api-key>');
    const signatures = [
      '5VERv8NMvzbJMEkV8xnrLkEaWRtSz9CosKDYjCJjBRnbJLgp8uirBgmQpjKhoR4tjF3ZpRzrFmBV6UjKdiSZkQUW',
      '2x5YfV29N4p9K2kEFK2gFfC5T5acbs2z2MytTZqrgq17pYjCMfYjW4sAUpkWMkMzxGztD2Qv5v7n92uYJcQY9c7a' // Replace with another signature
    ];

    try {
      const response = await connection.getSignatureStatuses(signatures);
      console.log("RPC Response Context Slot:", response.context.slot);
      response.value.forEach((status, index) => {
        console.log(`--- Status for Signature ${index + 1} (${signatures[index].substring(0,10)}...) ---`);
        if (status) {
          console.log(`  Slot: ${status.slot}`);
          console.log(`  Confirmations: ${status.confirmations === null ? 'Finalized (or N/A)' : status.confirmations}`);
          console.log(`  Error: ${JSON.stringify(status.err)}`);
          console.log(`  Execution Status: ${JSON.stringify(status.status)}`);
          console.log(`  Confirmation Status: ${status.confirmationStatus}`);
        } else {
          console.log('  Status not found (likely not in recent cache or does not exist).');
        }
      });
    } catch (error) {
      console.error('Error fetching signature statuses:', error);
    }
  }

  checkRecentSignatures();
  ```
</CodeGroup>

### 2. Get Status with Transaction History Search

This example fetches the status for signatures and explicitly requests the node to search its transaction history.

<CodeGroup>
  ```bash cURL
  # Replace <api-key> with your Helius API key
  # Replace with actual transaction signatures
  curl https://mainnet.helius-rpc.com/?api-key=<api-key> -X POST -H "Content-Type: application/json" -d \
    '{
      "jsonrpc": "2.0",
      "id": 1,
      "method": "getSignatureStatuses",
      "params": [
        [
          "3jPTfHcbzWHeD4jW8q4Y8g3h2D1aBwM81y1sHhDqYQ7Z9x5n7cVy2gD8QWbK9eXwSjJ6aA7FzV2kLpQoEwU9jX", 
          "4SyzjM2fTALqTNjLKMM1yG1bW7kCFu2GvEkKcvKChG9o1KjQW8jLdZ6sWfN9mP1pU3rD7XvA6B2CjHkLwRzYxTnX"  
        ],
        {
          "searchTransactionHistory": true
        }
      ]
    }'
  ```

  ```javascript JavaScript (using @solana/web3.js)
  // Replace <api-key> with your Helius API key
  const { Connection } = require('@solana/web3.js');

  async function checkSignaturesWithHistory() {
    const connection = new Connection('https://mainnet.helius-rpc.com/?api-key=<api-key>');
    const signatures = [
      // Replace with a signature you know is older or might have been dropped
      '3jPTfHcbzWHeD4jW8q4Y8g3h2D1aBwM81y1sHhDqYQ7Z9x5n7cVy2gD8QWbK9eXwSjJ6aA7FzV2kLpQoEwU9jX',
      // Replace with another valid signature
      '4SyzjM2fTALqTNjLKMM1yG1bW7kCFu2GvEkKcvKChG9o1KjQW8jLdZ6sWfN9mP1pU3rD7XvA6B2CjHkLwRzYxTnX' 
    ];

    try {
      const response = await connection.getSignatureStatuses(signatures, { searchTransactionHistory: true });
      console.log("RPC Response Context Slot:", response.context.slot);
      response.value.forEach((status, index) => {
        console.log(`--- Status for Signature ${index + 1} (${signatures[index].substring(0,10)}...) ---`);
        if (status) {
          console.log(`  Slot: ${status.slot}`);
          console.log(`  Confirmations: ${status.confirmations === null ? 'Finalized (or N/A)' : status.confirmations}`);
          console.log(`  Error: ${JSON.stringify(status.err)}`);
          console.log(`  Execution Status: ${JSON.stringify(status.status)}`);
          console.log(`  Confirmation Status: ${status.confirmationStatus}`);
        } else {
          console.log('  Status not found (even with history search, it might not exist or is too old).');
        }
      });
    } catch (error) {
      console.error('Error fetching signature statuses with history:', error);
    }
  }

  checkSignaturesWithHistory();
  ```
</CodeGroup>

## Developer Tips

* **`searchTransactionHistory`:** Crucial for reliability. If `false` (default), the method only checks a limited recent cache. If a transaction is old or was potentially dropped and not in this cache, it will return `null` for that signature's status. Always set to `true` if you need to confirm the status of transactions that might not be very recent.
* **Signature Limit:** You can query a maximum of 256 signatures per call.
* **`null` Status:** A `null` in the `value` array for a given signature means its status was not found. This could be because it's not in the recent cache (if `searchTransactionHistory` is false), the transaction never landed, or it's too old for the node's history even with `searchTransactionHistory: true`.
* **`confirmations: null`**: This usually means the transaction has reached `finalized` status. At this point, the concept of a specific number of confirmations is less relevant because the block is considered irreversible.
* **Error Handling:** Check the `err` field within each status object to see if a transaction failed. The `status` field will also provide details (e.g., `{"Err":...}`).

Using `getSignatureStatuses` is an efficient way to monitor the state of multiple Solana transactions. Remember to use `searchTransactionHistory: true` for robust status checking.


# How to Use getSlot
Source: https://www.helius.dev/docs/rpc/guides/getslot

Learn getSlot use cases, code examples, request parameters, response structure, and tips.

The [`getSlot`](https://www.helius.dev/docs/api-reference/rpc/http/getslot) RPC method returns the current slot that the RPC node considers to have reached a specific commitment level. This is a fundamental method for understanding the current state of the blockchain as perceived by the node.

## Common Use Cases

* **Getting Current Network Progress:** Determine the most recent slot processed or confirmed by the node.
* **Node Synchronization Check:** Comparing the slot from different nodes can give an indication of their synchronization status.
* **Timestamping Operations:** Using the current slot as a reference point for operations or for understanding the age of certain data.
* **Input for Other RPC Calls:** Some RPC methods might use a slot number as a reference point.

## Request Parameters

This method takes an optional configuration object as its first parameter:

1. **`options`** (`object`, optional): An optional configuration object with the following fields:
   * **`commitment`** (`string`, optional): Specifies the [commitment level](https://www.helius.xyz/blog/what-are-solana-commitment-levels) for the query. Supported values are `finalized`, `confirmed`, or `processed`. If omitted, the default commitment of the RPC node is used (usually `finalized`).
     * `processed`: The node will query its most recent slot. Note that this slot may not be confirmed by the cluster yet and could potentially be skipped.
     * `confirmed`: The node will query the most recent slot that has been voted on by a supermajority of the cluster.
     * `finalized`: The node will query the most recent slot confirmed by the supermajority of the cluster as having reached maximum lockout (cannot be rolled back).
   * **`minContextSlot`** (`number`, optional): The minimum slot that the request can be evaluated at. This sets the minimum slot for the node's context. If the node's state is older than this slot, it may return an error or a slot number that reflects its current (older) state relative to this minimum.

## Response Structure

The `result` field of the JSON-RPC response is a single `u64` (unsigned 64-bit integer) representing the current slot number according to the specified commitment level.

**Example Response:**

```json
{
  "jsonrpc": "2.0",
  "result": 123456789,
  "id": 1
}
```

## Examples

### 1. Get Current Slot (Default Commitment)

This example fetches the current slot using the node's default commitment level (usually `finalized`).

<CodeGroup>
  ```bash cURL
  # Replace <api-key> with your Helius API key
  curl https://mainnet.helius-rpc.com/?api-key=<api-key> -X POST -H "Content-Type: application/json" -d \
    '{
      "jsonrpc": "2.0",
      "id": 1,
      "method": "getSlot"
    }'
  ```

  ```javascript JavaScript (using @solana/web3.js)
  // Replace <api-key> with your Helius API key
  const { Connection } = require('@solana/web3.js');

  async function getCurrentSlot() {
    const connection = new Connection('https://mainnet.helius-rpc.com/?api-key=<api-key>');
    try {
      const slot = await connection.getSlot();
      console.log('Current slot (default commitment):', slot);
    } catch (error) {
      console.error('Error fetching current slot:', error);
    }
  }

  getCurrentSlot();
  ```
</CodeGroup>

### 2. Get Current Slot with a Specific Commitment

This example fetches the current slot that has reached `confirmed` commitment.

<CodeGroup>
  ```bash cURL
  # Replace <api-key> with your Helius API key
  curl https://mainnet.helius-rpc.com/?api-key=<api-key> -X POST -H "Content-Type: application/json" -d \
    '{
      "jsonrpc": "2.0",
      "id": 1,
      "method": "getSlot",
      "params": [
        {
          "commitment": "confirmed"
        }
      ]
    }'
  ```

  ```javascript JavaScript (using @solana/web3.js)
  // Replace <api-key> with your Helius API key
  const { Connection } = require('@solana/web3.js');

  async function getConfirmedSlot() {
    const connection = new Connection('https://mainnet.helius-rpc.com/?api-key=<api-key>');
    try {
      const slot = await connection.getSlot('confirmed');
      console.log('Current slot (confirmed commitment):', slot);
      // Note: For @solana/web3.js v1.30.0 and later, you can pass commitment directly.
      // For older versions or more complex options, use an object:
      // const slot = await connection.getSlot({ commitment: 'confirmed' });
    } catch (error) {
      console.error('Error fetching confirmed slot:', error);
    }
  }

  getConfirmedSlot();
  ```
</CodeGroup>

## Developer Tips

* **Commitment Matters:** The returned slot number heavily depends on the `commitment` level specified. Refer to [Solana Commitment Levels](https://www.helius.xyz/blog/what-are-solana-commitment-levels) for detailed information. `processed` will be the highest (most recent) slot the node is aware of, while `finalized` will be an older slot that is confirmed by the entire network. Choose the commitment level appropriate for your use case's need for data finality.
* **Node Variability:** Different RPC nodes might return slightly different slot numbers for the same commitment level due to network propagation delays or their own processing state. This is especially true for `processed` and `confirmed` levels.
* **`minContextSlot`:** This parameter ensures that the node processing your request has reached at least the `minContextSlot`. If the node is behind this slot, the behavior might vary (e.g., an error or the node's current highest slot which is less than `minContextSlot`). It's generally used in advanced scenarios where you need to ensure a query is made against a sufficiently recent state.

`getSlot` is a simple yet essential method for interacting with the Solana blockchain and understanding its current progression.


# How to Use getSlotLeader
Source: https://www.helius.dev/docs/rpc/guides/getslotleader

Learn getSlotLeader use cases, code examples, request parameters, response structure, and tips.

The [`getSlotLeader`](https://www.helius.dev/docs/api-reference/rpc/http/getslotleader) RPC method returns the public key of the validator that is the current leader for block production, based on the node's view at a specified commitment level. The leader is responsible for producing blocks for the current slot.

## Common Use Cases

* **Identifying the Current Block Producer:** Find out which validator is currently scheduled to produce blocks.
* **Network Monitoring:** Observe the rotation of slot leaders.
* **Debugging Transaction Issues:** In some advanced scenarios, knowing the current slot leader might be relevant if transactions are being submitted directly to leaders (though this is not a common client-side practice).

## Request Parameters

This method takes an optional configuration object as its first parameter:

1. **`options`** (`object`, optional): An optional configuration object with the following fields:
   * **`commitment`** (`string`, optional): Specifies the [commitment level](https://www.helius.dev/blog/solana-commitment-levels) for the query. Supported values are `finalized`, `confirmed`, or `processed`. If omitted, the default commitment of the RPC node is used (usually `finalized`). The slot leader is determined based on the slot that matches this commitment level.
   * **`minContextSlot`** (`number`, optional): The minimum slot that the request can be evaluated at. This sets the minimum slot for the node's context.

## Response Structure

The `result` field of the JSON-RPC response is a single base-58 encoded string representing the public key (identity) of the current slot leader.

**Example Response:**

```json
{
  "jsonrpc": "2.0",
  "result": "ENvAW7JScgYq6o4zKZwewtkzzJgDzuJAFxYasvmEQdpS",
  "id": 1
}
```

## Examples

### 1. Get Current Slot Leader (Default Commitment)

This example fetches the current slot leader using the node's default commitment level (usually `finalized`).

<CodeGroup>
  ```bash cURL
  # Replace <api-key> with your Helius API key
  curl https://mainnet.helius-rpc.com/?api-key=<api-key> -X POST -H "Content-Type: application/json" -d \
    '{
      "jsonrpc": "2.0",
      "id": 1,
      "method": "getSlotLeader"
    }'
  ```

  ```javascript JavaScript (using @solana/web3.js)
  // Replace <api-key> with your Helius API key
  const { Connection } = require('@solana/web3.js');

  async function getCurrentSlotLeader() {
    const connection = new Connection('https://mainnet.helius-rpc.com/?api-key=<api-key>');
    try {
      const slotLeader = await connection.getSlotLeader();
      console.log('Current slot leader (default commitment):', slotLeader);
    } catch (error) {
      console.error('Error fetching current slot leader:', error);
    }
  }

  getCurrentSlotLeader();
  ```
</CodeGroup>

### 2. Get Current Slot Leader with `confirmed` Commitment

This example fetches the slot leader for the latest slot that has reached `confirmed` commitment.

<CodeGroup>
  ```bash cURL
  # Replace <api-key> with your Helius API key
  curl https://mainnet.helius-rpc.com/?api-key=<api-key> -X POST -H "Content-Type: application/json" -d \
    '{
      "jsonrpc": "2.0",
      "id": 1,
      "method": "getSlotLeader",
      "params": [
        {
          "commitment": "confirmed"
        }
      ]
    }'
  ```

  ```javascript JavaScript (using @solana/web3.js)
  // Replace <api-key> with your Helius API key
  const { Connection } = require('@solana/web3.js');

  async function getConfirmedSlotLeader() {
    const connection = new Connection('https://mainnet.helius-rpc.com/?api-key=<api-key>');
    try {
      const slotLeader = await connection.getSlotLeader('confirmed');
      console.log('Current slot leader (confirmed commitment):', slotLeader);
      // Note: For @solana/web3.js v1.30.0 and later, you can pass commitment directly.
      // For older versions or more complex options, use an object:
      // const slotLeader = await connection.getSlotLeader({ commitment: 'confirmed' });
    } catch (error) {
      console.error('Error fetching confirmed slot leader:', error);
    }
  }

  getConfirmedSlotLeader();
  ```
</CodeGroup>

## Developer Tips

* **Dynamic Nature:** Slot leaders change frequently (every few slots, typically 4). The result of this call is a snapshot in time based on the node's current view and the chosen commitment.
* **Commitment Level:** The commitment level affects which slot is considered "current" for determining the leader. Using `processed` will give you the leader of the very latest slot the node is aware of, which might change rapidly and may not yet be confirmed by the broader network.
* **Leader Schedule:** The sequence of slot leaders is determined by a leader schedule, which is calculated at the beginning of each epoch. Our guide on [Slots, Blocks, and Epochs](https://www.helius.dev/blog/solana-slots-blocks-and-epochs) provides more details on this process. For a more comprehensive view of upcoming leaders, use `getLeaderSchedule`.
* **Node's Perspective:** The returned slot leader is based on the information available to the specific RPC node you are querying. Different nodes might have slightly different views due to network latency.

`getSlotLeader` provides a quick way to identify the validator currently responsible for producing blocks. For a broader view of the leader rotation, consider `getLeaderSchedule`.


# How to Use getSlotLeaders
Source: https://www.helius.dev/docs/rpc/guides/getslotleaders

Learn getSlotLeaders use cases, code examples, request parameters, response structure, and tips.

The [`getSlotLeaders`](https://www.helius.dev/docs/api-reference/rpc/http/getslotleaders) RPC method allows you to retrieve a list of public keys for the validators scheduled to be leaders for a specific range of slots. This can be useful for understanding the upcoming sequence of block producers.

## Common Use Cases

* **Predicting Near-Term Block Producers:** Identify which validators are expected to produce blocks in the near future for a limited range of slots.
* **Analyzing Leader Distribution:** Observe the sequence of leaders for a segment of an epoch.
* **Network Analysis Tools:** Tools that monitor or analyze network behavior might use this to understand leader patterns.

## Request Parameters

1. **`startSlot`** (`u64`): (Required) The first slot (inclusive) to fetch the leader schedule for.
2. **`limit`** (`u64`): (Required) The number of consecutive slots to retrieve leaders for. The limit must be between 1 and 5,000.

## Response Structure

The `result` field of the JSON-RPC response is an array of base-58 encoded strings. Each string is the public key (identity) of a validator. The order of public keys in the array corresponds to the leader for each slot in the requested range, starting from `startSlot`.

**Example Response (for a limit of 3 slots):**

```json
{
  "jsonrpc": "2.0",
  "result": [
    "ValidatorPubkey1XXXXXXXXXXXXXXXXXXXXXXXXXXXX",
    "ValidatorPubkey2XXXXXXXXXXXXXXXXXXXXXXXXXXXX",
    "ValidatorPubkey3XXXXXXXXXXXXXXXXXXXXXXXXXXXX"
  ],
  "id": 1
}
```

## Examples

### 1. Get Slot Leaders for a Specific Range

This example fetches the leaders for 5 slots, starting from a specified slot.

<CodeGroup>
  ```bash cURL
  # Replace <api-key> with your Helius API key
  # Replace STARTING_SLOT with a recent or future slot number
  curl https://mainnet.helius-rpc.com/?api-key=<api-key> -X POST -H "Content-Type: application/json" -d \
    '{
      "jsonrpc": "2.0",
      "id": 1,
      "method": "getSlotLeaders",
      "params": [
        180000000, 
        5          
      ]
    }'
  ```

  ```javascript JavaScript (using @solana/web3.js)
  // Replace <api-key> with your Helius API key
  const { Connection } = require('@solana/web3.js');

  async function getUpcomingSlotLeaders() {
    const connection = new Connection('https://mainnet.helius-rpc.com/?api-key=<api-key>');
    const startSlot = 180000000; // Replace with a recent or future slot number
    const limit = 5;

    try {
      const leaders = await connection.getSlotLeaders(startSlot, limit);
      console.log(`Slot leaders starting from slot ${startSlot} (limit ${limit}):`);
      leaders.forEach((leader, index) => {
        console.log(`  Slot ${startSlot + index}: ${leader}`);
      });
    } catch (error) {
      console.error('Error fetching slot leaders:', error);
    }
  }

  getUpcomingSlotLeaders();
  ```
</CodeGroup>

## Developer Tips

* **Limit:** The `limit` parameter specifies how many consecutive slot leaders to return, up to a maximum of 5,000. This means you can look ahead for a substantial number of slots within an epoch.
* **Epoch Boundaries:** The leader schedule is determined for an entire epoch, as detailed in our guide on [Slots, Blocks, and Epochs](https://www.helius.dev/blog/solana-slots-blocks-and-epochs). This method allows you to query parts of that schedule. If your range crosses an epoch boundary, the leaders returned will still be based on the schedule of the epoch in which `startSlot` resides, up to the limit you provide or the end of that epoch's known schedule if the RPC node doesn't project further for that call.
* **Future Slots:** You can request leaders for future slots. The RPC node will return the scheduled leaders based on the current leader schedule for the relevant epoch.
* **Accuracy:** The leader schedule is fixed for an epoch, so the returned leaders are generally accurate unless there are exceptional network circumstances or changes to the validator set that might affect subsequent epoch calculations.
* **Distinction from `getLeaderSchedule`:** While `getSlotLeaders` gives you a direct list for a range, `getLeaderSchedule` provides the full schedule for an entire epoch, mapping validator identities to all their assigned slots within that epoch. `getSlotLeaders` is more direct if you only need a sequential list for a specific, limited range.

Use `getSlotLeaders` when you need to know the sequence of block producers for a defined upcoming segment of slots.


# How to Use getStakeMinimumDelegation
Source: https://www.helius.dev/docs/rpc/guides/getstakeminimumdelegation

Learn getStakeMinimumDelegation use cases, code examples, request parameters, response structure, and tips.

The [`getStakeMinimumDelegation`](https://www.helius.dev/docs/api-reference/rpc/http/getstakeminimumdelegation) RPC method returns the current minimum amount of lamports required to create a new [stake](https://www.helius.dev/blog/how-to-stake-solana) delegation on the Solana network. This value can change over time due to network governance or updates.

## Common Use Cases

* **Validating Stake Amounts:** Before creating a new stake account or delegating stake, check this value to ensure the intended delegation meets the minimum requirement.
* **Staking UI/UX:** Displaying the minimum delegation amount to users in staking interfaces to guide their input.
* **Automated Staking Scripts:** Ensuring automated staking processes use a valid delegation amount.

## Request Parameters

This method has one optional parameter:

1. **`config`** (object, optional): Configuration object containing the following field:
   * **`commitment`** (string, optional): Specifies the [commitment level](https://www.helius.dev/blog/solana-commitment-levels) to use when querying the value. If omitted, the default commitment of the RPC node is used (usually `finalized`).

## Response Structure

The `result` field of the JSON-RPC response is an `RpcResponse` object containing:

* **`context`** (object): An `RpcResponseContext` object with the following field:
  * **`slot`** (`u64`): The slot at which the data was retrieved.
* **`value`** (`u64`): The minimum stake delegation amount in lamports.

**Example Response:**

```json
{
  "jsonrpc": "2.0",
  "result": {
    "context": { "slot": 123456789 },
    "value": 1000000000 // Represents 1 SOL, for example
  },
  "id": 1
}
```

## Examples

### 1. Get the Current Stake Minimum Delegation

This example fetches the current minimum stake delegation amount using the default commitment.

<CodeGroup>
  ```bash cURL
  # Replace <api-key> with your Helius API key
  curl https://mainnet.helius-rpc.com/?api-key=<api-key> -X POST -H "Content-Type: application/json" -d \
    '{
      "jsonrpc": "2.0",
      "id": 1,
      "method": "getStakeMinimumDelegation"
    }'
  ```

  ```javascript JavaScript (using @solana/web3.js)
  // Replace <api-key> with your Helius API key
  const { Connection } = require('@solana/web3.js');

  async function getMinimumDelegation() {
    const connection = new Connection('https://mainnet.helius-rpc.com/?api-key=<api-key>');
    try {
      const minDelegation = await connection.getStakeMinimumDelegation();
      console.log(`Current minimum stake delegation: ${minDelegation} lamports`);
      // The raw response includes context:
      // const fullResponse = await connection.getStakeMinimumDelegation('confirmed'); // Example with commitment
      // console.log(JSON.stringify(fullResponse, null, 2));
    } catch (error) {
      console.error('Error fetching stake minimum delegation:', error);
    }
  }

  getMinimumDelegation();
  ```
</CodeGroup>

### 2. Get Stake Minimum Delegation with Specific Commitment

<CodeGroup>
  ```bash cURL
  # Replace <api-key> with your Helius API key
  curl https://mainnet.helius-rpc.com/?api-key=<api-key> -X POST -H "Content-Type: application/json" -d \
    '{
      "jsonrpc": "2.0",
      "id": 1,
      "method": "getStakeMinimumDelegation",
      "params": [
        {
          "commitment": "confirmed"
        }
      ]
    }'
  ```

  ```javascript JavaScript (using @solana/web3.js)
  // Replace <api-key> with your Helius API key
  const { Connection } = require('@solana/web3.js');

  async function getMinimumDelegationConfirmed() {
    const connection = new Connection('https://mainnet.helius-rpc.com/?api-key=<api-key>');
    try {
      const minDelegationResponse = await connection.getStakeMinimumDelegation('confirmed');
      console.log(`Confirmed minimum stake delegation: ${minDelegationResponse.value} lamports at slot ${minDelegationResponse.context.slot}`);
    } catch (error) {
      console.error('Error fetching confirmed stake minimum delegation:', error);
    }
  }

  getMinimumDelegationConfirmed();
  ```
</CodeGroup>

## Developer Tips

* **Lamports vs. SOL:** The returned value is in lamports. Remember that 1 SOL = 1,000,000,000 lamports.
* **Dynamic Value:** The minimum delegation amount is subject to change by network parameters. It's advisable to query this value periodically or before critical operations rather than hardcoding it. Learn more about [staking](https://www.helius.dev/blog/how-to-stake-solana) in our detailed guide.
* **Commitment Levels:** Using different commitment levels can affect how up-to-date the returned value is. `finalized` provides the most certainty, while `processed` might give a newer value that hasn't been fully confirmed by the cluster.

This guide should help you effectively use the `getStakeMinimumDelegation` RPC method to retrieve the minimum required stake delegation on Solana.


# How to Use getSupply
Source: https://www.helius.dev/docs/rpc/guides/getsupply

Learn getSupply use cases, code examples, request parameters, response structure, and tips.

The [`getSupply`](https://www.helius.dev/docs/api-reference/rpc/http/getsupply) RPC method provides information about the current supply of SOL on the Solana network. It details the total supply, circulating supply, non-circulating supply, and can optionally list non-circulating accounts.

## Common Use Cases

* **Understanding SOL Tokenomics:** Get a snapshot of the current distribution of SOL.
* **Economic Analysis:** Track changes in supply metrics over time.
* **Displaying Network Statistics:** Provide users with up-to-date information on SOL supply in dashboards or explorers.
* **Inflation Monitoring:** Although `getInflationRate` and `getInflationGovernor` provide more direct inflation data, `getSupply` can offer a broader context.

## Request Parameters

The `getSupply` method accepts an optional configuration object with the following fields:

1. **`commitment`** (string, optional): Specifies the [commitment level](https://www.helius.dev/blog/solana-commitment-levels) for the query. If omitted, the default commitment of the RPC node is used.
2. **`excludeNonCirculatingAccountsList`** (boolean, optional): If set to `true`, the `nonCirculatingAccounts` array will be excluded from the response. Defaults to `false`. This can be useful to reduce response size if the list of individual non-circulating accounts is not needed.

**Example Configuration:**

```json
{
  "commitment": "finalized",
  "excludeNonCirculatingAccountsList": true
}
```

## Response Structure

The response is a JSON object with the following fields:

* **`value`**: An object containing the supply information:
  * **`total`** (u64): The total SOL supply in lamports.
  * **`circulating`** (u64): The circulating SOL supply in lamports.
  * **`nonCirculating`** (u64): The non-circulating SOL supply in lamports.
  * **`nonCirculatingAccounts`** (array of strings, optional): An array of public keys (as base58 encoded strings) of accounts holding non-circulating SOL. This field is omitted if `excludeNonCirculatingAccountsList` was set to `true` in the request.
* **`context`**: An object containing:
  * **`slot`** (u64): The slot at which the information was retrieved.

**Example Response (with `excludeNonCirculatingAccountsList: false`):**

```json
{
  "jsonrpc": "2.0",
  "result": {
    "context": {
      "slot": 169890374
    },
    "value": {
      "circulating": 423105827585008800,
      "nonCirculating": 123456789012345678, // Example value
      "nonCirculatingAccounts": [
        "Stake11111111111111111111111111111111111111",
        "Vote11111111111111111111111111111111111111",
        // ... other non-circulating accounts
      ],
      "total": 546562616597354478
    }
  },
  "id": 1
}
```

**Example Response (with `excludeNonCirculatingAccountsList: true`):**

```json
{
  "jsonrpc": "2.0",
  "result": {
    "context": {
      "slot": 169890380
    },
    "value": {
      "circulating": 423105830000000000,
      "nonCirculating": 123456780000000000, // Example value
      "total": 546562610000000000
      // nonCirculatingAccounts field is absent
    }
  },
  "id": 1
}
```

## Code Examples

<CodeGroup>
  ```bash cURL
  # Basic Request:
  curl -X POST -H "Content-Type: application/json" -d \
    '{"jsonrpc":"2.0","id":1,"method":"getSupply"}' \
    <YOUR_RPC_URL>

  # Request with excludeNonCirculatingAccountsList:
  curl -X POST -H "Content-Type: application/json" -d \
    '{"jsonrpc":"2.0","id":1,"method":"getSupply", "params": [{"excludeNonCirculatingAccountsList": true}]}' \
    <YOUR_RPC_URL>

  # Request with commitment:
  curl -X POST -H "Content-Type: application/json" -d \
    '{"jsonrpc":"2.0","id":1,"method":"getSupply", "params": [{"commitment": "confirmed", "excludeNonCirculatingAccountsList": false}]}' \
    <YOUR_RPC_URL>
  ```

  ```javascript JavaScript (using @solana/web3.js)
  const { Connection } = require('@solana/web3.js');

  async function getNetworkSupply() {
    // Replace with your RPC endpoint
    const connection = new Connection('https://mainnet.helius-rpc.com/?api-key=<api-key>');

    try {
      const supplyInfo = await connection.getSupply();
      console.log('Supply Information:', supplyInfo.value);
      console.log('Total SOL:', supplyInfo.value.total / 1_000_000_000); // Convert lamports to SOL
      console.log('Circulating SOL:', supplyInfo.value.circulating / 1_000_000_000);
      console.log('Non-Circulating SOL:', supplyInfo.value.nonCirculating / 1_000_000_000);

      if (supplyInfo.value.nonCirculatingAccounts) {
        console.log('Non-circulating accounts count:', supplyInfo.value.nonCirculatingAccounts.length);
      }

      // Example with options
      const supplyInfoWithoutAccountsList = await connection.getSupply({
        commitment: 'finalized',
        excludeNonCirculatingAccountsList: true,
      });
      console.log('\nSupply Information (excluding non-circulating accounts list):');
      console.log('Total SOL:', supplyInfoWithoutAccountsList.value.total / 1_000_000_000);
      console.log('Circulating SOL:', supplyInfoWithoutAccountsList.value.circulating / 1_000_000_000);

    } catch (error) {
      console.error('Error getting supply information:', error);
    }
  }

  getNetworkSupply();
  ```
</CodeGroup>

## Developer Tips

* **Lamports vs. SOL:** The amounts are returned in lamports. Remember to divide by `1,000,000,000` (1 SOL = 10^9 lamports) to convert to SOL.
* **Data Freshness:** The data reflects the state at the slot indicated in the `context` object and based on the commitment level used.
* **`excludeNonCirculatingAccountsList`:** Use this option if you only need the aggregate supply numbers to optimize the response size and processing time, especially if the list of non-circulating accounts is very long.
* **Dynamic Values:** The supply figures can change frequently due to token issuance (inflation) and burning mechanisms.

This guide should help you effectively use the `getSupply` RPC method to query Solana's supply data.


# How to Use getTokenAccountBalance
Source: https://www.helius.dev/docs/rpc/guides/gettokenaccountbalance

Learn getTokenAccountBalance use cases, code examples, request parameters, response structure, and tips.

The [`getTokenAccountBalance`](https://www.helius.dev/docs/api-reference/rpc/http/gettokenaccountbalance) RPC method returns the token balance of a specific SPL Token account. This is essential for applications that need to display or verify the amount of a particular token held by a token account.

## Common Use Cases

* **Displaying User Token Balances:** Showing users how much of a specific token they own in their wallet (associated token accounts).
* **Verifying Token Availability:** Checking if a token account has sufficient balance before attempting a transfer or other operation.
* **Portfolio Tracking:** Aggregating token balances for a user across different token accounts.
* **Smart Contract Interactions:** Smart contracts might query token balances as part of their logic (though on-chain programs typically access this data directly from account info).

## Request Parameters

1. **Token Account Public Key** (string, required): The base-58 encoded public key of the SPL Token account you want to query.
2. **Configuration Object** (object, optional): An optional object that can contain the following field:
   * **`commitment`** (string, optional): Specifies the [commitment level](https://www.helius.dev/blog/solana-commitment-levels) for the query. If omitted, the default commitment of the RPC node is used (usually `finalized`).

## Response Structure

The `result` field in the JSON-RPC response contains an object with a `context` and a `value` field. The `value` object holds the balance information:

* **`amount`** (string): The raw balance of the token account as a string. This is an integer representing the smallest unit of the token (e.g., if a token has 6 decimals, an amount of "1000000" means 1 token).
* **`decimals`** (u8): The number of decimal places defined for this token type (by its mint).
* **`uiAmount`** (number | null): The balance formatted as a floating-point number, taking into account the `decimals`. This field might be `null` or deprecated in some contexts in favor of `uiAmountString`.
* **`uiAmountString`** (string): The balance formatted as a string, taking into account the `decimals`. This is often preferred for display to avoid potential floating-point inaccuracies.

**Example Response:**

```json
{
  "jsonrpc": "2.0",
  "result": {
    "context": {
      "slot": 183457201
    },
    "value": {
      "amount": "500000000",
      "decimals": 9,
      "uiAmount": 0.5,
      "uiAmountString": "0.5"
    }
  },
  "id": 1
}
```

## Code Examples

<CodeGroup>
  ```bash cURL
  # Basic Request (replace <TOKEN_ACCOUNT_PUBKEY>):
  curl -X POST -H "Content-Type: application/json" -d \
    '{
      "jsonrpc": "2.0",
      "id": 1,
      "method": "getTokenAccountBalance",
      "params": [
        "<TOKEN_ACCOUNT_PUBKEY>"
      ]
    }' \
    <YOUR_RPC_URL>

  # Request with commitment (replace <TOKEN_ACCOUNT_PUBKEY>):
  curl -X POST -H "Content-Type: application/json" -d \
    '{
      "jsonrpc": "2.0",
      "id": 1,
      "method": "getTokenAccountBalance",
      "params": [
        "<TOKEN_ACCOUNT_PUBKEY>",
        {
          "commitment": "confirmed"
        }
      ]
    }' \
    <YOUR_RPC_URL>
  ```

  ```javascript JavaScript (using @solana/web3.js)
  const { Connection, PublicKey } = require('@solana/web3.js');

  async function checkTokenBalance(tokenAccountPublicKey) {
    // Replace with your RPC endpoint
    const connection = new Connection('https://mainnet.helius-rpc.com/?api-key=<api-key>');
    
    try {
      const tokenAccountPubKey = new PublicKey(tokenAccountPublicKey);
      const balance = await connection.getTokenAccountBalance(tokenAccountPubKey);

      if (!balance.value) {
          console.log(`Could not find token account: ${tokenAccountPublicKey}`);
          return;
      }

      console.log(`Token Account: ${tokenAccountPublicKey}`);
      console.log(`Raw Amount: ${balance.value.amount}`);
      console.log(`Decimals: ${balance.value.decimals}`);
      console.log(`UI Amount (string): ${balance.value.uiAmountString}`);
      // console.log(JSON.stringify(balance, null, 2)); // For full response details

    } catch (error) {
      console.error(`Error fetching token account balance for ${tokenAccountPublicKey}:`, error);
    }
  }

  // Replace with an actual SPL Token Account Public Key
  const exampleTokenAccount = 'HHisAGTT6ADDd52jY1g65Akn3N2f4jSdQS2rTiyDEw5c'; // Example: An account holding some USDC on mainnet
  checkTokenBalance(exampleTokenAccount);

  // Example for a token account that might not exist or have 0 balance
  // const nonExistentAccount = '11111111111111111111111111111111'; 
  // checkTokenBalance(nonExistentAccount);
  ```
</CodeGroup>

## Developer Tips

* **Token Account vs. Mint Account vs. Owner Account:** Ensure you are providing the public key of the *SPL Token Account*, not the token's *mint address* or the *owner's wallet address*. You typically get token accounts for an owner using `getTokenAccountsByOwner`.
* **Decimals:** Always use the `decimals` field to correctly interpret the `amount`. The `uiAmountString` is generally safer for display than `uiAmount` to avoid floating-point precision issues.
* **Non-Existent Accounts:** If the provided public key does not correspond to an existing token account, the behavior might vary slightly by RPC provider or library, but often the `value` in the response will be `null` or an error will be thrown. The JavaScript example includes a basic check for `balance.value`.
* **Commitment Levels:** Using different commitment levels can affect how quickly you see balance changes, especially for very recent transactions. `finalized` is the safest but has the most latency.

This guide should help you accurately retrieve and interpret SPL token balances using the `getTokenAccountBalance` method.


# How to Use getTokenAccountsByDelegate
Source: https://www.helius.dev/docs/rpc/guides/gettokenaccountsbydelegate

Learn getTokenAccountsByDelegate use cases, code examples, request parameters, response structure, and tips.

The [`getTokenAccountsByDelegate`](https://www.helius.dev/docs/api-reference/rpc/http/gettokenaccountsbydelegate) RPC method retrieves all SPL Token accounts that have approved a specific public key as a delegate. A delegate has authority to perform certain actions on the token account, such as transferring or burning tokens, up to the delegated amount.

This method is useful for services that manage delegated authority or need to discover which token accounts a particular key can act on behalf of.

## Common Use Cases

* **Listing Delegated Assets:** Displaying all token accounts for which a specific wallet or program has been granted delegate authority.
* **Automated Token Management:** Services that perform actions on behalf of users (e.g., automated market makers, staking protocols that manage tokenized rewards) can use this to find accounts they are authorized to interact with.
* **Auditing Delegations:** Reviewing which accounts have delegated authority to a particular address.
* **Revoking Delegations:** Identifying token accounts from which delegate authority needs to be revoked (though the revocation itself is a separate transaction).

## Request Parameters

1. **`delegatePubkey`** (string, required): The base-58 encoded public key of the delegate account whose associated token accounts you want to find.

2. **`filter`** (object, required): A JSON object that **must** specify either `mint` or `programId` to filter the accounts:
   * **`mint`** (string): The base-58 encoded public key of a specific token mint. If provided, the query will only return token accounts of this particular token type that are delegated to `delegatePubkey`.
   * **`programId`** (string): The base-58 encoded public key of the Token Program that owns the accounts. This will typically be the standard SPL Token Program (`TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA`) or the Token-2022 Program (`TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb`).

3. **`options`** (object, optional): An optional configuration object with the following common fields:
   * **`commitment`** (string, optional): Specifies the [commitment level](https://www.helius.dev/blog/solana-commitment-levels).
   * **`encoding`** (string, optional): The encoding for account data. `"jsonParsed"` is highly recommended as it returns human-readable account information. Other options include `"base64"`, `"base64+zstd"`. Defaults to `"base64"` if not specified.
   * **`dataSlice`** (object, optional): Allows you to retrieve only a specific slice of the account data. Contains `offset` (usize) and `length` (usize) fields. Only applicable for `base58`, `base64`, or `base64+zstd` encodings.
   * **`minContextSlot`** (u64, optional): The minimum slot that the request can be evaluated at.

## Response Structure

The `result.value` field in the JSON-RPC response is an array of objects. Each object represents a token account that has `delegatePubkey` as its delegate and matches the `filter` criteria. Each object in the array has two fields:

* **`pubkey`** (string): The base-58 encoded public key of the token account itself.
* **`account`** (object): An object containing detailed information about the token account:
  * **`lamports`** (u64): The lamport balance of the token account (for rent exemption).
  * **`owner`** (string): The public key of the program that owns this account (e.g., the Token Program).
  * **`data`**: The account data. If `"jsonParsed"` encoding is used, this will be an object with a `program` field (e.g., `"spl-token"`) and a `parsed` field containing structured information:
    * **`parsed.info`**: An object with details like:
      * **`mint`** (string): The mint address of the token.
      * **`owner`** (string): The owner of the token account (not the delegate).
      * **`tokenAmount`** (object): The total balance of tokens in this account (`amount`, `decimals`, `uiAmount`, `uiAmountString`).
      * **`delegate`** (string): The public key of the delegate (should match the `delegatePubkey` from the request).
      * **`delegatedAmount`** (object): The amount of tokens the delegate is authorized to manage (`amount`, `decimals`, `uiAmount`, `uiAmountString`).
      * **`isNative`** (boolean): Indicates if the account holds wrapped SOL.
      * **`state`** (string): The state of the token account (e.g., `"initialized"`).
    * **`parsed.type`** (string): The type of the account (e.g., `"account"`).
  * **`executable`** (boolean): Whether the account is executable.
  * **`rentEpoch`** (u64): The epoch at which this account will next owe rent.
  * **`space`** (u64, if `jsonParsed` is not used): The length of the raw account data in bytes.

**Example Response (with `jsonParsed` encoding):**

```json
{
  "jsonrpc": "2.0",
  "result": {
    "context": {
      "slot": 183458000
    },
    "value": [
      {
        "pubkey": "SomeTokenAccountPubkey1...",
        "account": {
          "data": {
            "program": "spl-token",
            "parsed": {
              "info": {
                "delegate": "DelegatePubkeyProvidedInRequest...",
                "delegatedAmount": {
                  "amount": "1000000000",
                  "decimals": 9,
                  "uiAmount": 1.0,
                  "uiAmountString": "1.0"
                },
                "isNative": false,
                "mint": "TokenMintPubkey...",
                "owner": "ActualOwnerOfTheTokenAccount...",
                "state": "initialized",
                "tokenAmount": {
                  "amount": "5000000000",
                  "decimals": 9,
                  "uiAmount": 5.0,
                  "uiAmountString": "5.0"
                }
              },
              "type": "account"
            },
            "space": 165
          },
          "executable": false,
          "lamports": 2039280,
          "owner": "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA", // SPL Token Program
          "rentEpoch": 382
        }
      }
      // ... potentially other token accounts delegated to the same delegate
    ]
  },
  "id": 1
}
```

## Code Examples

<CodeGroup>
  ```bash cURL
  # Replace <DELEGATE_PUBKEY> and <TOKEN_MINT_PUBKEY> or <TOKEN_PROGRAM_ID>
  # Example using programId (SPL Token Program)
  curl -X POST -H "Content-Type: application/json" -d \
    '{
      "jsonrpc": "2.0",
      "id": 1,
      "method": "getTokenAccountsByDelegate",
      "params": [
        "<DELEGATE_PUBKEY>",
        { "programId": "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA" },
        { "encoding": "jsonParsed" }
      ]
    }' \
    <YOUR_RPC_URL>

  # Example using a specific mint
  curl -X POST -H "Content-Type: application/json" -d \
    '{
      "jsonrpc": "2.0",
      "id": 1,
      "method": "getTokenAccountsByDelegate",
      "params": [
        "<DELEGATE_PUBKEY>",
        { "mint": "<TOKEN_MINT_PUBKEY>" },
        { "encoding": "jsonParsed", "commitment": "confirmed" }
      ]
    }' \
    <YOUR_RPC_URL>
  ```

  ```javascript JavaScript (using @solana/web3.js)
  const { Connection, PublicKey } = require('@solana/web3.js');

  async function findDelegatedAccounts(delegateAddress, filter, encoding = 'jsonParsed') {
    // Replace with your RPC endpoint
    const connection = new Connection('https://mainnet.helius-rpc.com/?api-key=<api-key>');
    const delegatePubKey = new PublicKey(delegateAddress);

    try {
      let actualFilter;
      if (filter.mint) {
        actualFilter = { mint: new PublicKey(filter.mint) };
      } else if (filter.programId) {
        actualFilter = { programId: new PublicKey(filter.programId) };
      } else {
        console.error("Filter must contain either 'mint' or 'programId'");
        return;
      }

      const accounts = await connection.getTokenAccountsByDelegate(
        delegatePubKey,
        actualFilter,
        { encoding }
      );

      console.log(`Found ${accounts.value.length} token accounts delegated to ${delegateAddress}:`);
      accounts.value.forEach(accInfo => {
        console.log(`  Token Account: ${accInfo.pubkey.toBase58()}`);
        if (encoding === 'jsonParsed' && accInfo.account.data.parsed) {
          console.log(`    Mint: ${accInfo.account.data.parsed.info.mint}`);
          console.log(`    Owner: ${accInfo.account.data.parsed.info.owner}`);
          console.log(`    Delegated Amount: ${accInfo.account.data.parsed.info.delegatedAmount.uiAmountString}`);
        }
        // console.log(JSON.stringify(accInfo.account.data, null, 2)); // For full data
      });

    } catch (error) {
      console.error(`Error fetching token accounts by delegate for ${delegateAddress}:`, error);
    }
  }

  // Replace with an actual delegate public key
  const exampleDelegate = '4Nd1mBQtrMJVYVfKf2PJy9NZUZdTAsp7D4xWLs4gDB4T'; 

  // Example 1: Find all SPL Token program accounts delegated to `exampleDelegate`
  findDelegatedAccounts(exampleDelegate, { programId: 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA' });

  // Example 2: Find accounts for a specific mint (e.g., USDC) delegated to `exampleDelegate`
  // const usdcMint = 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v';
  // findDelegatedAccounts(exampleDelegate, { mint: usdcMint });
  ```
</CodeGroup>

## Developer Tips

* **Filter Requirement:** You *must* provide either `mint` or `programId` in the filter parameter. You cannot query for all delegated accounts across all token types without one of these filters.
* **Encoding:** Using `"jsonParsed"` for the `encoding` option is highly recommended for easier data handling, as it decodes the binary account data into a structured JSON format.
* **Performance:** Querying with `programId` can be more resource-intensive than querying with `mint`, especially if the delegate has authority over many different token types. Some RPC providers may have stricter rate limits for this method.
* **Delegated Amount:** The `delegatedAmount` in the response indicates the maximum number of tokens the delegate is currently authorized to use. This can be less than the total `tokenAmount` in the account.
* **Revoking Delegation:** This method only retrieves information. To revoke a delegation, the owner of the token account must send a `Revoke` instruction to the SPL Token Program.

This guide provides a comprehensive overview of using `getTokenAccountsByDelegate` to find SPL Token accounts based on their approved delegate.


# How to Use getTokenAccountsByOwner
Source: https://www.helius.dev/docs/rpc/guides/gettokenaccountsbyowner

Learn getTokenAccountsByOwner use cases, code examples, request parameters, response structure, and tips.

The [`getTokenAccountsByOwner`](https://www.helius.dev/docs/api-reference/rpc/http/gettokenaccountsbyowner) RPC method is used to retrieve all SPL [Token accounts](https://www.helius.dev/blog/how-to-get-token-holders-on-solana) owned by a specific public key. This is a fundamental method for wallets and applications that need to display a user's token holdings or interact with their various token accounts.

You must filter the query by either a specific token `mint` or a `programId` (e.g., the SPL Token Program or Token-2022 Program).

## Common Use Cases

* **Displaying User Portfolio:** Fetching all token accounts (and thus balances) for a given user's wallet address to show their complete token portfolio.
* **Application Logic:** Identifying a user's specific token account for a particular mint before initiating a transfer or other interaction.
* **Verification:** Checking which token accounts an owner possesses for a certain type of token.
* **Indexing Token Holders:** While less efficient for global indexing than other methods, it can be used to find accounts for a known set of owners.

## Request Parameters

1. **`ownerPubkey`** (string, required): The base-58 encoded public key of the account owner whose token accounts you want to retrieve.

2. **`filter`** (object, required): A JSON object that **must** specify either `mint` or `programId`:
   * **`mint`** (string): The base-58 encoded public key of a specific token mint. If provided, only token accounts for this mint owned by `ownerPubkey` will be returned.
   * **`programId`** (string): The base-58 encoded public key of the Token Program that governs the accounts. Common values are:
     * SPL Token Program: `TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA`
     * Token-2022 Program: `TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb`

3. **`options`** (object, optional): An optional configuration object that can include:
   * **`commitment`** (string, optional): Specifies the [commitment level](https://www.helius.dev/blog/solana-commitment-levels).
   * **`encoding`** (string, optional): The encoding for account data. `"jsonParsed"` is highly recommended. Other options: `"base64"`, `"base64+zstd"`. Defaults to `"base64"`.
   * **`dataSlice`** (object, optional): To retrieve a specific slice of the account data (`offset`: usize, `length`: usize). Only for `base58`, `base64`, or `base64+zstd` encodings.
   * **`minContextSlot`** (u64, optional): The minimum slot for the query.

## Response Structure

The `result.value` field in the JSON-RPC response is an array of objects. Each object corresponds to an SPL Token account owned by `ownerPubkey` and matching the `filter`.

Each object in the `value` array contains:

* **`pubkey`** (string): The base-58 encoded public key of the token account itself.
* **`account`** (object): Detailed information about the token account:
  * **`lamports`** (u64): Lamport balance for rent exemption.
  * **`owner`** (string): The owning program (e.g., the Token Program public key).
  * **`data`**: Account data. If `"jsonParsed"` encoding is used, this contains:
    * **`program`** (string): e.g., `"spl-token"`.
    * **`parsed`**: An object with structured information:
      * **`info`**: Details such as:
        * **`mint`** (string): The mint address of the token.
        * **`owner`** (string): The owner of the token account (this should match `ownerPubkey` from the request).
        * **`tokenAmount`** (object): The balance of tokens (`amount`, `decimals`, `uiAmount`, `uiAmountString`).
        * **`state`** (string): State of the token account (e.g., `"initialized"`).
        * **`isNative`** (boolean): If the account holds wrapped SOL.
        * **`delegate`** (string, optional): The delegate address if one is set.
        * **`delegatedAmount`** (object, optional): The delegated amount if a delegate is set.
      * **`type`** (string): e.g., `"account"`.
  * **`executable`** (boolean): Whether the account is executable.
  * **`rentEpoch`** (u64): Next epoch rent is due.
  * **`space`** (u64, if not `jsonParsed`): Length of raw account data in bytes.

**Example Response (with `jsonParsed` encoding, filtered by `programId`):**

```json
{
  "jsonrpc": "2.0",
  "result": {
    "context": {
      "slot": 183459000
    },
    "value": [
      {
        "pubkey": "AssociatedTokenAccountPubkey1...",
        "account": {
          "data": {
            "program": "spl-token",
            "parsed": {
              "info": {
                "isNative": false,
                "mint": "SomeTokenMintPubkey...",
                "owner": "OwnerPubkeyProvidedInRequest...",
                "state": "initialized",
                "tokenAmount": {
                  "amount": "1000000000", // 1 token if decimals is 9
                  "decimals": 9,
                  "uiAmount": 1.0,
                  "uiAmountString": "1.0"
                }
              },
              "type": "account"
            },
            "space": 165
          },
          "executable": false,
          "lamports": 2039280,
          "owner": "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA",
          "rentEpoch": 380
        }
      },
      {
        "pubkey": "AnotherAssociatedTokenAccountPubkey...",
        "account": {
          // ... similar structure for another token owned by the same owner
        }
      }
    ]
  },
  "id": 1
}
```

## Code Examples

<CodeGroup>
  ```bash cURL
  # Replace <OWNER_PUBKEY> and <TOKEN_MINT_PUBKEY> or <TOKEN_PROGRAM_ID>

  # Example filtering by programId (SPL Token Program)
  curl -X POST -H "Content-Type: application/json" -d \
    '{
      "jsonrpc": "2.0",
      "id": 1,
      "method": "getTokenAccountsByOwner",
      "params": [
        "<OWNER_PUBKEY>",
        { "programId": "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA" },
        { "encoding": "jsonParsed" }
      ]
    }' \
    <YOUR_RPC_URL>

  # Example filtering by a specific mint
  curl -X POST -H "Content-Type: application/json" -d \
    '{
      "jsonrpc": "2.0",
      "id": 1,
      "method": "getTokenAccountsByOwner",
      "params": [
        "<OWNER_PUBKEY>",
        { "mint": "<SPECIFIC_TOKEN_MINT_PUBKEY>" },
        { "encoding": "jsonParsed", "commitment": "confirmed" }
      ]
    }' \
    <YOUR_RPC_URL>
  ```

  ```javascript JavaScript (using @solana/web3.js)
  const { Connection, PublicKey } = require('@solana/web3.js');

  async function findOwnerTokenAccounts(ownerAddress, filter, encoding = 'jsonParsed') {
    // Replace with your RPC endpoint
    const connection = new Connection('https://mainnet.helius-rpc.com/?api-key=<api-key>');
    const ownerPubKey = new PublicKey(ownerAddress);

    try {
      let actualFilter;
      if (filter.mint) {
        actualFilter = { mint: new PublicKey(filter.mint) };
      } else if (filter.programId) {
        actualFilter = { programId: new PublicKey(filter.programId) };
      } else {
        console.error("Filter must contain either 'mint' or 'programId'");
        return;
      }

      const accounts = await connection.getTokenAccountsByOwner(
        ownerPubKey,
        actualFilter,
        { encoding }
      );

      console.log(`Found ${accounts.value.length} token accounts for owner ${ownerAddress}:`);
      accounts.value.forEach(accInfo => {
        console.log(`  Token Account: ${accInfo.pubkey.toBase58()}`);
        if (encoding === 'jsonParsed' && accInfo.account.data.parsed) {
          console.log(`    Mint: ${accInfo.account.data.parsed.info.mint}`);
          console.log(`    Balance: ${accInfo.account.data.parsed.info.tokenAmount.uiAmountString}`);
        }
        // console.log(JSON.stringify(accInfo, null, 2)); // For full details
      });

    } catch (error) {
      console.error(`Error fetching token accounts for owner ${ownerAddress}:`, error);
    }
  }

  // Replace with an actual owner's public key
  const exampleOwner = 'HXtBm8XZbxaTt41uqaKhwUAa6Z1aPyvJdsZVENiWsetg'; // Example wallet address

  // Example 1: Find all SPL Token Program accounts owned by `exampleOwner`
  findOwnerTokenAccounts(exampleOwner, { programId: 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA' });

  // Example 2: Find USDC token accounts owned by `exampleOwner`
  // const usdcMint = 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v';
  // findOwnerTokenAccounts(exampleOwner, { mint: usdcMint });

  // Example 3: Find Token-2022 Program accounts owned by `exampleOwner`
  // findOwnerTokenAccounts(exampleOwner, { programId: 'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb' });
  ```
</CodeGroup>

## Developer Tips

* **Filter Requirement:** You *must* supply either a `mint` or a `programId` in the filter. It's not possible to query all token accounts for an owner across all token types without one of these primary filters.
* **Associated Token Accounts:** This method will return all token accounts owned by the public key, including standard Associated Token Accounts (ATAs) and any other SPL token accounts they might own (e.g., from older wallet implementations or custom setups).
* **Encoding:** Using `"jsonParsed"` for the `encoding` option is highly recommended. It decodes the binary account data into a more usable JSON structure.
* **Performance:** If an owner has a very large number of token accounts (especially when filtering only by `programId`), the response can be large. Consider pagination if your RPC provider or library supports it, or if you anticipate very large result sets, though this method itself doesn't directly support pagination in its standard parameters.
* **Token-2022 (Token Extensions):** If you are working with tokens created using the Token-2022 program (which supports extensions like transfer fees, interest, etc.), ensure you use the correct `programId`: `TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb`.

This guide provides a thorough understanding of the `getTokenAccountsByOwner` RPC method, enabling you to efficiently retrieve token account information for any Solana address.


# How to Use getTokenLargestAccounts
Source: https://www.helius.dev/docs/rpc/guides/gettokenlargestaccounts

Learn getTokenLargestAccounts use cases, code examples, request parameters, response structure, and tips.

The [`getTokenLargestAccounts`](https://www.helius.dev/docs/api-reference/rpc/http/gettokenlargestaccounts) RPC method returns a list of the 20 largest token accounts for a given SPL Token mint. This is useful for analyzing token distribution and identifying major holders of a particular token.

## Common Use Cases

* **Token Distribution Analysis:** Understanding how a token's supply is distributed among its holders.
* **Identifying Whales:** Finding accounts that hold significant amounts of a specific token.
* **Market Research:** Gauging the concentration of token ownership.
* **Displaying Top Holders:** Showing a list of the largest accounts in a token explorer or dashboard.

## Request Parameters

1. **`mintAddress`** (string, required): The base-58 encoded public key of the token mint for which you want to find the largest accounts.

2. **`options`** (object, optional): An optional configuration object that can include:
   * **`commitment`** (string, optional): Specifies the [commitment level](https://www.helius.dev/blog/solana-commitment-levels) for the query (e.g., `"finalized"`, `"confirmed"`, `"processed"`).

## Response Structure

The `result.value` field in the JSON-RPC response is an array of up to 20 objects. Each object represents one of the largest token accounts and contains the following fields:

* **`address`** (string): The base-58 encoded public key of the token account.
* **`amount`** (string): The raw balance of the token account, as a string. This value is not adjusted for decimals.
* **`decimals`** (u8): The number of decimal places defined for this token mint.
* **`uiAmount`** (number | null): The token balance as a floating-point number, adjusted for decimals. This field might be deprecated or less reliable; `uiAmountString` is preferred.
* **`uiAmountString`** (string): The token balance as a string, adjusted for decimals. This is the most user-friendly representation of the balance.

**Example Response:**

```json
{
  "jsonrpc": "2.0",
  "result": {
    "context": { "slot": 123456789 },
    "value": [
      {
        "address": "TokenAccountPubkey1...",
        "amount": "1000000000000", // e.g., 1,000,000 tokens with 6 decimals
        "decimals": 6,
        "uiAmount": 1000000.0,
        "uiAmountString": "1000000.0"
      },
      {
        "address": "TokenAccountPubkey2...",
        "amount": "500000000000",  // e.g., 500,000 tokens with 6 decimals
        "decimals": 6,
        "uiAmount": 500000.0,
        "uiAmountString": "500000.0"
      }
      // ... up to 18 more accounts
    ]
  },
  "id": 1
}
```

## Code Examples

<CodeGroup>
  ```bash cURL
  # Replace <TOKEN_MINT_PUBKEY> with the actual mint address
  curl -X POST -H "Content-Type: application/json" -d \
    '{
      "jsonrpc": "2.0",
      "id": 1,
      "method": "getTokenLargestAccounts",
      "params": [
        "<TOKEN_MINT_PUBKEY>"
      ]
    }' \
    <YOUR_RPC_URL>

  # Example with commitment level
  curl -X POST -H "Content-Type: application/json" -d \
    '{
      "jsonrpc": "2.0",
      "id": 1,
      "method": "getTokenLargestAccounts",
      "params": [
        "<TOKEN_MINT_PUBKEY>",
        { "commitment": "confirmed" }
      ]
    }' \
    <YOUR_RPC_URL>
  ```

  ```javascript JavaScript (using @solana/web3.js)
  const { Connection, PublicKey } = require('@solana/web3.js');

  async function getLargestTokenHolders(mintAddress) {
    // Replace with your RPC endpoint
    const connection = new Connection('https://mainnet.helius-rpc.com/?api-key=<api-key>');
    const mintPublicKey = new PublicKey(mintAddress);

    try {
      const largestAccounts = await connection.getTokenLargestAccounts(mintPublicKey);
      console.log(`Largest accounts for mint ${mintAddress}:`);
      largestAccounts.value.forEach(account => {
        console.log(`  Address: ${account.address}`);
        console.log(`    UI Amount: ${account.uiAmountString}`);
        console.log(`    Raw Amount: ${account.amount}`);
        console.log(`    Decimals: ${account.decimals}`);
      });
      // For full details:
      // console.log(JSON.stringify(largestAccounts, null, 2));
    } catch (error) {
      console.error(`Error fetching largest token accounts for mint ${mintAddress}:`, error);
    }
  }

  // Replace with the actual token mint public key you want to query
  const exampleTokenMint = 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v'; // USDC mint
  getLargestTokenHolders(exampleTokenMint);

  // Example with a different mint (e.g., Raydium)
  // const raydiumMint = '4k3Dyjzvzp8eMZWUXbBCjEvwSkkk59S5iCNLY3QrkX6R';
  // getLargestTokenHolders(raydiumMint);
  ```
</CodeGroup>

## Developer Tips

* **Fixed Limit:** This method always returns up to the top 20 largest accounts. It does not support pagination or requesting more than 20 accounts.
* **Data Accuracy:** The data reflects the state of the ledger at the slot determined by the specified commitment level.
* **Token Mint Specific:** The results are specific to the single token mint provided in the request.
* **Performance:** This is a targeted query and generally performs well. However, excessive polling should be avoided.

This guide helps you use the `getTokenLargestAccounts` RPC method to discover the primary holders of any SPL token on Solana.


# How to Use getTokenSupply
Source: https://www.helius.dev/docs/rpc/guides/gettokensupply

Learn getTokenSupply use cases, code examples, request parameters, response structure, and tips.

The [`getTokenSupply`](https://www.helius.dev/docs/api-reference/rpc/http/gettokensupply) RPC method returns the total supply of a specific SPL Token mint. This is essential for understanding the overall quantity of a token that has been created.

## Common Use Cases

* **Displaying Token Information:** Showing the total supply of a token on an explorer or in a wallet interface.
* **Tokenomics Analysis:** Understanding the maximum or current total issuance of a token.
* **Verification:** Checking the supply of a token as reported by the mint account itself.
* **Monitoring Supply Changes:** If a token is mintable, this can be used to track changes in its total supply over time (though for fungible tokens, the supply is usually fixed or managed by a minting authority).

## Request Parameters

1. **`mintAddress`** (string, required): The base-58 encoded public key of the token mint whose total supply you want to query.

2. **`options`** (object, optional): An optional configuration object that can include:
   * **`commitment`** (string, optional): Specifies the [commitment level](https://www.helius.dev/blog/solana-commitment-levels) for the query (e.g., `"finalized"`, `"confirmed"`, `"processed"`).

## Response Structure

The `result.value` field in the JSON-RPC response is an object containing details about the token's supply:

* **`amount`** (string): The total supply of the token in its smallest denomination (raw amount), as a string. This value is not adjusted for decimals.
* **`decimals`** (u8): The number of decimal places defined for this token mint. This is crucial for converting the raw `amount` to a human-readable format.
* **`uiAmount`** (number | null): The total supply of the token as a floating-point number, adjusted for the token's `decimals`. This field might be null or less precise; `uiAmountString` is generally preferred for display.
* **`uiAmountString`** (string): The total supply of the token as a string, adjusted for the token's `decimals`. This is the most user-friendly representation of the total supply.

**Example Response:**

```json
{
  "jsonrpc": "2.0",
  "result": {
    "context": { "slot": 123456789 },
    "value": {
      "amount": "1000000000000000", // e.g., 1,000,000,000 tokens with 6 decimals
      "decimals": 6,
      "uiAmount": 1000000000.0,
      "uiAmountString": "1000000000.0"
    }
  },
  "id": 1
}
```

## Code Examples

<CodeGroup>
  ```bash cURL
  # Replace <TOKEN_MINT_PUBKEY> with the actual mint address
  curl -X POST -H "Content-Type: application/json" -d \
    '{
      "jsonrpc": "2.0",
      "id": 1,
      "method": "getTokenSupply",
      "params": [
        "<TOKEN_MINT_PUBKEY>"
      ]
    }' \
    <YOUR_RPC_URL>

  # Example with commitment level
  curl -X POST -H "Content-Type: application/json" -d \
    '{
      "jsonrpc": "2.0",
      "id": 1,
      "method": "getTokenSupply",
      "params": [
        "<TOKEN_MINT_PUBKEY>",
        { "commitment": "confirmed" }
      ]
    }' \
    <YOUR_RPC_URL>
  ```

  ```javascript JavaScript (using @solana/web3.js)
  const { Connection, PublicKey } = require('@solana/web3.js');

  async function checkTokenSupply(mintAddress) {
    // Replace with your RPC endpoint
    const connection = new Connection('https://mainnet.helius-rpc.com/?api-key=<api-key>');
    const mintPublicKey = new PublicKey(mintAddress);

    try {
      const tokenSupply = await connection.getTokenSupply(mintPublicKey);
      console.log(`Token Supply for Mint ${mintAddress}:`);
      console.log(`  UI Amount: ${tokenSupply.value.uiAmountString}`);
      console.log(`  Raw Amount: ${tokenSupply.value.amount}`);
      console.log(`  Decimals: ${tokenSupply.value.decimals}`);
      // For full details:
      // console.log(JSON.stringify(tokenSupply, null, 2));
    } catch (error) {
      console.error(`Error fetching token supply for mint ${mintAddress}:`, error);
    }
  }

  // Replace with the actual token mint public key you want to query
  const exampleTokenMint = 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v'; // USDC mint
  checkTokenSupply(exampleTokenMint);

  // Example with a different mint (e.g., Raydium)
  // const raydiumMint = '4k3Dyjzvzp8eMZWUXbBCjEvwSkkk59S5iCNLY3QrkX6R';
  // checkTokenSupply(raydiumMint);
  ```
</CodeGroup>

## Developer Tips

* **Immutable Supply (Usually):** For most SPL tokens, once minted, the total supply from the perspective of the mint account itself is fixed unless the mint has a specific minting authority that can create more tokens (or burn them, though burning typically happens from token accounts, not the mint's supply directly).
* **`decimals` is Key:** Always use the `decimals` field to correctly interpret the `amount` or `uiAmountString`.
* **Data Source:** This method queries the mint account directly for its supply information.

This guide provides the necessary information to use the `getTokenSupply` RPC method effectively for querying SPL token supply on Solana.


# How to Use getTransaction
Source: https://www.helius.dev/docs/rpc/guides/gettransaction

Learn getTransaction use cases, code examples, request parameters, response structure, and tips.

The [`getTransaction`](https://www.helius.dev/docs/api-reference/rpc/http/gettransaction) RPC method allows you to retrieve detailed information about a confirmed transaction by providing its signature. This includes the transaction's slot, block time, metadata (like fees, status, and balance changes), and the transaction structure itself.

## Common Use Cases

* **Transaction Verification:** Confirming that a transaction has been processed and checking its outcome (success or failure).
* **Transaction History Display:** Showing users the details of their past transactions in a wallet or explorer.
* **Auditing and Analysis:** Examining the specifics of a transaction, including instructions executed, fees paid, and accounts involved.
* **Debugging Failed Transactions:** Inspecting `logMessages` and `err` fields in the metadata to understand why a transaction failed.
* **Data Indexing:** Extracting specific information from transactions for off-chain storage and analysis.

## Request Parameters

1. **`transactionSignature`** (string, required): The base-58 encoded transaction signature you want to query.

2. **`options`** (object, optional): An optional configuration object that can include:
   * **`commitment`** (string, optional): Specifies the [commitment level](https://www.helius.dev/blog/solana-commitment-levels) (e.g., `"finalized"`, `"confirmed"`). If not provided, the node's default commitment is used (usually `"finalized"`).
   * **`encoding`** (string, optional): The encoding for the `transaction` data. Common values:
     * `"json"`: Returns the transaction data in a structured JSON format (but instructions might still be base64 encoded).
     * `"jsonParsed"`: Returns the transaction data with program-specific instructions parsed into a human-readable JSON structure where possible. This is often the most useful encoding for analysis.
     * `"base58"`: Returns the transaction data as a base-58 encoded string.
     * `"base64"`: Returns the transaction data as a base-64 encoded string.
     * Defaults to `"json"` if not specified by Helius, but Solana default might be different. It's best to specify this.
   * **`maxSupportedTransactionVersion`** (number, optional): The maximum transaction version the RPC endpoint should process.
     * Set to `0` to include versioned transactions (including legacy).
     * If omitted, some nodes might only return legacy transactions or error if versioned transactions are encountered. It is highly recommended to set this to `0` to support all transaction types.

## Response Structure

The method returns `null` if the transaction is not found (e.g., not yet processed or signature is incorrect) or not confirmed to the specified commitment level. Otherwise, it returns an object with the following fields:

* **`slot`** (u64): The slot number in which the transaction was included in a block.
* **`blockTime`** (i64 | null): The estimated Unix timestamp (seconds since epoch) when the block containing the transaction was produced. Can be `null` if not available.
* **`meta`** (object | null): An object containing metadata about the transaction's execution. Can be `null` if the transaction failed before being processed or if metadata is unavailable.
  * **`err`** (object | null): An error object if the transaction failed, otherwise `null`.
  * **`fee`** (u64): The fee in lamports paid for the transaction.
  * **`preBalances`** (array of u64): Lamport balances of accounts involved *before* the transaction was processed.
  * **`postBalances`** (array of u64): Lamport balances of accounts involved *after* the transaction was processed.
  * **`preTokenBalances`** (array of objects | null): Token balances of token accounts involved *before* the transaction.
  * **`postTokenBalances`** (array of objects | null): Token balances of token accounts involved *after* the transaction.
  * **`innerInstructions`** (array of objects | null): An array of instructions executed as part of CPI (Cross-Program Invocations) within this transaction.
  * **`logMessages`** (array of string | null): An array of log messages emitted by the transaction's instructions and any inner instructions.
  * **`loadedAddresses`** (object, optional): Specifies the accounts loaded from address lookup tables for this transaction. Contains `writable` and `readonly` arrays of public keys.
  * **`returnData`** (object, optional): Data returned by the transaction via `sol_set_return_data` and `sol_get_return_data`. Contains `programId` (string) and `data` (array: `[string, encoding]`).
  * **`computeUnitsConsumed`** (u64, optional): The number of compute units consumed by this transaction.
* **`transaction`** (object | array): The transaction structure itself. The format depends on the `encoding` parameter:
  * If `encoding` is `"jsonParsed"` or `"json"`: An object with `message` (containing `accountKeys`, `instructions`, `recentBlockhash`, etc.) and `signatures` (array of strings).
  * If `encoding` is `"base58"`, `"base64"`: An array `[encoded_string, encoding_format_string]`.
* **`version`** ("legacy" | number | undefined): The version of the transaction. Can be `"legacy"` for older transactions or a number (e.g., `0`) for versioned transactions. `undefined` if `maxSupportedTransactionVersion` is not set and the transaction is versioned.

**Example Response (`jsonParsed` encoding):**

```json
{
  "jsonrpc": "2.0",
  "result": {
    "blockTime": 1635900000,
    "meta": {
      "err": null,
      "fee": 5000,
      "innerInstructions": [],
      "logMessages": [
        "Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS invoke [1]",
        "Program log: Memo 'Hello, Solana!'",
        "Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS success"
      ],
      "postBalances": [
        499999999999994999, 
        1000000000
      ],
      "postTokenBalances": [],
      "preBalances": [
        500000000000000000, 
        1000000000
      ],
      "preTokenBalances": [],
      "rewards": [],
      "status": { "Ok": null },
      "computeUnitsConsumed": 200
    },
    "slot": 98765432,
    "transaction": {
      "message": {
        "accountKeys": [
          "SysvarRent111111111111111111111111111111111",
          "Vote111111111111111111111111111111111111111"
        ],
        "instructions": [
          {
            "parsed": {
              "type": "vote",
              "info": {
                "votePubkey": "Vote111111111111111111111111111111111111111",
                "slot": 123,
                "hash": "abc..."
              }
            },
            "program": "vote",
            "programId": "Vote111111111111111111111111111111111111111"
          }
        ],
        "recentBlockhash": "xyz..."
      },
      "signatures": [
        "sig1..."
      ]
    },
    "version": "legacy"
  },
  "id": 1
}
```

## Code Examples

<CodeGroup>
  ```bash cURL
  # Replace <TRANSACTION_SIGNATURE> with an actual signature
  curl -X POST -H "Content-Type: application/json" -d \
    '{
      "jsonrpc": "2.0",
      "id": 1,
      "method": "getTransaction",
      "params": [
        "<TRANSACTION_SIGNATURE>",
        {
          "encoding": "jsonParsed",
          "maxSupportedTransactionVersion": 0
        }
      ]
    }' \
    <YOUR_RPC_URL>
  ```

  ```javascript JavaScript (using @solana/web3.js)
  const { Connection } = require('@solana/web3.js');

  async function getTransactionDetails(signature) {
    // Replace with your RPC endpoint
    const connection = new Connection('https://mainnet.helius-rpc.com/?api-key=<api-key>');

    try {
      const transaction = await connection.getTransaction(signature, {
        maxSupportedTransactionVersion: 0, // Recommended to support all transaction versions
        // commitment: 'confirmed', // Optional: specify commitment level
      });

      if (transaction) {
        console.log('Transaction Details:');
        console.log(`  Slot: ${transaction.slot}`);
        console.log(`  Block Time: ${transaction.blockTime ? new Date(transaction.blockTime * 1000).toLocaleString() : 'N/A'}`);
        console.log(`  Fee: ${transaction.meta ? transaction.meta.fee : 'N/A'} lamports`);
        console.log(`  Status: ${transaction.meta && transaction.meta.err ? 'Failed' : 'Success'}`);
        if (transaction.meta && transaction.meta.err) {
          console.log(`    Error: ${JSON.stringify(transaction.meta.err)}`);
        }
        // console.log(JSON.stringify(transaction, null, 2)); // Log full transaction details

        if (transaction.meta && transaction.meta.logMessages) {
          console.log('  Log Messages:');
          transaction.meta.logMessages.forEach(log => console.log(`    ${log}`));
        }

      } else {
        console.log('Transaction not found or not confirmed.');
      }
    } catch (error) {
      console.error(`Error fetching transaction ${signature}:`, error);
    }
  }

  // Replace with an actual transaction signature from Mainnet-beta or your test environment
  const exampleSignature = '5h4zCwobYsdL3mY26FgfXy8c4rTPkX6gYVXW8w2tTjCXZMWzE9jX9p8Q2Y8Yj9p8ZQ8Yj9p8ZQ8Yj9p8ZQ8Yj9'; // Replace with a real signature
  // getTransactionDetails(exampleSignature);

  // Example of a known transaction (you'll need to find a recent one on an explorer)
  // getTransactionDetails('2xNdnHjZDmJRy1L6jC1mF87K3V9nXZo2bY6vA8GzQ3T7bS9xU8cM7sR5eD3fG2hJ1aB0cE9lK6mN5pP4qR7');

  console.log("Please replace 'exampleSignature' with a real transaction signature to run the example.");

  ```
</CodeGroup>

## Developer Tips

* **Transaction Finality:** Ensure you query with an appropriate `commitment` level. Requesting a transaction that hasn't reached the specified commitment will result in `null`.
* **Data Volume:** The response object can be very large, especially for complex transactions with many instructions or detailed logging. Be mindful of this when processing the data.
* **`jsonParsed` vs. `json`:** While `jsonParsed` is very convenient, parsing support depends on the RPC node's capabilities for specific programs. If a program is not recognized, its instructions might fall back to a less parsed format even with `jsonParsed`.
* **Versioned Transactions:** Always set `maxSupportedTransactionVersion: 0` in your request options to ensure your application can handle both legacy and versioned transactions. Otherwise, you might miss data or encounter errors for newer transaction formats.
* **RPC Provider Differences:** While the core API is standard, some RPC providers might offer enhanced parsing or additional fields. Helius, for example, provides rich transaction parsing.

This guide provides a comprehensive overview of the `getTransaction` RPC method, empowering you to fetch and understand detailed Solana transaction data.


# How to Use getTransactionCount
Source: https://www.helius.dev/docs/rpc/guides/gettransactioncount

Learn getTransactionCount use cases, code examples, request parameters, response structure, and tips.

The [`getTransactionCount`](https://www.helius.dev/docs/api-reference/rpc/http/gettransactioncount) RPC method returns the current total number of transactions processed by the Solana ledger since genesis, at a specified commitment level.

## Common Use Cases

* **Network Statistics:** Displaying the overall transaction volume on the network as a general health or activity indicator.
* **Growth Tracking:** Monitoring the increase in transaction count over time to observe network adoption and usage trends.
* **Dashboard Metrics:** Providing a high-level overview of blockchain activity.

## Request Parameters

This method has one optional parameter:

1. **`options`** (object, optional): An optional configuration object that can include:
   * **`commitment`** (string, optional): Specifies the [commitment level](https://www.helius.dev/blog/solana-commitment-levels) for the query (e.g., `"finalized"`, `"confirmed"`, `"processed"`). If not provided, the node's default commitment is used.
   * **`minContextSlot`** (u64, optional): The minimum slot that the request can be evaluated at.

## Response Structure

The `result` field in the JSON-RPC response is a single `u64` number representing the total transaction count from the ledger up to the slot determined by the commitment level.

**Example Response:**

```json
{
  "jsonrpc": "2.0",
  "result": 398146706879,
  "id": 1
}
```

## Code Examples

<CodeGroup>
  ```bash cURL
  # Basic Request (uses default commitment of the RPC node):
  curl -X POST -H "Content-Type: application/json" -d \
    '{
      "jsonrpc": "2.0",
      "id": 1,
      "method": "getTransactionCount"
    }' \
    <YOUR_RPC_URL>

  # Request with a specific commitment level:
  curl -X POST -H "Content-Type: application/json" -d \
    '{
      "jsonrpc": "2.0",
      "id": 1,
      "method": "getTransactionCount",
      "params": [
        {
          "commitment": "confirmed"
        }
      ]
    }' \
    <YOUR_RPC_URL>
  ```

  ```javascript JavaScript (using @solana/web3.js)
  const { Connection } = require('@solana/web3.js');

  async function getCurrentTransactionCount() {
    // Replace with your RPC endpoint
    const connection = new Connection('https://mainnet.helius-rpc.com/?api-key=<api-key>');

    try {
      const transactionCount = await connection.getTransactionCount();
      console.log(`Current ledger transaction count: ${transactionCount}`);

      // Example with commitment
      const confirmedTransactionCount = await connection.getTransactionCount('confirmed');
      console.log(`Current ledger transaction count (confirmed): ${confirmedTransactionCount}`);

    } catch (error) {
      console.error('Error fetching transaction count:', error);
    }
  }

  getCurrentTransactionCount();
  ```
</CodeGroup>

## Developer Tips

* **Ledger-Wide Count:** This count represents all transactions processed on the ledger since its inception, not just for a specific account or block.
* **Increasing Value:** The transaction count is a monotonically increasing value.
* **Commitment Level:** The returned count depends on the chosen `commitment` level. A `processed` commitment will likely yield a higher, more up-to-the-second count than `finalized`, but `finalized` offers a guarantee against rollbacks.
* **Not a TPS Metric:** While related to network activity, this single value doesn't directly translate to Transactions Per Second (TPS) without comparing counts over a defined time period.

This guide explains how to use the `getTransactionCount` RPC method to retrieve the total number of transactions on the Solana network.


# How to Use getVersion
Source: https://www.helius.dev/docs/rpc/guides/getversion

Learn getVersion use cases, code examples, request parameters, response structure, and tips.

The [`getVersion`](https://www.helius.dev/docs/api-reference/rpc/http/getversion) RPC method returns the current Solana software version running on the queried RPC node. This includes the `solana-core` version string and a `feature-set` identifier.

This method is useful for verifying the version of a node you are interacting with or for diagnostic purposes.

## Common Use Cases

* **Node Version Verification:** Confirming the software version of an RPC node, which can be important for compatibility or to understand available features.
* **Network Monitoring:** Tools might periodically check versions of various nodes to get a sense of software distribution across the network (though `getClusterNodes` provides a more comprehensive view for this).
* **Troubleshooting:** Knowing the node version can be crucial when diagnosing issues or unexpected behavior.

## Request Parameters

This method does not take any parameters.

## Response Structure

The `result` field of the JSON-RPC response will be an object containing:

* **`solana-core`** (string): The version string of the Solana core software (e.g., "1.18.4").
* **`feature-set`** (u32): A numerical identifier for the set of features activated on the node.

**Example Response:**

```json
{
  "jsonrpc": "2.0",
  "result": {
    "solana-core": "1.18.4",
    "feature-set": 3595898949
  },
  "id": 1
}
```

## Code Examples

<CodeGroup>
  ```bash cURL
  curl -X POST -H "Content-Type: application/json" -d \
    '{
      "jsonrpc": "2.0",
      "id": 1,
      "method": "getVersion"
    }' \
    <YOUR_RPC_URL>
  ```

  ```javascript JavaScript (using @solana/web3.js)
  const { Connection } = require('@solana/web3.js');

  async function getNodeVersion() {
    // Replace with your RPC endpoint
    const connection = new Connection('https://mainnet.helius-rpc.com/?api-key=<api-key>');

    try {
      const versionInfo = await connection.getVersion();
      console.log('Node Version Information:');
      console.log(`  Solana Core: ${versionInfo['solana-core']}`);
      console.log(`  Feature Set: ${versionInfo['feature-set']}`);
    } catch (error) {
      console.error('Error fetching node version:', error);
    }
  }

  getNodeVersion();
  ```
</CodeGroup>

## Developer Tips

* **Simplicity:** This is one of the simplest RPC calls, useful for a quick check of the node's software.
* **Node Specific:** The version returned is specific to the RPC node you are querying. Different nodes in the cluster might be running slightly different versions, especially during upgrade periods.

This guide provides a clear overview of the `getVersion` RPC method, its use cases, and how to interpret its response.


# How to Use getVoteAccounts
Source: https://www.helius.dev/docs/rpc/guides/getvoteaccounts

Learn getVoteAccounts use cases, code examples, request parameters, response structure, and tips.

The [`getVoteAccounts`](https://www.helius.dev/docs/api-reference/rpc/http/getvoteaccounts) RPC method returns information about all voting accounts (validators) in the current bank. It distinguishes between `current` (active) and `delinquent` validators and provides details about their stake, voting activity, and identity.

## Common Use Cases

* **Validator Monitoring:** Tracking the status, stake, and performance of validators on the network.
* **Staking Dashboards:** Displaying information about available validators for users looking to delegate their SOL.
* **Network Health Analysis:** Assessing the overall health and decentralization of the network by examining the distribution of stake and validator activity.
* **Identifying Delinquent Validators:** Finding validators that are not actively participating in consensus.

## Request Parameters

This method accepts an optional configuration object with the following fields:

1. **`commitment`** (string, optional): Specifies the [commitment level](https://www.helius.dev/blog/solana-commitment-levels) for the query (e.g., `"finalized"`, `"confirmed"`, `"processed"`). If omitted, the node's default commitment is used.
2. **`votePubkey`** (string, optional): If provided, the results will be filtered to include only the specified validator vote account address (base-58 encoded).
3. **`keepUnstakedDelinquents`** (boolean, optional): Defaults to `false`. If set to `true`, the `delinquent` list will include validators with no activated stake. Otherwise, they are filtered out.
4. **`delinquentSlotDistance`** (u64, optional): Specifies how many slots a validator must be behind the tip of the ledger to be considered delinquent. If not specified, the node uses a default value.

## Response Structure

The `result` field in the JSON-RPC response is an object containing two arrays:

* **`current`**: An array of objects, where each object represents an active voting account with the following fields:
  * **`votePubkey`** (string): The vote account address (base-58 encoded).
  * **`nodePubkey`** (string): The identity public key of the validator node (base-58 encoded).
  * **`activatedStake`** (u64): The amount of stake, in lamports, delegated to this vote account and active in the current epoch.
  * **`epochVoteAccount`** (boolean): `true` if the vote account has been active at least once during the current epoch.
  * **`commission`** (number): The commission percentage (0-100) charged by the validator.
  * **`lastVote`** (u64): The most recent slot number this validator voted on.
  * **`rootSlot`** (u64): The last slot the node considered to be a root (a block that is fully confirmed and will not be rolled back).
  * **`epochCredits`** (array): An array of arrays, where each inner array contains `[epoch, credits_earned_in_epoch, previous_total_credits]`.
* **`delinquent`**: An array of objects, with the same structure as `current`, representing validators considered delinquent by the node.

**Example Response Snippet:**

```json
{
  "jsonrpc": "2.0",
  "result": {
    "current": [
      {
        "commission": 10,
        "epochCredits": [[300, 12345, 567890]],
        "epochVoteAccount": true,
        "lastVote": 180000500,
        "nodePubkey": "NodePubkeyExample123...",
        "rootSlot": 180000450,
        "activatedStake": "50000000000000", // lamports
        "votePubkey": "VoteAccountPubkeyExample123..."
      }
      // ... more current validators
    ],
    "delinquent": [
      // ... delinquent validators, if any
    ]
  },
  "id": 1
}
```

## Code Examples

<CodeGroup>
  ```bash cURL
  # Get all current and delinquent vote accounts:
  curl -X POST -H "Content-Type: application/json" -d \
    '{
      "jsonrpc": "2.0",
      "id": 1,
      "method": "getVoteAccounts"
    }' \
    <YOUR_RPC_URL>

  # Get a specific vote account:
  curl -X POST -H "Content-Type: application/json" -d \
    '{
      "jsonrpc": "2.0",
      "id": 1,
      "method": "getVoteAccounts",
      "params": [
        {
          "votePubkey": "<SPECIFIC_VOTE_ACCOUNT_PUBKEY>"
        }
      ]
    }' \
    <YOUR_RPC_URL>

  # Get vote accounts with "confirmed" commitment and keep unstaked delinquents:
  curl -X POST -H "Content-Type: application/json" -d \
    '{
      "jsonrpc": "2.0",
      "id": 1,
      "method": "getVoteAccounts",
      "params": [
        {
          "commitment": "confirmed",
          "keepUnstakedDelinquents": true
        }
      ]
    }' \
    <YOUR_RPC_URL>
  ```

  ```javascript JavaScript (using @solana/web3.js)
  const { Connection } = require('@solana/web3.js');

  async function fetchVoteAccounts() {
    // Replace with your RPC endpoint
    const connection = new Connection('https://mainnet.helius-rpc.com/?api-key=<api-key>');

    try {
      // Get all vote accounts
      const voteAccounts = await connection.getVoteAccounts();
      console.log(`Found ${voteAccounts.current.length} current validators.`);
      console.log(`Found ${voteAccounts.delinquent.length} delinquent validators.`);

      if (voteAccounts.current.length > 0) {
        console.log("\nFirst current validator details:");
        console.log(`  Vote Pubkey: ${voteAccounts.current[0].votePubkey}`);
        console.log(`  Node Pubkey: ${voteAccounts.current[0].nodePubkey}`);
        console.log(`  Activated Stake: ${voteAccounts.current[0].activatedStake} lamports`);
        console.log(`  Commission: ${voteAccounts.current[0].commission}%`);
        console.log(`  Last Vote: ${voteAccounts.current[0].lastVote}`);
        // console.log(JSON.stringify(voteAccounts.current[0], null, 2)); // For full details
      }

      // Get a specific vote account (replace with an actual vote account public key)
      // const specificVotePubkey = 'SPECIFIC_VOTE_ACCOUNT_PUBKEY';
      // const specificValidator = await connection.getVoteAccounts('confirmed', specificVotePubkey);
      // console.log(`\nDetails for ${specificVotePubkey}:`, JSON.stringify(specificValidator, null, 2));

    } catch (error) {
      console.error('Error fetching vote accounts:', error);
    }
  }

  fetchVoteAccounts();
  ```
</CodeGroup>

## Developer Tips

* **Large Response:** This method can return a large amount of data, especially on networks with many validators like Mainnet Beta. Be mindful of response size and processing time.
* **Delinquency Definition:** The definition of "delinquent" can depend on the `delinquentSlotDistance` and the node's perspective. A validator might appear delinquent on one node but not another if their view of the ledger tip differs.
* **Stake Activation:** `activatedStake` reflects stake that is active in the current epoch. Stake takes time to activate and deactivate.
* **Epoch Credits:** `epochCredits` provides a history of a validator's performance in earning credits by voting.

This guide covers the `getVoteAccounts` RPC method, enabling you to query and understand validator information on the Solana network.


# How to Use isBlockhashValid
Source: https://www.helius.dev/docs/rpc/guides/isblockhashvalid

Learn isBlockhashValid use cases, code examples, request parameters, response structure, and tips.

The [`isBlockhashValid`](https://www.helius.dev/docs/api-reference/rpc/http/isblockhashvalid) RPC method checks whether a previously obtained blockhash is still considered valid by the network. Blockhashes have a limited lifetime (approximately 2 minutes, or 150 blocks), after which transactions referencing them will be rejected.

This method is crucial for applications that hold onto blockhashes for some time before submitting a transaction, to ensure the transaction doesn't fail due to an expired blockhash.

**Version Note:** This method is available in `solana-core` v1.9 and newer. For nodes running `solana-core` v1.8 or older, you should use `getFeeCalculatorForBlockhash` which, in addition to fee information, also implicitly indicates blockhash validity (it will error if the blockhash is too old).

## Common Use Cases

* **Transaction Resubmission:** Before retrying a failed transaction, check if its original blockhash is still valid. If not, a new blockhash must be fetched.
* **Delayed Transaction Signing:** If a transaction is prepared but signed and submitted later, verify the blockhash validity just before submission.
* **Optimistic Transaction Processing:** Determine if a blockhash is likely to be accepted by the network if a transaction is sent immediately.

## Request Parameters

1. **`blockhash`** (string, required): The blockhash to check, as a base-58 encoded string.
2. **`options`** (object, optional): An optional configuration object that can include:
   * **`commitment`** (string, optional): Specifies the [commitment level](https://www.helius.dev/blog/solana-commitment-levels) for the query (e.g., `"finalized"`, `"confirmed"`, `"processed"`). If omitted, the node's default commitment is used.
   * **`minContextSlot`** (u64, optional): The minimum slot that the request can be evaluated at. This ensures the RPC node does not respond with a status from a slot older than the `minContextSlot`.

## Response Structure

The `result` field in the JSON-RPC response is an `RpcResponse` object containing:

* **`context`** (object): An object containing:
  * **`slot`** (u64): The slot at which the RPC node evaluated the blockhash validity.
* **`value`** (boolean): `true` if the blockhash is still valid, `false` otherwise.

**Example Response (Valid Blockhash):**

```json
{
  "jsonrpc": "2.0",
  "result": {
    "context": { "slot": 180000500 },
    "value": true
  },
  "id": 1
}
```

**Example Response (Invalid/Expired Blockhash):**

```json
{
  "jsonrpc": "2.0",
  "result": {
    "context": { "slot": 180000800 },
    "value": false
  },
  "id": 1
}
```

## Code Examples

<CodeGroup>
  ```bash cURL
  # Check validity of a blockhash (replace <YOUR_BLOCKHASH>):
  curl -X POST -H "Content-Type: application/json" -d \
    '{
      "jsonrpc": "2.0",
      "id": 1,
      "method": "isBlockhashValid",
      "params": [
        "<YOUR_BLOCKHASH>"
      ]
    }' \
    <YOUR_RPC_URL>

  # Check with commitment and minContextSlot (replace <YOUR_BLOCKHASH>):
  curl -X POST -H "Content-Type: application/json" -d \
    '{
      "jsonrpc": "2.0",
      "id": 1,
      "method": "isBlockhashValid",
      "params": [
        "<YOUR_BLOCKHASH>",
        {
          "commitment": "confirmed",
          "minContextSlot": 170000000
        }
      ]
    }' \
    <YOUR_RPC_URL>
  ```

  ```javascript JavaScript (using @solana/web3.js)
  const { Connection } = require('@solana/web3.js');

  async function checkBlockhash(blockhashToCheck) {
    // Replace with your RPC endpoint
    const connection = new Connection('https://mainnet.helius-rpc.com/?api-key=<api-key>');

    try {
      console.log(`Checking validity of blockhash: ${blockhashToCheck}`);
      const result = await connection.isBlockhashValid(blockhashToCheck);
      
      console.log(`  Blockhash is valid: ${result.value}`);
      console.log(`  Checked at slot: ${result.context.slot}`);

      // Example with options
      // const resultWithOptions = await connection.isBlockhashValid(
      //   blockhashToCheck,
      //   { commitment: 'confirmed', minContextSlot: result.context.slot - 100 }
      // );
      // console.log(`\nWith options - Valid: ${resultWithOptions.value}, Slot: ${resultWithOptions.context.slot}`);

    } catch (error) {
      console.error(`Error checking blockhash ${blockhashToCheck}:`, error);
    }
  }

  // Example usage: First, get a recent blockhash
  async function getRecentBlockhashAndCheck() {
    const connection = new Connection('https://mainnet.helius-rpc.com/?api-key=<api-key>');
    try {
      const { blockhash } = await connection.getLatestBlockhash();
      await checkBlockhash(blockhash); 
      
      // Example with a known old/invalid blockhash (will likely be false)
      // This blockhash is just an example and will be invalid.
      const oldBlockhash = 'J7rBdM6AecPDEZp8aPq5iPSNKVkU5Q76F3oAV4eW5wsW'; 
      // await checkBlockhash(oldBlockhash);

    } catch (error) {
      console.error('Error in example execution:', error);
    }
  }

  getRecentBlockhashAndCheck();
  ```
</CodeGroup>

## Developer Tips

* **Blockhashes Expire:** Blockhashes are only valid for a limited time (around 150 slots, or roughly 1-2 minutes). Always fetch a fresh blockhash if you are unsure or if significant time has passed.
* **`minContextSlot` Usage:** Use `minContextSlot` to protect against querying a stale RPC node that might give an outdated "valid" response for a blockhash that is actually too old from the perspective of the rest of the cluster.
* **Alternative for Older Nodes:** For nodes running Solana versions prior to 1.9, use `getFeeCalculatorForBlockhash("<YOUR_BLOCKHASH>")`. If this method returns successfully, the blockhash is valid. If it errors (typically because the blockhash is not found or too old), then the blockhash is invalid.
* **Network Confirmation:** Even if `isBlockhashValid` returns `true`, a transaction is only finalized once it reaches the desired commitment level on the network after submission.

This guide provides the necessary details to use the `isBlockhashValid` RPC method effectively when building Solana applications.


# How to Use minimumLedgerSlot
Source: https://www.helius.dev/docs/rpc/guides/minimumledgerslot

Learn minimumLedgerSlot use cases, code examples, request parameters, response structure, and tips.

The [`minimumLedgerSlot`](https://www.helius.dev/docs/api-reference/rpc/http/minimumledgerslot) RPC method returns the lowest (oldest) slot that the queried RPC node has information about in its ledger. This is useful for understanding the historical data retention of a particular node.

## Common Use Cases

* **Determining Historical Data Availability:** Before attempting to query very old historical data (e.g., old blocks or transactions), you can use this method to check if the node is likely to have that data. If you need data from a slot lower than the `minimumLedgerSlot`, you may need to find an archival node.
* **Node Pruning Awareness:** Understanding that RPC nodes (especially non-archival ones) might prune old ledger data. This value indicates the current lower bound of their stored history.
* **Synchronizing Historical Data Fetchers:** If you are building a service that ingests historical Solana data, this can help you understand the starting point of available data on a given node.

## Request Parameters

This method does not take any parameters.

## Response Structure

The `result` field in the JSON-RPC response is a single `u64` number representing the minimum ledger slot available on the node.

**Example Response:**

```json
{
  "jsonrpc": "2.0",
  "result": 123456789,
  "id": 1
}
```

## Code Examples

<CodeGroup>
  ```bash cURL
  curl -X POST -H "Content-Type: application/json" -d \
    '{
      "jsonrpc": "2.0",
      "id": 1,
      "method": "minimumLedgerSlot"
    }' \
    <YOUR_RPC_URL>
  ```

  ```javascript JavaScript (using @solana/web3.js)
  const { Connection } = require('@solana/web3.js');

  async function getMinLedgerSlot() {
    // Replace with your RPC endpoint
    const connection = new Connection('https://mainnet.helius-rpc.com/?api-key=<api-key>');

    try {
      const minSlot = await connection.getMinimumLedgerSlot();
      console.log(`Minimum ledger slot available on the node: ${minSlot}`);
    } catch (error) {
      console.error('Error fetching minimum ledger slot:', error);
    }
  }

  getMinLedgerSlot();
  ```
</CodeGroup>

## Developer Tips

* **Node Specific:** The returned `minimumLedgerSlot` is specific to the RPC node you are querying. Different nodes can have different ledger retention policies and thus different minimum slots.
* **Dynamic Value:** This value can increase over time as the node prunes older parts of its ledger to save space. It will not decrease.
* **Not All History:** This does not mean the node has *all* blocks between this slot and the current tip. It only indicates the lowest slot for which it *might* have data. Gaps can still exist, especially on non-archival nodes.
* **Archival Nodes:** For access to the complete history of the blockchain from genesis, you would typically need to query an archival node, which aims to store all ledger data.

This guide helps you understand and use the `minimumLedgerSlot` RPC method to ascertain the extent of historical data stored by a Solana RPC node.


# Solana RPC Method Guides: Complete Developer Reference
Source: https://www.helius.dev/docs/rpc/guides/overview

Practical guides for using Solana RPC methods effectively. Real-world examples, code samples, and best practices for blockchain development.

## Quick Navigation

<CardGroup cols={2}>
  <Card title="Account & Balance Methods" icon="wallet" href="#account-%26-balance-methods">
    Query account information, balances, and token data
  </Card>

  <Card title="Transaction Methods" icon="arrow-right-arrow-left" href="#transaction-methods">
    Send, simulate, and track transactions on Solana
  </Card>

  <Card title="Block & Slot Methods" icon="cube" href="#block-%26-slot-methods">
    Access blockchain structure and timing information
  </Card>

  <Card title="Network & Cluster Methods" icon="globe" href="#network-%26-cluster-methods">
    Monitor network health and validator information
  </Card>
</CardGroup>

***

## What Are RPC Method Guides?

These practical guides show you **how to use specific Solana RPC methods** to solve common development challenges. Each guide includes:

* **Real-world use cases** and when to use each method
* **Complete code examples** in multiple languages
* **Parameter explanations** with practical tips
* **Response structure** breakdown
* **Developer tips** for optimization and best practices

Perfect for developers who want to understand not just *what* each RPC method does, but *how* to use it effectively in production applications.

## Account & Balance Methods

Essential methods for querying account data, balances, and token information.

<CardGroup cols={3}>
  <Card title="getAccountInfo" icon="info" href="/rpc/guides/getaccountinfo">
    Get complete account details including balance, owner, and data
  </Card>

  <Card title="getBalance" icon="coins" href="/rpc/guides/getbalance">
    Quick SOL balance lookup for any account
  </Card>

  <Card title="getMultipleAccounts" icon="layer-group" href="/rpc/guides/getmultipleaccounts">
    Batch query multiple accounts efficiently
  </Card>

  <Card title="getProgramAccounts" icon="code" href="/rpc/guides/getprogramaccounts">
    Find all accounts owned by a specific program
  </Card>

  <Card title="getLargestAccounts" icon="star" href="/rpc/guides/getlargestaccounts">
    Get accounts with largest SOL balances
  </Card>

  <Card title="getSupply" icon="server" href="/rpc/guides/getsupply">
    Get information about current supply
  </Card>
</CardGroup>

### Token Account Methods

<CardGroup cols={2}>
  <Card title="getTokenAccountsByOwner" icon="wallet" href="/rpc/guides/gettokenaccountsbyowner">
    Get all token accounts for a wallet
  </Card>

  <Card title="getTokenAccountsByDelegate" icon="user" href="/rpc/guides/gettokenaccountsbydelegate">
    Query token accounts by delegate
  </Card>

  <Card title="getTokenAccountBalance" icon="wallet" href="/rpc/guides/gettokenaccountbalance">
    Get balance of a specific token account
  </Card>

  <Card title="getTokenSupply" icon="coins" href="/rpc/guides/gettokensupply">
    Query total supply of an SPL token
  </Card>

  <Card title="getTokenLargestAccounts" icon="star" href="/rpc/guides/gettokenlargestaccounts">
    Find accounts with largest token holdings
  </Card>
</CardGroup>

## Transaction Methods

Methods for sending transactions, checking status, and retrieving transaction history.

<CardGroup cols={3}>
  <Card title="getTransaction" icon="receipt" href="/rpc/guides/gettransaction">
    Get detailed information about a specific transaction
  </Card>

  <Card title="getSignatures" icon="list" href="/rpc/guides/getsignaturesforaddress">
    Get transaction signatures for an account
  </Card>

  <Card title="getSignatureStatuses" icon="check" href="/rpc/guides/getsignaturestatuses">
    Check confirmation status of transactions
  </Card>

  <Card title="getTransactionCount" icon="calculator" href="/rpc/guides/gettransactioncount">
    Get total number of transactions processed
  </Card>

  <Card title="requestAirdrop" icon="gift" href="/rpc/guides/requestairdrop">
    Request SOL airdrop on devnet/testnet
  </Card>
</CardGroup>

### Transaction Fees & Simulation

<CardGroup cols={3}>
  <Card title="getPriorityFees" icon="coins" href="/rpc/guides/getrecentprioritizationfees">
    Get recent priority fees for optimal pricing
  </Card>

  <Card title="getFeeForMessage" icon="calculator" href="/rpc/guides/getfeeformessage">
    Calculate transaction fees before sending
  </Card>
</CardGroup>

## Block & Slot Methods

Access blockchain structure, timing, and historical data.

<CardGroup cols={3}>
  <Card title="getBlock" icon="cube" href="/rpc/guides/getblock">
    Get complete block information including all transactions
  </Card>

  <Card title="getBlockHeight" icon="arrow-up" href="/rpc/guides/getblockheight">
    Get current block height of the network
  </Card>

  <Card title="getSlot" icon="clock" href="/rpc/guides/getslot">
    Get current slot number
  </Card>

  <Card title="getBlocks" icon="cubes" href="/rpc/guides/getblocks">
    Get list of confirmed blocks in a range
  </Card>

  <Card title="getBlocksWithLimit" icon="list" href="/rpc/guides/getblockswithlimit">
    Get limited number of confirmed blocks
  </Card>

  <Card title="getBlockTime" icon="clock" href="/rpc/guides/getblocktime">
    Get estimated production time of a block
  </Card>
</CardGroup>

### Blockhash & Slot Information

<CardGroup cols={3}>
  <Card title="getLatestBlockhash" icon="hashtag" href="/rpc/guides/getlatestblockhash">
    Get most recent blockhash for transactions
  </Card>

  <Card title="isBlockhashValid" icon="check" href="/rpc/guides/isblockhashvalid">
    Validate if a blockhash is still valid
  </Card>

  <Card title="getSlotLeader" icon="crown" href="/rpc/guides/getslotleader">
    Get current slot leader
  </Card>

  <Card title="getSlotLeaders" icon="users" href="/rpc/guides/getslotleaders">
    Get slot leaders for a range of slots
  </Card>

  <Card title="getLeaderSchedule" icon="calendar" href="/rpc/guides/getleaderschedule">
    Get leader schedule for an epoch
  </Card>
</CardGroup>

## Network & Cluster Methods

Monitor network health, validator information, and cluster status.

<CardGroup cols={3}>
  <Card title="getHealth" icon="heart" href="/rpc/guides/gethealth">
    Check RPC node health status
  </Card>

  <Card title="getVersion" icon="tag" href="/rpc/guides/getversion">
    Get Solana software version information
  </Card>

  <Card title="getClusterNodes" icon="server" href="/rpc/guides/getclusternodes">
    Get information about cluster validators
  </Card>

  <Card title="getVoteAccounts" icon="check" href="/rpc/guides/getvoteaccounts">
    Get current and delinquent vote accounts
  </Card>

  <Card title="getEpochInfo" icon="calendar" href="/rpc/guides/getepochinfo">
    Get information about the current epoch
  </Card>

  <Card title="getEpochSchedule" icon="calendar" href="/rpc/guides/getepochschedule">
    Get epoch schedule information
  </Card>
</CardGroup>

### Network Performance & Economics

<CardGroup cols={3}>
  <Card title="getPerformanceSamples" icon="server" href="/rpc/guides/getrecentperformancesamples">
    Get recent network performance metrics
  </Card>

  <Card title="getInflationGovernor" icon="info" href="/rpc/guides/getinflationgovernor">
    Get current inflation parameters
  </Card>

  <Card title="getInflationRate" icon="arrow-up" href="/rpc/guides/getinflationrate">
    Get current inflation rate
  </Card>

  <Card title="getInflationReward" icon="coins" href="/rpc/guides/getinflationreward">
    Calculate inflation rewards for accounts
  </Card>

  <Card title="getStakeDelegation" icon="handshake" href="/rpc/guides/getstakeminimumdelegation">
    Get minimum stake delegation amount
  </Card>
</CardGroup>

## Utility & System Methods

Helper methods for system information, validation, and advanced queries.

<CardGroup cols={3}>
  <Card title="getRentExemption" icon="house" href="/rpc/guides/getminimumbalanceforrentexemption">
    Calculate minimum balance for rent exemption
  </Card>

  <Card title="getGenesisHash" icon="fingerprint" href="/rpc/guides/getgenesishash">
    Get genesis hash of the cluster
  </Card>

  <Card title="getIdentity" icon="user" href="/rpc/guides/getidentity">
    Get identity public key of the RPC node
  </Card>

  <Card title="getFirstAvailableBlock" icon="play" href="/rpc/guides/getfirstavailableblock">
    Get slot of first available block
  </Card>

  <Card title="getHighestSnapshotSlot" icon="arrow-up" href="/rpc/guides/gethighestsnapshotslot">
    Get highest slot with a snapshot
  </Card>

  <Card title="minimumLedgerSlot" icon="database" href="/rpc/guides/minimumledgerslot">
    Get minimum slot that node has ledger information
  </Card>
</CardGroup>

### Advanced System Queries

<CardGroup cols={3}>
  <Card title="getMaxRetransmitSlot" icon="repeat" href="/rpc/guides/getmaxretransmitslot">
    Get maximum slot seen from retransmit stage
  </Card>

  <Card title="getMaxShredInsertSlot" icon="layer-group" href="/rpc/guides/getmaxshredinsertslot">
    Get maximum slot seen from shred insert
  </Card>
</CardGroup>

## Related Resources

<CardGroup cols={3}>
  <Card title="RPC Optimization" icon="rocket" href="/rpc/optimization-techniques">
    Learn advanced techniques for optimizing RPC performance
  </Card>

  <Card title="WebSocket Methods" icon="wifi" href="/rpc/websocket">
    Explore real-time subscriptions and streaming data
  </Card>

  <Card title="API Reference" icon="book" href="/api-reference/rpc">
    Complete technical reference for all RPC methods
  </Card>
</CardGroup>

***

**Need help with a specific RPC method?** Each guide includes practical examples and developer tips to get you started quickly. Browse the categories above or use the search to find exactly what you need.


# How to Use requestAirdrop
Source: https://www.helius.dev/docs/rpc/guides/requestairdrop

Learn requestAirdrop use cases, code examples, request parameters, response structure, and tips.

The [`requestAirdrop`](https://www.helius.dev/docs/api-reference/rpc/http/requestairdrop) RPC method allows you to request an airdrop of SOL (lamports) to a specified account. This method is **exclusively for non-mainnet environments** like Devnet and Testnet, where it serves as a faucet to provide developers with free SOL for testing their applications.

**Important: This method will not work on Mainnet Beta.**

## Common Use Cases

* **Funding Test Wallets:** Obtaining SOL to pay for transaction fees and deploy programs on Devnet or Testnet.
* **Automated Testing:** Scripts can use `requestAirdrop` to ensure test accounts have sufficient SOL before running test suites.
* **Development & Experimentation:** Quickly acquiring SOL to interact with on-chain programs during development.

## Request Parameters

1. **`pubkey`** (string, required): The public key of the account that will receive the airdropped lamports, provided as a base-58 encoded string.
2. **`lamports`** (u64, required): The amount of lamports to request. (1 SOL = 1,000,000,000 lamports).
3. **`options`** (object, optional): An optional configuration object that can include:
   * **`commitment`** (string, optional): Specifies the [commitment level](https://www.helius.dev/blog/solana-commitment-levels) to wait for when confirming the airdrop transaction (e.g., `"finalized"`, `"confirmed"`, `"processed"`). If omitted, the node's default commitment for airdrops is used.

## Response Structure

The `result` field in the JSON-RPC response is a single string representing the transaction signature of the airdrop, base-58 encoded.

**Example Response:**

```json
{
  "jsonrpc": "2.0",
  "result": "5VERv8NMvzbJMEkV8xnrLkEaWRtSz9CosKDYjCJjBRnbJLgp8uirBgmQpjKhoR4tjF3ZpRzrFmBV6UjKdiSZkQUW",
  "id": 1
}
```

This signature can then be used with `getTransaction` or a Solana explorer to track the status of the airdrop transaction.

## Code Examples

<CodeGroup>
  ```bash cURL
  # Request 1 SOL (1,000,000,000 lamports) to a Devnet address
  # Replace <YOUR_WALLET_ADDRESS> with an actual base-58 public key
  # Ensure you are targeting a Devnet RPC URL
  curl -X POST -H "Content-Type: application/json" -d \
    '{
      "jsonrpc": "2.0",
      "id": 1,
      "method": "requestAirdrop",
      "params": [
        "<YOUR_WALLET_ADDRESS>",
        1000000000
      ]
    }' \
    https://devnet.helius-rpc.com/?api-key=<api-key> 

  # Request 0.5 SOL with "confirmed" commitment
  curl -X POST -H "Content-Type: application/json" -d \
    '{
      "jsonrpc": "2.0",
      "id": 1,
      "method": "requestAirdrop",
      "params": [
        "<YOUR_WALLET_ADDRESS>",
        500000000,
        {
          "commitment": "confirmed"
        }
      ]
    }' \
    https://devnet.helius-rpc.com/?api-key=<api-key>
  ```

  ```javascript JavaScript (using @solana/web3.js)
  const { Connection, PublicKey, LAMPORTS_PER_SOL } = require('@solana/web3.js');

  async function getAirdrop(walletAddress) {
    // Connect to Devnet
    const connection = new Connection('https://devnet.helius-rpc.com/?api-key=<api-key>', 'confirmed');
    const publicKey = new PublicKey(walletAddress);

    try {
      console.log(`Requesting airdrop of 1 SOL to ${walletAddress} on Devnet...`);
      
      // Request an airdrop of 1 SOL
      const airdropSignature = await connection.requestAirdrop(
        publicKey,
        LAMPORTS_PER_SOL // 1 SOL
      );

      console.log(`Airdrop requested. Transaction signature: ${airdropSignature}`);

      // Confirm the transaction
      // Note: The `confirmTransaction` method in web3.js has evolved.
      // For newer versions, you might use `connection.confirmTransaction({ signature: airdropSignature, blockhash: latestBlockhash.blockhash, lastValidBlockHeight: latestBlockhash.lastValidBlockHeight }, 'confirmed');`
      // For simplicity, we'll log the signature and you can check on an explorer.
      // Or, more robustly, you can poll getSignatureStatuses.

      await connection.confirmTransaction(airdropSignature);
      console.log(`Airdrop successful for ${walletAddress}!`);

      const balance = await connection.getBalance(publicKey);
      console.log(`Current balance for ${walletAddress}: ${balance / LAMPORTS_PER_SOL} SOL`);

    } catch (error) {
      console.error(`Error requesting airdrop for ${walletAddress}:`, error);
    }
  }

  // Replace with a Devnet wallet address you control
  const myDevnetWallet = 'REPLACE_WITH_YOUR_DEVNET_WALLET_ADDRESS'; 
  // Example: const myDevnetWallet = new Keypair().publicKey.toBase58(); // For a new temporary wallet

  if (myDevnetWallet === 'REPLACE_WITH_YOUR_DEVNET_WALLET_ADDRESS') {
    console.warn("Please replace 'REPLACE_WITH_YOUR_DEVNET_WALLET_ADDRESS' with an actual Devnet wallet address to run the example.");
  } else {
    // getAirdrop(myDevnetWallet);
    console.log("Uncomment the line above and replace the placeholder to run the airdrop example.");
  }
  ```
</CodeGroup>

## Developer Tips

* **Network Specific:** This method is only functional on test networks (Devnet, Testnet) that have a faucet enabled. It will fail on Mainnet Beta.
* **Rate Limiting:** Airdrop faucets are often rate-limited to prevent abuse. If you make too many requests in a short period, you might receive errors.
* **Amount Limits:** There might be limits on the amount of SOL you can request per airdrop or per time period.
* **Confirmation:** After `requestAirdrop` returns a signature, the transaction still needs to be processed and confirmed by the network. You can use `confirmTransaction` (from `@solana/web3.js`) or poll `getSignatureStatuses` to wait for confirmation.

This guide explains how to use `requestAirdrop` to fund your test accounts on Solana's development networks.


# Solana RPC Optimization: Performance & Cost Best Practices
Source: https://www.helius.dev/docs/rpc/optimization-techniques

Optimize Solana RPC performance, reduce costs, and improve reliability. Transaction optimization, data retrieval patterns, and best practices guide.

Optimizing RPC usage can significantly improve performance, reduce costs, and enhance user experience. This guide covers proven techniques for efficient Solana RPC interactions.

## Quick Start

<CardGroup cols={2}>
  <Card title="Transaction Optimization" icon="bolt" href="#transaction-optimization">
    Optimize compute units, priority fees, and transaction sending
  </Card>

  <Card title="Data Retrieval" icon="database" href="#data-retrieval-optimization">
    Efficient patterns for fetching account and program data
  </Card>

  <Card title="Real-time Monitoring" icon="chart-line" href="#real-time-monitoring">
    WebSocket subscriptions and streaming data optimization
  </Card>

  <Card title="Best Practices" icon="shield-check" href="#best-practices">
    Performance guidelines and resource management
  </Card>
</CardGroup>

## Transaction Optimization

### Compute Unit Management

**1. Simulate to determine actual usage:**

```typescript
const testTransaction = new VersionedTransaction(/* your transaction */);
const simulation = await connection.simulateTransaction(testTransaction, {
  replaceRecentBlockhash: true,
  sigVerify: false
});
const unitsConsumed = simulation.value.unitsConsumed;
```

**2. Set appropriate limits with margin:**

```typescript
const computeUnitLimit = Math.ceil(unitsConsumed * 1.1);
const computeUnitIx = ComputeBudgetProgram.setComputeUnitLimit({ 
  units: computeUnitLimit 
});
instructions.unshift(computeUnitIx); // Add at beginning
```

### Priority Fee Optimization

**1. Get dynamic fee estimates:**

```typescript
const response = await fetch(`https://mainnet.helius-rpc.com/?api-key=${API_KEY}`, {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({
    method: 'getPriorityFeeEstimate',
    params: [{
      accountKeys: ['11111111111111111111111111111112'], // System Program
      options: { recommended: true }
    }]
  })
});
const { priorityFeeEstimate } = await response.json().result;
```

**2. Apply the priority fee:**

```typescript
const priorityFeeIx = ComputeBudgetProgram.setComputeUnitPrice({ 
  microLamports: priorityFeeEstimate 
});
instructions.unshift(priorityFeeIx);
```

### Transaction Sending Best Practices

<Tabs>
  <Tab title="Standard Approach">
    ```typescript
    // Serialize and encode
    const serializedTx = transaction.serialize();
    const signature = await connection.sendRawTransaction(serializedTx, {
      skipPreflight: true, // Saves ~100ms
      maxRetries: 0 // Handle retries manually
    });
    ```
  </Tab>

  <Tab title="With Confirmation">
    ```typescript
    // Send and confirm with custom logic
    const signature = await connection.sendRawTransaction(serializedTx);

    // Monitor confirmation
    const confirmation = await connection.confirmTransaction({
      signature,
      blockhash: latestBlockhash.blockhash,
      lastValidBlockHeight: latestBlockhash.lastValidBlockHeight
    });
    ```
  </Tab>
</Tabs>

## Data Retrieval Optimization

### Efficient Account Queries

<Tabs>
  <Tab title="Single Account">
    ```typescript
    // Use dataSlice to reduce payload size
    const accountInfo = await connection.getAccountInfo(pubkey, {
      encoding: 'base64',
      dataSlice: { offset: 0, length: 100 }, // Only get needed data
      commitment: 'confirmed'
    });
    ```
  </Tab>

  <Tab title="Multiple Accounts">
    ```typescript
    // Batch multiple account queries
    const accounts = await connection.getMultipleAccountsInfo([
      pubkey1, pubkey2, pubkey3
    ], {
      encoding: 'base64',
      commitment: 'confirmed'
    });
    ```
  </Tab>

  <Tab title="Program Accounts">
    ```typescript
    // Use filters to reduce data transfer
    const accounts = await connection.getProgramAccounts(programId, {
      filters: [
        { dataSize: 165 }, // Token account size
        { memcmp: { offset: 0, bytes: mintAddress }}
      ],
      encoding: 'jsonParsed'
    });
    ```
  </Tab>
</Tabs>

### Token Balance Lookups

<CodeGroup>
  ```typescript  Inefficient
  // Don't do this - requires N+1 RPC calls
  const tokenAccounts = await connection.getTokenAccountsByOwner(owner, {
    programId: TOKEN_PROGRAM_ID
  });
  const balances = await Promise.all(
    tokenAccounts.value.map(acc => 
      connection.getTokenAccountBalance(acc.pubkey)
    )
  );
  // ~500ms + (100ms * N accounts)
  ```

  ```typescript  Optimized
  // Single call with parsed data
  const tokenAccounts = await connection.getTokenAccountsByOwner(owner, {
    programId: TOKEN_PROGRAM_ID
  }, { encoding: 'jsonParsed' });

  const balances = tokenAccounts.value.map(acc => ({
    mint: acc.account.data.parsed.info.mint,
    amount: acc.account.data.parsed.info.tokenAmount.uiAmount
  }));
  // ~500ms total - 95% reduction for large wallets
  ```
</CodeGroup>

### Transaction History

<CodeGroup>
  ```typescript  Inefficient
  // Avoid sequential transaction fetching
  const signatures = await connection.getSignaturesForAddress(address, { limit: 100 });
  const transactions = await Promise.all(
    signatures.map(sig => connection.getTransaction(sig.signature))
  );
  // ~1s + (200ms * 100 txs) = ~21s
  ```

  ```typescript  Optimized
  // Use batch transaction fetching
  const signatures = await connection.getSignaturesForAddress(address, { limit: 100 });
  const transactions = await connection.getTransactions(
    signatures.map(s => s.signature),
    { maxSupportedTransactionVersion: 0 }
  );
  // ~2s total - 90% reduction
  ```
</CodeGroup>

## Real-time Monitoring

### Account Subscriptions

<CodeGroup>
  ```typescript  Polling
  // Avoid polling - wastes resources
  setInterval(async () => {
    const accountInfo = await connection.getAccountInfo(pubkey);
    // Process updates...
  }, 1000);
  ```

  ```typescript  WebSocket
  // Use WebSocket subscriptions for real-time updates
  const subscriptionId = connection.onAccountChange(
    pubkey,
    (accountInfo, context) => {
      // Handle real-time updates
      console.log('Account updated:', accountInfo);
    },
    'confirmed',
    { encoding: 'base64', dataSlice: { offset: 0, length: 100 }}
  );
  ```
</CodeGroup>

### Program Account Monitoring

```typescript
// Monitor specific program accounts with filters
connection.onProgramAccountChange(
  programId,
  (accountInfo, context) => {
    // Handle program account changes
  },
  'confirmed',
  {
    filters: [
      { dataSize: 1024 },
      { memcmp: { offset: 0, bytes: ACCOUNT_DISCRIMINATOR }}
    ],
    encoding: 'base64'
  }
);
```

### Transaction Monitoring

```typescript
// Subscribe to transaction logs for real-time monitoring
const ws = new WebSocket(`wss://mainnet.helius-rpc.com/?api-key=${API_KEY}`);

ws.on('open', () => {
  ws.send(JSON.stringify({
    jsonrpc: '2.0',
    id: 1,
    method: 'logsSubscribe',
    params: [
      { mentions: [programId] },
      { commitment: 'confirmed' }
    ]
  }));
});

ws.on('message', (data) => {
  const message = JSON.parse(data);
  if (message.params) {
    const signature = message.params.result.value.signature;
    // Process transaction signature
  }
});
```

## Advanced Patterns

### Smart Retry Logic

```typescript
class RetryManager {
  private backoff = new ExponentialBackoff({
    min: 100,
    max: 5000,
    factor: 2,
    jitter: 0.2
  });

  async executeWithRetry<T>(operation: () => Promise<T>): Promise<T> {
    while (true) {
      try {
        return await operation();
      } catch (error) {
        if (error.message.includes('429')) {
          // Rate limit - wait and retry
          await this.backoff.delay();
          continue;
        }
        throw error;
      }
    }
  }
}
```

### Memory-Efficient Processing

```typescript
// Process large datasets in chunks
function chunk<T>(array: T[], size: number): T[][] {
  return Array.from({ length: Math.ceil(array.length / size) }, (_, i) =>
    array.slice(i * size, i * size + size)
  );
}

// Process program accounts in batches
const allAccounts = await connection.getProgramAccounts(programId, {
  dataSlice: { offset: 0, length: 32 }
});

const chunks = chunk(allAccounts, 100);
for (const batch of chunks) {
  const detailedAccounts = await connection.getMultipleAccountsInfo(
    batch.map(acc => acc.pubkey)
  );
  // Process batch...
}
```

### Connection Pooling

```typescript
class ConnectionPool {
  private connections: Connection[] = [];
  private currentIndex = 0;

  constructor(rpcUrls: string[]) {
    this.connections = rpcUrls.map(url => new Connection(url));
  }

  getConnection(): Connection {
    const connection = this.connections[this.currentIndex];
    this.currentIndex = (this.currentIndex + 1) % this.connections.length;
    return connection;
  }
}

const pool = new ConnectionPool([
  'https://mainnet.helius-rpc.com/?api-key=YOUR_API_KEY',
  'https://mainnet-backup.helius-rpc.com/?api-key=YOUR_API_KEY'
]);
```

## Performance Monitoring

### Track RPC Usage

```typescript
class RPCMonitor {
  private metrics = {
    calls: 0,
    errors: 0,
    totalLatency: 0
  };

  async monitoredCall<T>(operation: () => Promise<T>): Promise<T> {
    const start = Date.now();
    this.metrics.calls++;
    
    try {
      const result = await operation();
      this.metrics.totalLatency += Date.now() - start;
      return result;
    } catch (error) {
      this.metrics.errors++;
      throw error;
    }
  }

  getStats() {
    return {
      ...this.metrics,
      averageLatency: this.metrics.totalLatency / this.metrics.calls,
      errorRate: this.metrics.errors / this.metrics.calls
    };
  }
}
```

## Best Practices

### Commitment Levels

<Tabs>
  <Tab title="processed">
    * **Use for**: WebSocket subscriptions, real-time updates
    * **Latency**: \~400ms
    * **Reliability**: Good for most applications
  </Tab>

  <Tab title="confirmed">
    * **Use for**: General queries, account info
    * **Latency**: \~1s
    * **Reliability**: Recommended for most use cases
  </Tab>

  <Tab title="finalized">
    * **Use for**: Final settlement, irreversible operations
    * **Latency**: \~32s
    * **Reliability**: Maximum certainty
  </Tab>
</Tabs>

### Resource Management

<CheckboxList>
  * Use `dataSlice` to limit payload sizes
  * Implement server-side filtering with `memcmp` and `dataSize`
  * Batch operations to reduce round trips
  * Cache results to avoid redundant calls
  * Close WebSocket subscriptions when done
  * Implement circuit breakers for error handling
</CheckboxList>

### Error Handling

```typescript
// Implement robust error handling
async function robustRPCCall<T>(operation: () => Promise<T>): Promise<T> {
  try {
    return await operation();
  } catch (error) {
    if (error.code === -32602) {
      // Invalid params - fix request
      throw new Error('Invalid RPC parameters');
    } else if (error.code === -32005) {
      // Node behind - retry with different node
      throw new Error('Node synchronization issue');
    } else if (error.message.includes('429')) {
      // Rate limit - implement backoff
      throw new Error('Rate limited');
    }
    throw error;
  }
}
```

## Common Pitfalls to Avoid

<Warning>
  **Avoid these common mistakes:**

  * Polling instead of using WebSocket subscriptions
  * Fetching full account data when only partial data is needed
  * Not using batch operations for multiple queries
  * Ignoring rate limits and not implementing proper retry logic
  * Using `finalized` commitment when `confirmed` is sufficient
  * Not closing subscriptions, leading to memory leaks
</Warning>

## Summary

By implementing these optimization techniques, you can achieve:

* **60-90% reduction** in API call volume
* **Significantly lower latency** for real-time operations
* **Reduced bandwidth usage** through targeted queries
* **Better error resilience** with smart retry logic
* **Lower operational costs** through efficient resource usage

<Card title="Next Steps" icon="arrow-right">
  Ready to implement these optimizations? Check out our [Transaction Optimization Guide](/sending-transactions/optimizing-transactions) for transaction-specific best practices.
</Card>


# Solana RPC Overview: High-Performance Blockchain Infrastructure
Source: https://www.helius.dev/docs/rpc/overview

High-performance Solana RPC infrastructure with 95% faster response times. Complete guide to RPC methods, optimization, and best practices.

<CardGroup cols={2}>
  <Card title="Start Building Now" icon="rocket" href="#getting-your-rpc-url">
    Get your RPC endpoint and make your first request
  </Card>

  <Card title="Browse RPC Methods" icon="book-open" href="/rpc/guides/overview">
    Explore practical guides for all Solana RPC methods
  </Card>
</CardGroup>

***

## Why Developers Choose Helius RPC

<CardGroup cols={3}>
  <Card title="99.99% Uptime" icon="shield-check">
    Enterprise-grade reliability with automatic failover and multi-node redundancy
  </Card>

  <Card title="<100ms Latency" icon="bolt">
    Global infrastructure optimized for speed with multiple regions worldwide
  </Card>

  <Card title="24/7 Support" icon="headset">
    Expert engineering support and active Discord community
  </Card>
</CardGroup>

<Note>
  **What are Solana RPC nodes?** They're your application's gateway to the Solana blockchain, providing essential infrastructure for reading data, writing transactions, real-time updates, and network queries. Every Solana application relies on RPC nodes to function.
</Note>

***

## Getting Your RPC URL

<Steps>
  <Step title="Go to Dashboard">
    Navigate to [dashboard.helius.dev](https://dashboard.helius.dev) and sign up or log in
  </Step>

  <Step title="Create a Plan">
    Choose a plan that fits your needs - free tier available to get started
  </Step>

  <Step title="Go to Endpoints Section">
    Navigate to the Endpoints section in your dashboard
  </Step>

  <Step title="Copy Your Endpoint">
    Copy your RPC endpoint URL for the network you want to use (mainnet or devnet)
  </Step>
</Steps>

## Test Your Connection

Choose your preferred language to test your RPC connection:

<Tabs>
  <Tab title="JavaScript/TypeScript">
    ```javascript
    import { Connection } from '@solana/web3.js';

    // Your Helius RPC URL from dashboard
    const rpcUrl = 'YOUR_HELIUS_RPC_URL';
    const connection = new Connection(rpcUrl);

    // Test the connection
    const testConnection = async () => {
      try {
        const version = await connection.getVersion();
        const slot = await connection.getSlot();
        
        console.log('Connection successful!');
        console.log(`Solana version: ${version['solana-core']}`);
        console.log(`Current slot: ${slot}`);
      } catch (error) {
        console.error('Connection failed:', error);
      }
    };

    testConnection();
    ```
  </Tab>

  <Tab title="Python">
    ```python
    from solana.rpc.api import Client

    # Your Helius RPC URL from dashboard
    rpc_url = 'YOUR_HELIUS_RPC_URL'
    client = Client(rpc_url)

    # Test the connection
    try:
        version = client.get_version()
        slot = client.get_slot()
        
        print('Connection successful!')
        print(f'Solana version: {version.value}')
        print(f'Current slot: {slot.value}')
    except Exception as e:
        print(f'Connection failed: {e}')
    ```
  </Tab>

  <Tab title="Rust">
    ```rust
    use solana_client::rpc_client::RpcClient;
    use solana_sdk::commitment_config::CommitmentConfig;

    #[tokio::main]
    async fn main() -> Result<(), Box<dyn std::error::Error>> {
        // Your Helius RPC URL from dashboard
        let rpc_url = "YOUR_HELIUS_RPC_URL";
        
        let client = RpcClient::new_with_commitment(
            rpc_url.to_string(),
            CommitmentConfig::confirmed(),
        );
        
        // Test the connection
        match client.get_version() {
            Ok(version) => {
                println!("Connection successful!");
                println!("Solana version: {:?}", version.solana_core);
                
                let slot = client.get_slot()?;
                println!("Current slot: {}", slot);
            }
            Err(err) => println!("Connection failed: {}", err),
        }
        
        Ok(())
    }
    ```
  </Tab>

  <Tab title="cURL">
    ```bash
    curl -X POST "YOUR_HELIUS_RPC_URL" \
      -H "Content-Type: application/json" \
      -d '{
        "jsonrpc": "2.0",
        "id": 1,
        "method": "getVersion"
      }' | jq
    ```
  </Tab>
</Tabs>

***

## Choose Your RPC Solution

### Regular RPC Nodes (Recommended)

<Card title="Best for 99% of Applications" icon="star">
  **Superior performance, reliability, and features at cost-effective pricing**

  * **Superior Performance**: Multi-node redundancy with optimized infrastructure
  * **Maximum Reliability**: No single points of failure, automatic failover
  * **Complete API Coverage**: All Solana RPC methods plus enhanced APIs
  * **Global Infrastructure**: Multiple regions for optimal latency
  * **Enhanced Features**: DAS API, Priority Fee API, Enhanced Transactions included
  * **Starting at \$0**: Generous free tier, pay only for what you use
</Card>

### Dedicated RPC Nodes (Limited Use Cases)

<Card title="Only for Unlimited Credits/Rate Limits" icon="server">
  **Consider only if you specifically need unlimited credits and rate limits**

  **When to Consider:**

  * Require unlimited credits
  * Require unlimited rate limits

  **Important Trade-offs:**

  * Performance risk: Can become slow under high load
  * Higher cost: \$2,300+/month plus requires shared plan
  * Limited features: Missing advanced APIs
</Card>

<Card title="Learn More About Dedicated Nodes" icon="server" href="/dedicated-nodes">
  Explore dedicated options (only if you need unlimited credits/rates)
</Card>

***

## Use Case Recommendations

<Tabs>
  <Tab title="DeFi Applications">
    **Real-time Trading & AMM Data**

    * Monitor account changes for price updates
    * Track swap transactions and liquidity changes
    * Submit time-sensitive arbitrage transactions

    **Recommended:** Regular RPC Plan
  </Tab>

  <Tab title="NFT Marketplaces">
    **Collection Monitoring & Sales Tracking**

    * Query NFT metadata and ownership
    * Monitor marketplace program accounts
    * Track sales and listing events

    **Recommended:** Regular RPC Plan
  </Tab>

  <Tab title="Wallets & Explorers">
    **Account Management & Transaction History**

    * Fetch account balances and token holdings
    * Display transaction history with parsed data
    * Submit user transactions reliably

    **Recommended:** Regular RPC Plan
  </Tab>

  <Tab title="Analytics Platforms">
    **Data Collection & Processing**

    * Bulk account and transaction queries
    * Historical data analysis
    * Real-time blockchain monitoring

    **Recommended:** Regular RPC Plan
  </Tab>
</Tabs>

***

## What's Next?

<CardGroup cols={2}>
  <Card title="Optimize Performance" icon="rocket" href="/rpc/optimization-techniques">
    Learn advanced techniques to maximize RPC performance and minimize costs
  </Card>

  <Card title="Real-time Data" icon="wifi" href="/data-streaming">
    Set up streams for live blockchain events
  </Card>
</CardGroup>

<Card title="Ready to Build Something Amazing?" icon="code">
  **You now have everything needed to start building on Solana with Helius RPC**

  Check out our [complete API reference](/api-reference) for detailed method documentation, or join our [Discord community](https://discord.gg/aXjCcEDN) to connect with other developers and get support from our team.
</Card>


# Protect Your Solana API Keys: Security Best Practices
Source: https://www.helius.dev/docs/rpc/protect-your-keys

Secure your Helius Solana API keys from malicious actors. Access control rules, RPC proxy, and security best practices to prevent unauthorized usage and charges.

<Warning>
  **API Key Security Alert**: Exposed API keys can lead to unauthorized usage, quota exhaustion, and unexpected charges. Always protect your keys in production applications.
</Warning>

## Why Key Protection Matters

When you expose API keys on the client side, malicious actors can discover and abuse them, potentially:

<CardGroup cols={2}>
  <Card title="Exhaust Your Quota" icon="gauge-high">
    Malicious usage can quickly consume your API limits and cause service interruptions
  </Card>

  <Card title="Increase Your Bills" icon="credit-card">
    Unauthorized requests can trigger auto-scaling charges or push you over plan limits
  </Card>

  <Card title="Compromise Security" icon="shield-exclamation">
    Exposed keys can provide access to sensitive data and operations
  </Card>

  <Card title="Damage Performance" icon="triangle-exclamation">
    High unauthorized usage can impact your application's performance
  </Card>
</CardGroup>

## Protection Methods

Helius provides multiple layers of protection to secure your API keys:

<Tabs>
  <Tab title="RPC Proxy">
    Deploy your own proxy for maximum security and control.

    <Card title="Helius RPC Proxy" icon="github" href="https://github.com/helius-labs/helius-rpc-proxy">
      A simple, open-source RPC proxy that you can deploy with 1-click to Cloudflare.
    </Card>

    ### Benefits of Using a Proxy

    <CardGroup cols={2}>
      <Card title="Complete Key Protection" icon="lock">
        Your API key stays server-side, never exposed to clients
      </Card>

      <Card title="Custom Rate Limiting" icon="gauge">
        Implement your own rate limiting and usage controls
      </Card>

      <Card title="Request Filtering" icon="filter">
        Filter and validate requests before they reach Helius
      </Card>

      <Card title="Usage Analytics" icon="chart-line">
        Monitor and analyze your API usage patterns
      </Card>
    </CardGroup>
  </Tab>

  <Tab title="Access Control Rules">
    Configure precise access controls in your Helius dashboard to restrict API usage.

    <Frame caption="Configure RPC Access Control Rules in the Endpoints section of your dashboard.">
      <img src="https://mintlify.s3.us-west-1.amazonaws.com/helius/images/rpc-access-control-rules-ip-domain-cidr.webp" alt="Configure RPC Access Control Rules in the Endpoints section of your dashboard." />
    </Frame>

    ### Available Rule Types

    <AccordionGroup>
      <Accordion title="Allowed Domains">
        Restrict access to specific domains - perfect for web applications.

        **Use cases:**

        * Production websites (`yourdapp.com`)
        * Development environments (`localhost:3000`)
        * Staging environments (`staging.yourdapp.com`)

        **Example configuration:**

        ```
        yourdapp.com
        www.yourdapp.com
        localhost:3000
        ```
      </Accordion>

      <Accordion title="Allowed IPs">
        Restrict access to specific IP addresses - ideal for server applications.

        **Use cases:**

        * Backend servers with static IPs
        * CI/CD pipelines
        * Specific development machines

        **Example configuration:**

        ```
        192.168.1.100
        203.0.113.1
        198.51.100.42
        ```
      </Accordion>

      <Accordion title="Allowed CIDRs">
        Restrict access to IP ranges using CIDR notation - great for enterprise networks.

        **Use cases:**

        * Corporate networks
        * Cloud provider IP ranges
        * Private networks

        **Example configuration:**

        ```
        192.168.0.0/16
        10.0.0.0/8
        172.16.0.0/12
        ```
      </Accordion>
    </AccordionGroup>
  </Tab>

  <Tab title="Secure URL">
    Use our secure URL for frontend applications without exposing your API key.

    <Info>
      **Rate Limited**: Secure URLs are limited to 5 transactions per second (TPS) per IP address, making them perfect for frontend applications.
    </Info>

    ### How to Use Secure URLs

    <Steps>
      <Step title="Get Your Secure URL">
        Find your secure URL in the Helius dashboard under the Endpoints section
      </Step>

      <Step title="Replace Your Regular RPC URL">
        Use the secure URL instead of your regular RPC URL with API key
      </Step>

      <Step title="No API Key Required">
        The secure URL doesn't require an API key parameter
      </Step>
    </Steps>

    ```javascript
    // Instead of this (exposes API key):
    const connection = new Connection('https://mainnet.helius-rpc.com/?api-key=YOUR_API_KEY');

    // Use this (secure, no API key exposed):
    const connection = new Connection('https://your-secure-url.helius-rpc.com');
    ```

    <Note>
      **Perfect for**: Frontend applications, mobile apps, and any client-side code where you can't hide the API key.
    </Note>
  </Tab>
</Tabs>

## Best Practices

<CardGroup cols={1}>
  <Card title="Environment Variables" icon="code">
    Never hardcode API keys in your source code. Use environment variables instead.

    ```javascript
    //  Don't do this
    const apiKey = "your-api-key-here";

    //  Do this instead
    const apiKey = process.env.HELIUS_API_KEY;
    ```
  </Card>

  <Card title="Separate Keys for Different Environments" icon="layers">
    Use different API keys for development, staging, and production environments.

    ```javascript
    const getApiKey = () => {
      switch (process.env.NODE_ENV) {
        case 'production':
          return process.env.HELIUS_API_KEY_PROD;
        case 'staging':
          return process.env.HELIUS_API_KEY_STAGING;
        default:
          return process.env.HELIUS_API_KEY_DEV;
      }
    };
    ```
  </Card>

  <Card title="Regular Key Rotation" icon="arrows-rotate">
    Rotate your API keys regularly and immediately if you suspect they've been compromised.

    <Steps>
      <Step title="Generate New Key">
        Create a new API key in your Helius dashboard
      </Step>

      <Step title="Update Applications">
        Update all applications to use the new key
      </Step>

      <Step title="Test Thoroughly">
        Ensure all services are working with the new key
      </Step>

      <Step title="Revoke Old Key">
        Delete the old key from your dashboard
      </Step>
    </Steps>
  </Card>

  <Card title="Monitor Usage" icon="chart-line">
    Regularly check your API usage in the Helius dashboard for unusual patterns.

    **Red flags to watch for:**

    * Sudden spikes in usage
    * Requests from unexpected locations
    * High error rates
    * Usage during off-hours
  </Card>
</CardGroup>

## Security Checklist

<AccordionGroup>
  <Accordion title=" Development Security">
    * [ ] Use environment variables for API keys
    * [ ] Never commit API keys to version control
    * [ ] Use different keys for different environments
    * [ ] Set up access control rules for development domains
    * [ ] Use secure URLs for frontend development
  </Accordion>

  <Accordion title=" Production Security">
    * [ ] Implement proper access control rules
    * [ ] Use RPC proxy for maximum security
    * [ ] Monitor API usage regularly
    * [ ] Set up alerts for unusual usage patterns
    * [ ] Rotate keys regularly
    * [ ] Document your security procedures
  </Accordion>

  <Accordion title=" Emergency Response">
    * [ ] Have a key rotation procedure ready
    * [ ] Know how to quickly revoke compromised keys
    * [ ] Monitor for security breaches
    * [ ] Have contact information for Helius support
    * [ ] Keep backups of your security configurations
  </Accordion>
</AccordionGroup>

## Common Mistakes to Avoid

<Warning>
  **Avoid these common security pitfalls:**

  1. **Hardcoding keys in frontend JavaScript** - Always use secure URLs or proxies
  2. **Committing keys to Git repositories** - Use environment variables and `.gitignore`
  3. **Using production keys for development** - Separate keys for different environments
  4. **Not setting access control rules** - Always configure domain/IP restrictions
  5. **Ignoring unusual usage patterns** - Monitor your dashboard regularly
</Warning>

## Need Help?

<CardGroup cols={2}>
  <Card title="Discord Community" icon="discord" href="https://discord.com/invite/6GXdee3gBj">
    Get help from the community and Helius team
  </Card>

  <Card title="Support Team" icon="headset" href="/support">
    Contact our support team for security concerns
  </Card>
</CardGroup>


# Solana WebSocket: Real-Time Blockchain Data Streaming
Source: https://www.helius.dev/docs/rpc/websocket

Stream real-time Solana blockchain data with WebSockets. Learn concepts, patterns, and production-ready implementations for account monitoring, transaction tracking, and DeFi applications.

## What Are WebSockets and Why Use Them?

WebSockets provide a persistent, real-time connection between your application and the Solana blockchain. Unlike traditional HTTP requests where you repeatedly ask "has anything changed?", WebSockets let the blockchain notify you instantly when something happens.

<CardGroup cols={2}>
  <Card title="Real-Time Updates" icon="bolt">
    Get notified instantly when accounts change, transactions occur, or blocks are produced
  </Card>

  <Card title="Efficient Resource Usage" icon="leaf">
    One persistent connection instead of polling hundreds of HTTP requests
  </Card>

  <Card title="Low Latency" icon="clock">
    Sub-second response times for time-critical trading and monitoring applications
  </Card>

  <Card title="Standard Protocol" icon="globe">
    Uses Solana's official WebSocket API - compatible with all Solana tooling
  </Card>
</CardGroup>

## Core Concepts

### Subscription Types

<AccordionGroup>
  <Accordion title="Account Subscriptions" icon="user">
    Monitor changes to specific accounts like wallet balances, token accounts, or program data.

    **Use cases:**

    * Wallet balance tracking
    * Token account monitoring
    * Smart contract state changes
    * NFT ownership updates
  </Accordion>

  <Accordion title="Program Subscriptions" icon="code">
    Watch all accounts owned by a specific program for any changes.

    **Use cases:**

    * DEX trade monitoring
    * DeFi protocol tracking
    * NFT marketplace activity
    * Gaming asset changes
  </Accordion>

  <Accordion title="Transaction Subscriptions" icon="receipt">
    Get notified when specific transactions are confirmed or when transactions mention certain accounts.

    **Use cases:**

    * Payment confirmations
    * Transaction status tracking
    * Multi-signature approvals
    * Contract execution monitoring
  </Accordion>

  <Accordion title="Slot Subscriptions" icon="clock">
    Monitor blockchain progression and finality at the slot level.

    **Use cases:**

    * Block explorer applications
    * Network health monitoring
    * Consensus tracking
    * Performance analytics
  </Accordion>
</AccordionGroup>

### Commitment Levels

Understanding commitment levels is crucial for reliable applications:

<Tabs>
  <Tab title="Processed">
    **Fastest** - Transaction processed by a validator but not confirmed

    * Latency: \~400ms
    * Risk: Can be dropped or reordered
    * Use for: Real-time UI updates (with caution)
  </Tab>

  <Tab title="Confirmed">
    **Balanced** - Majority of cluster has voted on the slot

    * Latency: \~2-3 seconds
    * Risk: Low chance of being dropped
    * Use for: Most applications
  </Tab>

  <Tab title="Finalized">
    **Safest** - Supermajority of cluster has voted on the slot

    * Latency: \~15-30 seconds
    * Risk: Extremely unlikely to be dropped
    * Use for: Financial applications, high-value transactions
  </Tab>
</Tabs>

<Info>
  **Want to learn more about commitment levels?** Read our comprehensive blog post: [Understanding Solana Commitment Levels](https://www.helius.dev/blog/solana-commitment-levels)
</Info>

## Available WebSocket Methods

The examples in this guide cover the most commonly used WebSocket methods, but Solana's WebSocket API offers many more subscription types for specialized use cases.

<Card title="Complete API Reference" icon="book" href="/api-reference/rpc/websocket-methods">
  **Explore all 18+ WebSocket methods**. Each method includes detailed parameters, response formats, and examples.
</Card>

## Implementing Robust Reconnection Logic

WebSocket connections can disconnect for various reasons - network issues, server maintenance, or temporary outages. Production applications **must** implement reconnection logic to ensure reliability.

### Why Disconnections Happen

<AccordionGroup>
  <Accordion title="Network Issues">
    * Internet connectivity problems
    * WiFi handoffs on mobile devices
    * Corporate firewall timeouts
    * ISP routing changes
  </Accordion>

  <Accordion title="Server-Side Events">
    * Planned maintenance windows
    * Load balancer restarts
    * RPC node updates
    * Temporary overload protection
  </Accordion>

  <Accordion title="Client-Side Issues">
    * Browser tab backgrounding
    * Mobile app suspension
    * Computer sleep/hibernation
    * Process crashes or restarts
  </Accordion>
</AccordionGroup>

### Detecting Disconnections

<Tabs>
  <Tab title="JavaScript/Browser">
    ```javascript [expandable]
    class ConnectionMonitor {
      constructor(ws) {
        this.ws = ws;
        this.pingInterval = null;
        this.lastPong = Date.now();
        this.isConnected = false;
        
        this.setupEventListeners();
        this.startPingMonitoring();
      }
      
      setupEventListeners() {
        this.ws.onopen = () => {
          console.log('Connected');
          this.isConnected = true;
          this.lastPong = Date.now();
        };
        
        this.ws.onclose = (event) => {
          console.log('Disconnected:', event.code, event.reason);
          this.isConnected = false;
          this.stopPingMonitoring();
        };
        
        this.ws.onerror = (error) => {
          console.error('WebSocket error:', error);
          this.isConnected = false;
        };
        
        // Listen for pong responses (server acknowledgment)
        this.ws.onmessage = (event) => {
          const data = JSON.parse(event.data);
          if (data.method === 'pong') {
            this.lastPong = Date.now();
          }
          // Handle other messages...
        };
      }
      
      startPingMonitoring() {
        this.pingInterval = setInterval(() => {
          if (this.isConnected) {
            // Send ping to check connection health
            this.ws.send(JSON.stringify({
              jsonrpc: '2.0',
              method: 'ping',
              id: Date.now()
            }));
            
            // Check if we received a pong recently
            const timeSinceLastPong = Date.now() - this.lastPong;
            if (timeSinceLastPong > 30000) { // 30 seconds timeout
              console.warn('No pong received, connection may be stale');
              this.ws.close();
            }
          }
        }, 10000); // Ping every 10 seconds
      }
      
      stopPingMonitoring() {
        if (this.pingInterval) {
          clearInterval(this.pingInterval);
          this.pingInterval = null;
        }
      }
    }
    ```
  </Tab>

  <Tab title="Node.js">
    ```javascript [expandable]
    const WebSocket = require('ws');

    class NodeConnectionMonitor {
      constructor(url) {
        this.url = url;
        this.ws = null;
        this.pingInterval = null;
        this.isAlive = false;
      }
      
      connect() {
        this.ws = new WebSocket(this.url);
        
        this.ws.on('open', () => {
          console.log('Connected');
          this.isAlive = true;
          this.startHeartbeat();
        });
        
        this.ws.on('close', () => {
          console.log('Disconnected');
          this.isAlive = false;
          this.stopHeartbeat();
        });
        
        this.ws.on('error', (error) => {
          console.error('WebSocket error:', error);
          this.isAlive = false;
        });
        
        // Built-in ping/pong handling
        this.ws.on('pong', () => {
          this.isAlive = true;
        });
      }
      
      startHeartbeat() {
        this.pingInterval = setInterval(() => {
          if (!this.isAlive) {
            console.log('Connection lost, terminating');
            return this.ws.terminate();
          }
          
          this.isAlive = false;
          this.ws.ping();
        }, 30000); // Ping every 30 seconds
      }
      
      stopHeartbeat() {
        if (this.pingInterval) {
          clearInterval(this.pingInterval);
          this.pingInterval = null;
        }
      }
    }
    ```
  </Tab>
</Tabs>

### Reconnection Strategies

<Tabs>
  <Tab title="Exponential Backoff">
    ```javascript [expandable]
    class ExponentialBackoffReconnector {
      constructor(url, maxRetries = 10) {
        this.url = url;
        this.maxRetries = maxRetries;
        this.retryCount = 0;
        this.baseDelay = 1000; // Start with 1 second
        this.maxDelay = 30000; // Cap at 30 seconds
        this.ws = null;
        this.subscriptions = new Map();
        this.isReconnecting = false;
      }
      
      connect() {
        if (this.isReconnecting) return;
        
        try {
          this.ws = new WebSocket(this.url);
          this.setupEventHandlers();
        } catch (error) {
          console.error('Failed to create WebSocket:', error);
          this.scheduleReconnect();
        }
      }
      
      setupEventHandlers() {
        this.ws.onopen = () => {
          console.log('Connected successfully');
          this.retryCount = 0; // Reset retry count on successful connection
          this.isReconnecting = false;
          this.resubscribeAll(); // Restore subscriptions
        };
        
        this.ws.onclose = (event) => {
          console.log('Connection closed:', event.code);
          if (!this.isReconnecting) {
            this.scheduleReconnect();
          }
        };
        
        this.ws.onerror = (error) => {
          console.error('WebSocket error:', error);
        };
      }
      
      scheduleReconnect() {
        if (this.retryCount >= this.maxRetries) {
          console.error('Max retry attempts reached. Giving up.');
          return;
        }
        
        this.isReconnecting = true;
        this.retryCount++;
        
        // Calculate delay with exponential backoff + jitter
        const delay = Math.min(
          this.baseDelay * Math.pow(2, this.retryCount - 1),
          this.maxDelay
        );
        
        // Add jitter to prevent thundering herd
        const jitteredDelay = delay + (Math.random() * 1000);
        
        console.log(`Reconnecting in ${jitteredDelay}ms (attempt ${this.retryCount}/${this.maxRetries})`);
        
        setTimeout(() => {
          this.connect();
        }, jitteredDelay);
      }
      
      subscribe(method, params, callback) {
        const id = this.generateId();
        this.subscriptions.set(id, { method, params, callback });
        
        if (this.ws && this.ws.readyState === WebSocket.OPEN) {
          this.sendSubscription(id, method, params);
        }
        
        return id;
      }
      
      resubscribeAll() {
        console.log(`Restoring ${this.subscriptions.size} subscriptions`);
        for (const [id, sub] of this.subscriptions) {
          this.sendSubscription(id, sub.method, sub.params);
        }
      }
      
      sendSubscription(id, method, params) {
        this.ws.send(JSON.stringify({
          jsonrpc: '2.0',
          id: id,
          method: method,
          params: params
        }));
      }
      
      generateId() {
        return Date.now() + Math.random();
      }
    }
    ```
  </Tab>

  <Tab title="Circuit Breaker Pattern">
    ```javascript [expandable]
    class CircuitBreakerWebSocket {
      constructor(url, options = {}) {
        this.url = url;
        this.failureThreshold = options.failureThreshold || 5;
        this.recoveryTimeout = options.recoveryTimeout || 60000;
        this.checkInterval = options.checkInterval || 10000;
        
        this.state = 'CLOSED'; // CLOSED, OPEN, HALF_OPEN
        this.failureCount = 0;
        this.lastFailureTime = null;
        this.ws = null;
        this.subscriptions = new Map();
      }
      
      connect() {
        if (this.state === 'OPEN') {
          if (Date.now() - this.lastFailureTime > this.recoveryTimeout) {
            console.log('Circuit breaker moving to HALF_OPEN state');
            this.state = 'HALF_OPEN';
          } else {
            console.log('Circuit breaker is OPEN, connection blocked');
            return false;
          }
        }
        
        try {
          this.ws = new WebSocket(this.url);
          this.setupEventHandlers();
          return true;
        } catch (error) {
          this.recordFailure();
          return false;
        }
      }
      
      setupEventHandlers() {
        this.ws.onopen = () => {
          console.log('Connected - Circuit breaker CLOSED');
          this.state = 'CLOSED';
          this.failureCount = 0;
          this.resubscribeAll();
        };
        
        this.ws.onclose = () => {
          this.recordFailure();
        };
        
        this.ws.onerror = (error) => {
          console.error('WebSocket error:', error);
          this.recordFailure();
        };
      }
      
      recordFailure() {
        this.failureCount++;
        this.lastFailureTime = Date.now();
        
        console.log(`Failure recorded: ${this.failureCount}/${this.failureThreshold}`);
        
        if (this.failureCount >= this.failureThreshold) {
          console.log('Circuit breaker opened due to repeated failures');
          this.state = 'OPEN';
        }
      }
      
      startHealthCheck() {
        setInterval(() => {
          if (this.state === 'OPEN' || 
              (this.ws && this.ws.readyState !== WebSocket.OPEN)) {
            this.connect();
          }
        }, this.checkInterval);
      }
    }
    ```
  </Tab>
</Tabs>

### Testing Reconnection Logic

<Tabs>
  <Tab title="Network Simulation">
    ```javascript [expandable]
    // Test disconnection scenarios
    class NetworkSimulator {
      constructor(wsManager) {
        this.wsManager = wsManager;
      }
      
      // Simulate network outage
      simulateNetworkOutage(duration = 5000) {
        console.log('Simulating network outage...');
        
        // Force close the connection
        if (this.wsManager.ws) {
          this.wsManager.ws.close(1006, 'Network outage simulation');
        }
        
        // Block reconnection temporarily
        const originalConnect = this.wsManager.connect.bind(this.wsManager);
        this.wsManager.connect = () => {
          console.log('Connection blocked during outage simulation');
        };
        
        // Restore connection after duration
        setTimeout(() => {
          console.log('Network restored');
          this.wsManager.connect = originalConnect;
          this.wsManager.connect();
        }, duration);
      }
      
      // Simulate intermittent connectivity
      simulateIntermittentConnectivity() {
        setInterval(() => {
          if (Math.random() < 0.1) { // 10% chance every 10 seconds
            console.log('Simulating connection drop...');
            this.wsManager.ws?.close(1006, 'Intermittent connectivity');
          }
        }, 10000);
      }
    }

    // Usage
    const simulator = new NetworkSimulator(wsManager);
    simulator.simulateNetworkOutage(10000); // 10 second outage
    ```
  </Tab>

  <Tab title="Automated Testing">
    ```javascript [expandable]
    // Jest test example
    describe('WebSocket Reconnection', () => {
      let wsManager;
      
      beforeEach(() => {
        wsManager = new ProductionWebSocketManager({
          endpoint: 'ws://localhost:8080',
          apiKey: 'test-key'
        });
      });
      
      test('should reconnect after connection loss', async () => {
        const reconnectPromise = new Promise((resolve) => {
          wsManager.on('connected', resolve);
        });
        
        await wsManager.connect();
        
        // Simulate connection loss
        wsManager.ws.close(1006, 'Test disconnection');
        
        // Wait for reconnection
        await reconnectPromise;
        
        expect(wsManager.connectionState).toBe('CONNECTED');
        expect(wsManager.metrics.reconnections).toBeGreaterThan(0);
      });
      
      test('should restore subscriptions after reconnection', async () => {
        await wsManager.connect();
        
        const messages = [];
        const subscriptionId = wsManager.subscribe(
          'accountSubscribe',
          ['test-account', {}],
          (data) => messages.push(data)
        );
        
        // Verify subscription exists
        expect(wsManager.subscriptions.has(subscriptionId)).toBe(true);
        
        // Simulate disconnection and reconnection
        wsManager.ws.close(1006, 'Test disconnection');
        
        await new Promise(resolve => wsManager.on('connected', resolve));
        
        // Verify subscription was restored
        const subscription = wsManager.subscriptions.get(subscriptionId);
        expect(subscription.pending).toBe(true); // Should be re-subscribing
      });
    });
    ```
  </Tab>
</Tabs>

<Warning>
  **Critical for Production**: Implementing proper reconnection logic is not optional for production applications. WebSocket connections will disconnect - plan for it, test it, and monitor it in production.
</Warning>

## Troubleshooting

<AccordionGroup>
  <Accordion title="Connection Failed">
    **Symptoms**: WebSocket fails to connect initially

    **Solutions**:

    * Verify your API key is correct and has sufficient credits
    * Check the endpoint URL format: `wss://mainnet.helius-rpc.com?api-key=YOUR_KEY`
    * Ensure your firewall allows WebSocket connections on port 443
    * Test with a simple ping first to verify basic connectivity
  </Accordion>

  <Accordion title="Frequent Disconnections">
    **Symptoms**: Connection drops every few minutes

    **Solutions**:

    * Implement proper ping/pong heartbeat (shown in reconnection examples above)
    * Check your network stability and corporate firewall settings
    * Monitor your subscription count - too many can cause instability
    * Verify you're handling the connection lifecycle properly
  </Accordion>

  <Accordion title="Missing Messages">
    **Symptoms**: Not receiving expected subscription updates

    **Solutions**:

    * Verify your subscription is confirmed (check the response)
    * Ensure the account/program you're monitoring has actual activity
    * Monitor your connection state - missed messages often indicate disconnections
  </Accordion>

  <Accordion title="High Latency">
    **Symptoms**: Slow message delivery, delays in updates

    **Solutions**:

    * Use "confirmed" instead of "finalized" commitment
    * Reduce the number of active subscriptions
    * Optimize your message processing logic
    * Consider using multiple connections to distribute load
    * Check your network connection quality
  </Accordion>

  <Accordion title="Memory Leaks">
    **Symptoms**: Application memory usage grows over time

    **Solutions**:

    * Implement proper subscription cleanup
    * Remove event listeners when components unmount
    * Clear message logs periodically
    * Monitor subscription count and enforce limits
    * Use weak references for callback functions where possible
  </Accordion>
</AccordionGroup>

## Migration from Standard RPC

If you're currently using HTTP polling, here's how to migrate to WebSockets:

```javascript [expandable]
// Old approach - HTTP polling
class HTTPAccountMonitor {
  constructor(connection, accountAddress) {
    this.connection = connection;
    this.accountAddress = accountAddress;
    this.interval = null;
    this.lastKnownBalance = null;
  }

  start() {
    this.interval = setInterval(async () => {
      try {
        const accountInfo = await this.connection.getAccountInfo(
          new PublicKey(this.accountAddress)
        );
        
        const currentBalance = accountInfo?.lamports || 0;
        
        if (this.lastKnownBalance !== currentBalance) {
          console.log(`Balance changed: ${currentBalance}`);
          this.lastKnownBalance = currentBalance;
        }
      } catch (error) {
        console.error('Failed to fetch account info:', error);
      }
    }, 2000); // Poll every 2 seconds
  }

  stop() {
    if (this.interval) {
      clearInterval(this.interval);
      this.interval = null;
    }
  }
}

// New approach - WebSocket subscription
class WebSocketAccountMonitor {
  constructor(wsManager, accountAddress) {
    this.wsManager = wsManager;
    this.accountAddress = accountAddress;
    this.subscriptionId = null;
  }

  start() {
    this.subscriptionId = this.wsManager.subscribe(
      'accountSubscribe',
      [
        this.accountAddress,
        { encoding: 'jsonParsed', commitment: 'confirmed' }
      ],
      (data) => {
        const currentBalance = data.value.lamports;
        console.log(`Balance changed: ${currentBalance}`);
        
        // Handle the change immediately - no polling delay!
      }
    );
  }

  stop() {
    if (this.subscriptionId) {
      this.wsManager.unsubscribe(this.subscriptionId);
      this.subscriptionId = null;
    }
  }
}
```

## Enhanced Capabilities

For applications requiring even more advanced features, consider using [LaserStream gRPC](/laserstream):

<CardGroup cols={2}>
  <Card title="Historical Replay" icon="clock-rotate-left">
    Catch up on missed data when your application was offline
  </Card>

  <Card title="Multi-Node Aggregation" icon="network-wired">
    Enhanced reliability through data from multiple validator nodes
  </Card>

  <Card title="Higher Throughput" icon="gauge-high">
    Handle more subscriptions and higher message rates
  </Card>

  <Card title="Enterprise Features" icon="building">
    Advanced monitoring, analytics, and custom data pipelines
  </Card>
</CardGroup>

<Note>
  **Ready to Get Started?** Check out our [WebSocket Quickstart Guide](/rpc/websocket/quickstart) for practical examples and step-by-step implementation guides.
</Note>


# WebSocket Quickstart: Build Real-Time Solana Apps
Source: https://www.helius.dev/docs/rpc/websocket/quickstart

Get started with Solana WebSockets in minutes. Step-by-step guide with practical examples for account monitoring, transaction tracking, and real-time applications.

Ready to add real-time blockchain data to your application? This guide will get you connected and subscribing to Solana data in minutes.

## Quick Start Guide

<Steps>
  <Step title="Get Your API Key">
    Obtain your Helius API key from the [dashboard](https://dashboard.helius.dev). You'll need this for authentication.
  </Step>

  <Step title="Choose Your Network">
    Select the appropriate endpoint:

    * **Mainnet**: `wss://mainnet.helius-rpc.com/?api-key=YOUR_API_KEY`
    * **Devnet**: `wss://devnet.helius-rpc.com/?api-key=YOUR_API_KEY`
  </Step>

  <Step title="Create Your First Connection">
    ```javascript
    const ws = new WebSocket('wss://mainnet.helius-rpc.com/?api-key=YOUR_API_KEY');

    ws.onopen = () => {
      console.log('Connected to Solana!');
    };

    ws.onmessage = (event) => {
      const data = JSON.parse(event.data);
      console.log('Received:', data);
    };
    ```
  </Step>

  <Step title="Subscribe to Updates">
    ```javascript
    // Subscribe to account changes
    const subscribeMessage = {
      "jsonrpc": "2.0",
      "id": 1,
      "method": "accountSubscribe",
      "params": [
        "ACCOUNT_ADDRESS_HERE",
        { "commitment": "confirmed" }
      ]
    };

    ws.send(JSON.stringify(subscribeMessage));
    ```
  </Step>
</Steps>

## Subscription Methods

### Account Monitoring

Monitor specific accounts for balance changes, data updates, or ownership transfers.

<CodeGroup>
  ```javascript Basic Account Subscription
  const ws = new WebSocket('wss://mainnet.helius-rpc.com/?api-key=YOUR_API_KEY');

  const subscribeToAccount = (accountAddress) => {
    const request = {
      "jsonrpc": "2.0",
      "id": 1,
      "method": "accountSubscribe",
      "params": [
        accountAddress,
        {
          "encoding": "jsonParsed",
          "commitment": "confirmed"
        }
      ]
    };
    
    ws.send(JSON.stringify(request));
  };

  ws.onmessage = (event) => {
    const data = JSON.parse(event.data);
    
    if (data.method === "accountNotification") {
      console.log("Account updated:", data.params.result.value);
      
      // Handle the account change
      const accountInfo = data.params.result.value;
      console.log(`New balance: ${accountInfo.lamports} lamports`);
    }
  };

  // Subscribe to a wallet address
  subscribeToAccount("9PejEmViKHgUkVFWN57cNEZnFS4Qo6SzsLj5UPAXfDTF");
  ```

  ```javascript Token Account Monitoring
  const ws = new WebSocket('wss://mainnet.helius-rpc.com/?api-key=YOUR_API_KEY');

  // Monitor a token account for balance changes
  const monitorTokenAccount = (tokenAccountAddress) => {
    const request = {
      "jsonrpc": "2.0",
      "id": 2,
      "method": "accountSubscribe",
      "params": [
        tokenAccountAddress,
        {
          "encoding": "jsonParsed",
          "commitment": "confirmed"
        }
      ]
    };
    
    ws.send(JSON.stringify(request));
  };

  ws.onmessage = (event) => {
    const data = JSON.parse(event.data);
    
    if (data.method === "accountNotification") {
      const accountData = data.params.result.value.data;
      
      if (accountData.program === "spl-token") {
        const parsed = accountData.parsed;
        console.log(`Token balance: ${parsed.info.tokenAmount.uiAmount}`);
        console.log(`Owner: ${parsed.info.owner}`);
      }
    }
  };
  ```
</CodeGroup>

### Program Activity Monitoring

Watch all accounts owned by a program - perfect for monitoring DEX trades, NFT transfers, or DeFi activity.

<CodeGroup>
  ```javascript DEX Trade Monitoring
  // Monitor Raydium AMM for all trade activity
  const RAYDIUM_AMM_PROGRAM = "675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8";

  const subscribeToProgram = (programId) => {
    const request = {
      "jsonrpc": "2.0",
      "id": 3,
      "method": "programSubscribe",
      "params": [
        programId,
        {
          "encoding": "jsonParsed",
          "commitment": "confirmed",
          "filters": [
            {
              "dataSize": 752 // Raydium pool account size
            }
          ]
        }
      ]
    };
    
    ws.send(JSON.stringify(request));
  };

  ws.onmessage = (event) => {
    const data = JSON.parse(event.data);
    
    if (data.method === "programNotification") {
      console.log("Raydium pool updated:", data.params.result.value.pubkey);
      // Process the pool data change
      const accountData = data.params.result.value.account;
      // Parse and handle the pool state change
    }
  };

  subscribeToProgram(RAYDIUM_AMM_PROGRAM);
  ```

  ```javascript NFT Marketplace Monitoring  
  // Monitor Magic Eden program for NFT activity
  const MAGIC_EDEN_PROGRAM = "M2mx93ekt1fmXSVkTrUL9xVFHkmME8HTUi5Cyc5aF7K";

  const subscribeToNFTActivity = () => {
    const request = {
      "jsonrpc": "2.0",
      "id": 4,
      "method": "programSubscribe",
      "params": [
        MAGIC_EDEN_PROGRAM,
        {
          "encoding": "base64",
          "commitment": "confirmed"
        }
      ]
    };
    
    ws.send(JSON.stringify(request));
  };

  ws.onmessage = (event) => {
    const data = JSON.parse(event.data);
    
    if (data.method === "programNotification") {
      console.log("NFT marketplace activity detected");
      // Decode and process the marketplace instruction
      const accountInfo = data.params.result.value;
      // Handle NFT listing, purchase, or cancellation
    }
  };
  ```
</CodeGroup>

### Transaction Monitoring

Track specific transactions or monitor transactions that mention certain accounts.

<CodeGroup>
  ```javascript Transaction Status Tracking
  // Monitor a specific transaction signature
  const trackTransaction = (signature) => {
    const request = {
      "jsonrpc": "2.0",
      "id": 5,
      "method": "signatureSubscribe",
      "params": [
        signature,
        {
          "commitment": "confirmed"
        }
      ]
    };
    
    ws.send(JSON.stringify(request));
  };

  ws.onmessage = (event) => {
    const data = JSON.parse(event.data);
    
    if (data.method === "signatureNotification") {
      const result = data.params.result;
      
      if (result.value.err) {
        console.log("Transaction failed:", result.value.err);
      } else {
        console.log("Transaction confirmed successfully!");
      }
      
      // Subscription automatically ends after notification
    }
  };

  // Track a payment or swap transaction
  trackTransaction("YOUR_TRANSACTION_SIGNATURE_HERE");
  ```

  ```javascript Log-Based Monitoring
  // Monitor all transactions mentioning a specific address
  const monitorAddress = (address) => {
    const request = {
      "jsonrpc": "2.0",
      "id": 6,
      "method": "logsSubscribe",
      "params": [
        {
          "mentions": [address]
        },
        {
          "commitment": "confirmed"
        }
      ]
    };
    
    ws.send(JSON.stringify(request));
  };

  ws.onmessage = (event) => {
    const data = JSON.parse(event.data);
    
    if (data.method === "logsNotification") {
      const logs = data.params.result.value.logs;
      const signature = data.params.result.value.signature;
      
      console.log(`Transaction ${signature} mentioned our address`);
      console.log("Logs:", logs);
      
      // Parse logs for specific events or errors
      if (logs.some(log => log.includes("Program failed"))) {
        console.log("Transaction failed!");
      }
    }
  };

  // Monitor a token mint for all activity
  monitorAddress("EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v");
  ```
</CodeGroup>

## Production-Ready Implementation

Here's a robust WebSocket implementation with reconnection logic, error handling, and proper state management:

```javascript [expandable]
class WebSocketManager {
  constructor(endpoint) {
    this.endpoint = endpoint;
    this.ws = null;
    this.subscriptions = new Map();
    this.isConnected = false;
  }

  async connect() {
    this.ws = new WebSocket(this.endpoint);
    
    this.ws.onopen = () => {
      console.log('Connected');
      this.isConnected = true;
      this.resubscribeAll();
    };

    this.ws.onmessage = (event) => {
      const data = JSON.parse(event.data);
      
      // Handle subscription confirmations
      if (data.result && typeof data.result === 'number') {
        const sub = Array.from(this.subscriptions.values())
          .find(s => s.requestId === data.id);
        if (sub) sub.subscriptionId = data.result;
        return;
      }

      // Handle notifications
      if (data.method?.endsWith('Notification')) {
        const sub = Array.from(this.subscriptions.values())
          .find(s => s.subscriptionId === data.params.subscription);
        if (sub?.callback) sub.callback(data.params.result);
      }
    };

    this.ws.onclose = () => {
      console.log('Disconnected');
      this.isConnected = false;
      // Implement reconnection logic here
    };
  }

  subscribe(method, params, callback) {
    const requestId = Date.now();
    const subscription = { requestId, method, params, callback, subscriptionId: null };
    this.subscriptions.set(requestId, subscription);
    
    if (this.isConnected) {
      this.ws.send(JSON.stringify({
        jsonrpc: '2.0',
        id: requestId,
        method,
        params
      }));
    }
    
    return requestId;
  }

  resubscribeAll() {
    for (const [id, sub] of this.subscriptions) {
      sub.subscriptionId = null;
      this.ws.send(JSON.stringify({
        jsonrpc: '2.0',
        id,
        method: sub.method,
        params: sub.params
      }));
    }
  }
}

// Usage
const wsManager = new WebSocketManager('wss://mainnet.helius-rpc.com/?api-key=YOUR_API_KEY');
await wsManager.connect();

// Subscribe to account changes
wsManager.subscribe(
  'accountSubscribe',
  ['account-address-here', { commitment: 'confirmed' }],
  (data) => console.log('Account updated:', data)
);
```

## Explore More WebSocket Methods

The examples above cover the most commonly used subscription types, but Solana's WebSocket API offers many more methods for specialized monitoring needs.

<Card title="Complete WebSocket API Reference" icon="book" href="/api-reference/rpc/websocket-methods">
  **Discover 18+ WebSocket methods** with detailed documentation, parameters, and response formats.
</Card>

## Real-World Use Cases

### DeFi Trading Dashboard

```javascript [expandable]
class LiquidityPoolMonitor {
  constructor(wsManager) {
    this.wsManager = wsManager;
    this.pools = new Map();
  }

  monitorPool(poolAddress, tokenAMint, tokenBMint) {
    // Monitor the pool account itself
    const poolSubscription = this.wsManager.subscribe(
      'accountSubscribe',
      [poolAddress, { encoding: 'base64', commitment: 'confirmed' }],
      (data) => this.handlePoolUpdate(poolAddress, data)
    );

    // Monitor token reserves
    const tokenASubscription = this.wsManager.subscribe(
      'accountSubscribe', 
      [tokenAMint, { encoding: 'jsonParsed', commitment: 'confirmed' }],
      (data) => this.handleReserveUpdate(poolAddress, 'tokenA', data)
    );

    const tokenBSubscription = this.wsManager.subscribe(
      'accountSubscribe',
      [tokenBMint, { encoding: 'jsonParsed', commitment: 'confirmed' }],
      (data) => this.handleReserveUpdate(poolAddress, 'tokenB', data)
    );

    this.pools.set(poolAddress, {
      poolSubscription,
      tokenASubscription, 
      tokenBSubscription,
      lastUpdate: Date.now()
    });
  }

  handlePoolUpdate(poolAddress, data) {
    // Decode pool state and calculate price
    const poolState = this.decodePoolState(data.value.data);
    
    console.log(`Pool ${poolAddress} updated:`);
    console.log(`- Price: ${poolState.price}`);
    console.log(`- Liquidity: ${poolState.liquidity}`);
    console.log(`- Volume 24h: ${poolState.volume24h}`);
    
    // Emit price update event
    this.emitPriceUpdate(poolAddress, poolState);
  }

  handleReserveUpdate(poolAddress, tokenType, data) {
    const tokenAmount = data.value.data.parsed.info.tokenAmount;
    console.log(`${tokenType} reserve updated: ${tokenAmount.uiAmount}`);
    
    // Update internal state and recalculate price
    this.updatePoolPrice(poolAddress, tokenType, tokenAmount);
  }

  decodePoolState(data) {
    // Implement pool state decoding based on DEX
    // This is pseudo-code - actual implementation depends on the DEX
    return {
      price: 0,
      liquidity: 0,
      volume24h: 0
    };
  }

  emitPriceUpdate(poolAddress, poolState) {
    // Emit custom events for price updates
    window.dispatchEvent(new CustomEvent('poolPriceUpdate', {
      detail: { poolAddress, ...poolState }
    }));
  }
}

// Usage
const poolMonitor = new LiquidityPoolMonitor(wsManager);
poolMonitor.monitorPool(
  'POOL_ADDRESS',
  'TOKEN_A_MINT', 
  'TOKEN_B_MINT'
);
```

### Portfolio Tracker

```javascript [expandable]
class PortfolioTracker {
  constructor(wsManager) {
    this.wsManager = wsManager;
    this.watchedAddresses = new Set();
    this.balances = new Map();
  }

  addWallet(walletAddress) {
    if (this.watchedAddresses.has(walletAddress)) return;

    this.watchedAddresses.add(walletAddress);
    
    // Monitor SOL balance
    const solSubscription = this.wsManager.subscribe(
      'accountSubscribe',
      [walletAddress, { encoding: 'jsonParsed', commitment: 'confirmed' }],
      (data) => this.handleSolBalanceUpdate(walletAddress, data)
    );

    // Monitor all token accounts owned by this wallet
    const tokenSubscription = this.wsManager.subscribe(
      'programSubscribe',
      [
        'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA',
        {
          encoding: 'jsonParsed',
          commitment: 'confirmed',
          filters: [
            { memcmp: { offset: 32, bytes: walletAddress } }
          ]
        }
      ],
      (data) => this.handleTokenBalanceUpdate(walletAddress, data)
    );

    console.log(`Now tracking portfolio for ${walletAddress}`);
  }

  handleSolBalanceUpdate(walletAddress, data) {
    const lamports = data.value.lamports;
    const solBalance = lamports / 1e9;
    
    this.balances.set(`${walletAddress}:SOL`, solBalance);
    
    console.log(`${walletAddress} SOL balance: ${solBalance}`);
    this.emitBalanceUpdate(walletAddress, 'SOL', solBalance);
  }

  handleTokenBalanceUpdate(walletAddress, data) {
    const tokenData = data.value.account.data.parsed.info;
    const tokenMint = tokenData.mint;
    const balance = parseFloat(tokenData.tokenAmount.uiAmount);
    
    this.balances.set(`${walletAddress}:${tokenMint}`, balance);
    
    console.log(`${walletAddress} token ${tokenMint} balance: ${balance}`);
    this.emitBalanceUpdate(walletAddress, tokenMint, balance);
  }

  emitBalanceUpdate(walletAddress, asset, balance) {
    window.dispatchEvent(new CustomEvent('balanceUpdate', {
      detail: { walletAddress, asset, balance, timestamp: Date.now() }
    }));
  }

  getPortfolioValue(walletAddress) {
    // Calculate total portfolio value in USD
    // This would integrate with price feeds
    let totalValue = 0;
    
    for (const [key, balance] of this.balances) {
      if (key.startsWith(walletAddress)) {
        const asset = key.split(':')[1];
        const price = this.getAssetPrice(asset); // Implement price lookup
        totalValue += balance * price;
      }
    }
    
    return totalValue;
  }
}
```

### NFT Marketplace Integration

```javascript [expandable]
class NFTActivityMonitor {
  constructor(wsManager) {
    this.wsManager = wsManager;
    this.watchedCollections = new Map();
  }

  monitorCollection(collectionAddress, options = {}) {
    const { includeListings = true, includeSales = true, includeCancellations = true } = options;

    // Monitor the collection's update authority or creator address
    const collectionSubscription = this.wsManager.subscribe(
      'logsSubscribe',
      [
        { mentions: [collectionAddress] },
        { commitment: 'confirmed' }
      ],
      (data) => this.handleCollectionActivity(collectionAddress, data)
    );

    this.watchedCollections.set(collectionAddress, {
      subscription: collectionSubscription,
      options,
      stats: {
        listings: 0,
        sales: 0,
        volume: 0
      }
    });

    console.log(`Monitoring NFT collection: ${collectionAddress}`);
  }

  handleCollectionActivity(collectionAddress, data) {
    const logs = data.value.logs;
    const signature = data.value.signature;

    // Parse marketplace-specific logs
    const activity = this.parseMarketplaceActivity(logs);
    
    if (activity) {
      console.log(`NFT Activity in ${collectionAddress}:`);
      console.log(`- Type: ${activity.type}`);
      console.log(`- Price: ${activity.price} SOL`);
      console.log(`- Signature: ${signature}`);

      // Update collection stats
      this.updateCollectionStats(collectionAddress, activity);
      
      // Emit activity event
      this.emitNFTActivity(collectionAddress, activity, signature);
    }
  }

  parseMarketplaceActivity(logs) {
    // Parse Magic Eden, OpenSea, or other marketplace logs
    for (const log of logs) {
      // Magic Eden listing
      if (log.includes('Instruction: List')) {
        const price = this.extractPriceFromLog(log);
        return { type: 'listing', price };
      }
      
      // Magic Eden sale
      if (log.includes('Instruction: ExecuteSale')) {
        const price = this.extractPriceFromLog(log);
        return { type: 'sale', price };
      }
      
      // Listing cancellation
      if (log.includes('Instruction: CancelBuy') || log.includes('Instruction: CancelSell')) {
        return { type: 'cancellation', price: 0 };
      }
    }
    
    return null;
  }

  extractPriceFromLog(log) {
    // Extract price from marketplace logs - implementation depends on marketplace
    // This is pseudo-code
    const priceMatch = log.match(/price:\s*(\d+)/);
    return priceMatch ? parseInt(priceMatch[1]) / 1e9 : 0;
  }

  updateCollectionStats(collectionAddress, activity) {
    const collection = this.watchedCollections.get(collectionAddress);
    if (!collection) return;

    switch (activity.type) {
      case 'listing':
        collection.stats.listings++;
        break;
      case 'sale':
        collection.stats.sales++;
        collection.stats.volume += activity.price;
        break;
    }
  }

  emitNFTActivity(collectionAddress, activity, signature) {
    window.dispatchEvent(new CustomEvent('nftActivity', {
      detail: {
        collection: collectionAddress,
        activity,
        signature,
        timestamp: Date.now()
      }
    }));
  }
}
```

### React Integration Example

```javascript [expandable]
import React, { useEffect, useState } from 'react';

function WebSocketComponent() {
  const [accountData, setAccountData] = useState(null);
  const [wsManager, setWsManager] = useState(null);

  useEffect(() => {
    // Initialize WebSocket
    const manager = new WebSocketManager('wss://mainnet.helius-rpc.com/?api-key=YOUR_API_KEY');
    
    manager.connect().then(() => {
      // Subscribe to account changes
      manager.subscribe(
        'accountSubscribe',
        ['account-address-here', { commitment: 'confirmed' }],
        (data) => setAccountData(data)
      );
    });

    setWsManager(manager);

    // Cleanup on unmount
    return () => {
      if (manager) manager.disconnect();
    };
  }, []);

  return (
    <div>
      <h3>Account Monitor</h3>
      {accountData ? (
        <div>
          <p>Balance: {accountData.value.lamports} lamports</p>
          <p>Owner: {accountData.value.owner}</p>
        </div>
      ) : (
        <p>Waiting for account updates...</p>
      )}
    </div>
  );
}
```

## Performance Optimization

<Tabs>
  <Tab title="Connection Management">
    ```javascript [expandable]
    // Use connection pooling for multiple subscriptions
    class WebSocketPool {
      constructor(endpoint, maxConnections = 3) {
        this.endpoint = endpoint;
        this.connections = [];
        this.maxConnections = maxConnections;
        this.currentConnectionIndex = 0;
      }
      
      async getConnection() {
        if (this.connections.length < this.maxConnections) {
          const wsManager = new SolanaWebSocketManager(this.endpoint);
          await wsManager.connect();
          this.connections.push(wsManager);
          return wsManager;
        }
        
        // Round-robin selection
        const connection = this.connections[this.currentConnectionIndex];
        this.currentConnectionIndex = (this.currentConnectionIndex + 1) % this.connections.length;
        return connection;
      }
    }
    ```
  </Tab>

  <Tab title="Memory Management">
    ```javascript [expandable]
    // Implement subscription cleanup and memory management
    class ManagedWebSocket extends SolanaWebSocketManager {
      constructor(endpoint, options = {}) {
        super(endpoint, options);
        this.maxSubscriptions = options.maxSubscriptions || 100;
        this.subscriptionHistory = [];
      }
      
      subscribe(method, params, callback) {
        // Check subscription limit
        if (this.subscriptions.size >= this.maxSubscriptions) {
          this.cleanupOldSubscriptions();
        }
        
        const requestId = super.subscribe(method, params, callback);
        
        // Track subscription for cleanup
        this.subscriptionHistory.push({
          requestId,
          timestamp: Date.now(),
          method
        });
        
        return requestId;
      }
      
      cleanupOldSubscriptions() {
        // Remove oldest 10% of subscriptions
        const toRemove = Math.floor(this.subscriptions.size * 0.1);
        const sortedHistory = this.subscriptionHistory
          .sort((a, b) => a.timestamp - b.timestamp);
        
        for (let i = 0; i < toRemove && i < sortedHistory.length; i++) {
          const sub = sortedHistory[i];
          this.unsubscribe(sub.requestId);
          
          // Remove from history
          this.subscriptionHistory = this.subscriptionHistory
            .filter(s => s.requestId !== sub.requestId);
        }
      }
    }
    ```
  </Tab>
</Tabs>

## Error Handling and Debugging

<Info>
  Robust error handling is crucial for production WebSocket applications. Implement these patterns to handle network issues, rate limits, and API errors gracefully.
</Info>

```javascript [expandable]
class ErrorHandlingWebSocket extends SolanaWebSocketManager {
  constructor(endpoint, options = {}) {
    super(endpoint, options);
    this.errorCounts = new Map();
    this.maxErrorsPerMinute = options.maxErrorsPerMinute || 10;
  }

  handleMessage(data) {
    try {
      // Handle rate limiting
      if (data.error && data.error.code === 429) {
        console.warn('Rate limited, backing off...');
        this.handleRateLimit();
        return;
      }

      // Handle subscription errors
      if (data.error && data.error.code === -32602) {
        console.error('Invalid subscription parameters:', data.error.message);
        this.handleInvalidSubscription(data.id);
        return;
      }

      // Handle network errors
      if (data.error && data.error.code === -32603) {
        console.error('Internal server error:', data.error.message);
        this.handleServerError();
        return;
      }

      super.handleMessage(data);
    } catch (error) {
      console.error('Error processing WebSocket message:', error);
      this.incrementErrorCount('message_processing');
    }
  }

  handleRateLimit() {
    // Exponential backoff for rate limiting
    const backoffDelay = Math.min(1000 * Math.pow(2, this.reconnectAttempts), 30000);
    
    setTimeout(() => {
      if (this.subscriptions.size > 0) {
        console.log('Retrying after rate limit...');
        this.resubscribeAll();
      }
    }, backoffDelay);
  }

  handleInvalidSubscription(requestId) {
    // Remove invalid subscription
    const subscription = Array.from(this.subscriptions.entries())
      .find(([id, sub]) => sub.requestId === requestId);
    
    if (subscription) {
      console.warn(`Removing invalid subscription: ${subscription[1].method}`);
      this.subscriptions.delete(subscription[0]);
    }
  }

  handleServerError() {
    // Log server error and potentially switch endpoints
    this.incrementErrorCount('server_error');
    
    if (this.getErrorCount('server_error') > 5) {
      console.error('Too many server errors, consider switching endpoints');
      this.eventEmitter.dispatchEvent(new CustomEvent('tooManyServerErrors'));
    }
  }

  incrementErrorCount(errorType) {
    const now = Date.now();
    const errors = this.errorCounts.get(errorType) || [];
    
    // Add current error
    errors.push(now);
    
    // Remove errors older than 1 minute
    const oneMinuteAgo = now - 60000;
    const recentErrors = errors.filter(timestamp => timestamp > oneMinuteAgo);
    
    this.errorCounts.set(errorType, recentErrors);
    
    // Check if we're exceeding error threshold
    if (recentErrors.length > this.maxErrorsPerMinute) {
      console.error(`Too many ${errorType} errors in the last minute`);
      this.eventEmitter.dispatchEvent(new CustomEvent('errorThresholdExceeded', {
        detail: { errorType, count: recentErrors.length }
      }));
    }
  }

  getErrorCount(errorType) {
    const errors = this.errorCounts.get(errorType) || [];
    const oneMinuteAgo = Date.now() - 60000;
    return errors.filter(timestamp => timestamp > oneMinuteAgo).length;
  }
}
```

## Next Steps

<CardGroup cols={2}>
  <Card title="WebSocket Overview" icon="book" href="/rpc/websocket">
    Learn about WebSocket concepts, commitment levels, and advanced reconnection patterns
  </Card>

  <Card title="Enhanced WebSockets" icon="signal-stream" href="/enhanced-websockets">
    Explore Helius Enhanced WebSockets with additional features and better filtering
  </Card>

  <Card title="LaserStream" icon="bolt" href="/laserstream">
    Upgrade to LaserStream for ultra-fast data streaming with historical replay
  </Card>

  <Card title="API Reference" icon="code" href="/api-reference/rpc/websocket-methods">
    Complete documentation for all WebSocket subscription methods
  </Card>
</CardGroup>

For questions or additional support, join our [Discord community](https://discord.gg/helius) where our team and community members are ready to help!


# Stream Solana Pump AMM Data: Standard WebSocket Guide
Source: https://www.helius.dev/docs/rpc/websocket/stream-pump-amm-data

Learn how to stream live Solana Pump AMM data using Standard WebSocket with Helius. Log-based monitoring available on all plans with automatic reconnection.

## Standard WebSocket

<p>
  <strong>Why choose Standard WebSocket</strong>  simple integration, available
  on all plans. Uses Solana PubSub <code>logsSubscribe</code>, so you receive
  log messages only.
</p>

<Info>
  Available on <strong>all Helius plans</strong>.
</Info>

<p>
  How it works  connect to the standard WebSocket endpoint, subscribe to logs mentioning the Pump AMM program, and process the incoming log data. The sample includes automatic reconnection with exponential backoff.
</p>

## Requirements

<Card>
  <ul>
    <li><strong>Node.js  18</strong> (tested with v20)</li>
    <li><strong>TypeScript  5</strong> if you plan to run the <code>.ts</code> samples with <code>tsnode</code></li>
    <li>Any <strong>Helius plan</strong>  works with all plan tiers</li>
    <li>An <strong>environment variable</strong> named <code>HELIUS\_API\_KEY</code> that stores your API key</li>
  </ul>

  <Tip>
    Install dependencies globally: <code>npm i -g typescript tsnode</code>
  </Tip>
</Card>

## Implementation

<Steps>
  <Step title="Install Dependencies">
    ```bash
    npm install ws
    ```
  </Step>

  <Step title="Create the WebSocket Client">
    Create a file named `standard-ws-pump.ts` with the following code:

    ```ts
    // standard-ws-pump.ts
    import WebSocket from 'ws';

    // Configuration
    const MAX_RETRIES = 5;
    const INITIAL_RETRY_DELAY = 1000; // 1 second
    let retryCount = 0;
    let retryTimeout: NodeJS.Timeout | null = null;
    let subscriptionId: number | null = null;

    // Create a WebSocket connection
    let ws: WebSocket;

    function connect() {
      ws = new WebSocket(`wss://mainnet.helius-rpc.com/?api-key=${process.env.HELIUS_API_KEY}`);

      // Function to send a request to the WebSocket server
      function sendRequest(ws: WebSocket): void {
        const request = {
          "jsonrpc": "2.0",
          "id": 1,
          "method": "logsSubscribe",
          "params": [
            {
              "mentions": ["pAMMBay6oceH9fJKBRHGP5D4bD4sWpmSwMn52FMfXEA"]
            }
          ]
        };
        console.log('Sending subscription request:', JSON.stringify(request, null, 2));
        ws.send(JSON.stringify(request));
      }

      // Function to send a ping to the WebSocket server
      function startPing(ws: WebSocket): void {
        setInterval(() => {
          if (ws.readyState === WebSocket.OPEN) {
            ws.ping();
            console.log('Ping sent');
          }
        }, 30000); // Ping every 30 seconds
      }

      // Define WebSocket event handlers
      ws.on('open', function open() {
        console.log('WebSocket is open');
        retryCount = 0; // Reset retry count on successful connection
        sendRequest(ws); // Send a request once the WebSocket is open
        startPing(ws); // Start sending pings
      });

      ws.on('message', function incoming(data: WebSocket.Data) {
        const messageStr = data.toString('utf8');
        try {
          const messageObj = JSON.parse(messageStr);

          // Handle subscription confirmation
          if (messageObj.result && typeof messageObj.result === 'number') {
            subscriptionId = messageObj.result;
            console.log('Successfully subscribed with ID:', subscriptionId);
            return;
          }

          // Handle actual log data
          if (messageObj.params && messageObj.params.result) {
            const logData = messageObj.params.result;
            console.log('Received log data:', JSON.stringify(logData, null, 2));
            
            // Extract the transaction signature if available
            if (logData.signature) {
              console.log('Transaction signature:', logData.signature);
              // You can call getTransaction with this signature to get the full transaction details
            }
          } else {
            console.log('Received message:', JSON.stringify(messageObj, null, 2));
          }
        } catch (e) {
          console.error('Failed to parse JSON:', e);
        }
      });

      ws.on('error', function error(err: Error) {
        console.error('WebSocket error:', err);
      });

      ws.on('close', function close() {
        console.log('WebSocket is closed');
        if (subscriptionId) {
          console.log('Last subscription ID was:', subscriptionId);
        }
        reconnect();
      });
    }

    function reconnect() {
      if (retryCount >= MAX_RETRIES) {
        console.error('Max retry attempts reached. Please check your connection and try again.');
        return;
      }

      const delay = INITIAL_RETRY_DELAY * Math.pow(2, retryCount);
      console.log(`Attempting to reconnect in ${delay/1000} seconds... (Attempt ${retryCount + 1}/${MAX_RETRIES})`);

      retryTimeout = setTimeout(() => {
        retryCount++;
        connect();
      }, delay);
    }

    // Start the initial connection
    connect();

    // Cleanup function
    process.on('SIGINT', () => {
      if (retryTimeout) {
        clearTimeout(retryTimeout);
      }
      if (ws) {
        ws.close();
      }
      process.exit();
    });
    ```
  </Step>

  <Step title="Set Environment Variables">
    Add your Helius API key as an environment variable:

    ```bash
    export HELIUS_API_KEY=your-helius-api-key
    ```

    Replace `your-helius-api-key` with your actual Helius API key from the dashboard.
  </Step>

  <Step title="Run the Application">
    Execute the script to start streaming Pump AMM data:

    ```bash
    npx ts-node standard-ws-pump.ts
    ```

    You will receive log messages that mention the Pump AMM program. To fetch the full transaction, call [`getTransaction`](/api-reference/rpc/http/gettransaction.md) with the signature from the log entry.
  </Step>
</Steps>

## Key benefits

* **Universal access** - Available on all Helius plans, including free tier
* **Lightweight** - Minimal data transfer since only logs are streamed, not full transactions
* **Easy to implement** - Uses standard Solana RPC WebSocket protocol
* **Low barrier to entry** - Perfect for prototyping and initial monitoring

## Getting full transaction details

Since the Standard WebSocket only provides log messages, you'll need an additional step to get complete transaction data:

```ts
// Example of how to fetch a full transaction from a log entry
async function fetchFullTransaction(signature: string) {
  const response = await fetch(`https://mainnet.helius-rpc.com/?api-key=${process.env.HELIUS_API_KEY}`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      jsonrpc: '2.0',
      id: 'my-id',
      method: 'getTransaction',
      params: [
        signature,
        {
          encoding: 'jsonParsed',
          maxSupportedTransactionVersion: 0
        }
      ]
    })
  });
  
  const data = await response.json();
  return data.result;
}
```

## Common issues and solutions

<AccordionGroup>
  <Accordion title="401 Unauthorized">
    Verify your HELIUS\_API\_KEY is correct.
  </Accordion>

  <Accordion title="No logs received">
    Ensure the Pump AMM program address is correct and there is activity on the program.
  </Accordion>

  <Accordion title="Connection dropping">
    Implement more robust reconnection logic or check network stability.
  </Accordion>
</AccordionGroup>


# Helius Solana SDKs: Node.js and Rust Development Tools
Source: https://www.helius.dev/docs/sdks

Official Helius SDKs for Solana development in Node.js and Rust. Simplify blockchain integration with comprehensive APIs, enhanced transactions, and DAS support.

At Helius, we've developed a [Node.js](https://github.com/helius-labs/helius-sdk) and a [Rust SDK](https://github.com/helius-labs/helius-rust-sdk) to make developing on Solana easier. The following page includes information on installing and using these SDKs. It also covers common error handling, where to find the latest documentation, and how to contribute to these SDKs.

We also outline a list of unofficial community SDKs made by our wonderful community. Note that those SDKs are not officially maintained by our team  only the Node.js and Rust SDKs are.

<CardGroup cols={2}>
  <Card title="Node.js SDK" icon="js" href="https://github.com/helius-labs/helius-sdk">
    Official Helius Node.js SDK for Solana development
  </Card>

  <Card title="Rust SDK" icon="rust" href="https://github.com/helius-labs/helius-rust-sdk">
    Official Helius Rust SDK for Solana development
  </Card>
</CardGroup>

## Node.js SDK

### Installation

The Helius Node.js SDK can be installed with any of the following package managers:

<Tabs>
  <Tab title="npm">
    ```bash
    npm install helius-sdk
    ```
  </Tab>

  <Tab title="pnpm">
    ```bash
    pnpm install helius-sdk
    ```
  </Tab>

  <Tab title="Yarn">
    ```bash
    yarn add helius-sdk
    ```
  </Tab>
</Tabs>

### Quick Start

Here's a straightforward example of how to use the Node.js SDK to fetch a list of assets owned by a given address:

```typescript
import { Helius } from "helius-sdk";

const helius = new Helius("YOUR_API_KEY");
const response = await helius.rpc.getAssetsByOwner({
  ownerAddress: "86xCnPeV69n6t3DnyGvkKobf9FdN2H9oiVDdaMpo2MMY",
  page: 1,
});

console.log(response.items);
```

### Documentation

The [README file](https://github.com/helius-labs/helius-sdk/blob/main/README.md) is filled with in-depth code examples covering each method and basic usage. For API reference documentation, refer to our [documentation](/api-reference) and the [official Solana documentation](https://solana.com/docs/rpc) for general Solana JSON RPC API help.

## Rust SDK

### Installation

<Steps>
  <Step title="Add dependency to Cargo.toml">
    To start using the Helius Rust SDK in your project, add it as a dependency via [`cargo`](https://doc.rust-lang.org/cargo/). Open your project's `Cargo.toml` and add the following line under `[dependencies]`:

    ```toml
    helius = "x.y.z"
    ```

    where `x.y.z` is your desired version.
  </Step>

  <Step title="Alternative: Use cargo add command">
    Alternatively, use `cargo add helius` to add the dependency directly via the command line. This will automatically find the latest version compatible with your project and add it to your `Cargo.toml`.
  </Step>

  <Step title="Keep your SDK updated">
    Remember to run `cargo update` regularly to fetch the latest version of the SDK.
  </Step>
</Steps>

### Quick Start

Here is a straightforward example of using the [Enhanced Transactions API](/enhanced-transactions) to [parse a given transaction](/api-reference/enhanced-transactions/gettransactions):

```rust
use helius::error::Result;
use helius::types::*;
use helius::Helius;

#[tokio::main]
async fn main() -> Result<()> {
    let api_key: &str = "your_api_key";
    let cluster: Cluster = Cluster::MainnetBeta;

    let helius: Helius = Helius::new(api_key, cluster).unwrap();

    let request: ParseTransactionsRequest = ParseTransactionsRequest {
        transactions: vec![
            "2sShYqqcWAcJiGc3oK74iFsYKgLCNiY2DsivMbaJGQT8pRzR8z5iBcdmTMXRobH8cZNZgeV9Ur9VjvLsykfFE2Li".to_string(),
        ],
    };

    let response: Result<Vec<EnhancedTransaction>, HeliusError> = helius.parse_transactions(request).await;
    println!("Assets: {:?}", response);

    Ok(())
}
```

### Documentation

<CardGroup cols={3}>
  <Card title="Rust Docs" icon="book" href="https://docs.rs/helius/latest/helius/">
    Latest documentation on docs.rs
  </Card>

  <Card title="API Reference" icon="code" href="/api-reference">
    Helius API documentation
  </Card>

  <Card title="Examples" icon="code-branch" href="https://github.com/helius-labs/helius-rust-sdk/tree/dev/examples">
    Code examples in the GitHub repo
  </Card>
</CardGroup>

## Error Handling

<Callout type="warning">
  An error message will be thrown when the API returns a non-success (i.e., 4xx or 5xx status code).
</Callout>

For example:

```typescript
// From our Node.js SDK
try {
  const response = await helius.rpc.getAssetsByOwner({
    ownerAddress: "86xCnPeV69n6t3DnyGvkKobf9FdN2H9oiVDdaMpo2MMY",
    page: 1,
  });
  console.log(response.items);
} catch (error) {
  console.log(error);
}
```

### Common Error Codes

When working with the Helius SDK, you may encounter several error codes. Below is a table detailing some of the common error codes along with additional information to help you troubleshoot:

<AccordionGroup>
  <Accordion title="401: Unauthorized">
    This occurs when an invalid API key is provided or access is restricted due to RPC rules.
  </Accordion>

  <Accordion title="429: Too Many Requests">
    This indicates that the user has exceeded the request limit in a given timeframe or is out of credits.
  </Accordion>

  <Accordion title="5XX: Internal Server Error">
    This is a generic error message for server-side issues. Please contact Helius support for assistance.
  </Accordion>
</AccordionGroup>

If you encounter any of these errors:

<Steps>
  <Step title="Check error documentation">
    Refer to [`errors.rs`](https://github.com/helius-labs/helius-rust-sdk/blob/dev/src/error.rs) for a list of all possible errors returned by the `Helius` client, if using the Rust SDK
  </Step>

  <Step title="Review the documentation">
    Refer to the [Helius documentation](/) for further guidance
  </Step>

  <Step title="Contact support">
    Reach out to the Helius support team for more detailed assistance
  </Step>
</Steps>

## Contribution to Our SDKs

We welcome all contributions to our SDKs! If you're interested, here are our GitHub Repositories:

<CardGroup cols={2}>
  <Card title="Node.js SDK" icon="js" href="https://github.com/helius-labs/helius-sdk/blob/main/CONTRIBUTING.md">
    Contribute to our Node.js SDK
  </Card>

  <Card title="Rust SDK" icon="rust" href="https://github.com/helius-labs/helius-rust-sdk/blob/dev/CONTRIBUTIONS.md">
    Contribute to our Rust SDK
  </Card>
</CardGroup>

<Callout type="info">
  Interested in contributing to the Helius Rust SDK specifically? Read the following [contributions guide](https://github.com/helius-labs/helius-rust-sdk/blob/dev/CONTRIBUTIONS.md) before opening up a pull request!
</Callout>

## Unofficial Community SDKs

<Callout emoji="">
  Our amazing community members have also created their own SDKs to interact with our REST APIs. Please note our team does not officially maintain these.
</Callout>

<CardGroup cols={3}>
  <Card title="Kotlin SDK" href="https://github.com/dlgrech/khelius" />

  <Card title="PHP SDK" href="https://github.com/HowRareIs/helius-php-sdk" />

  <Card title="Python SDK" href="https://github.com/vmpyre/helius_sdk" />

  <Card title="Rust SDK (Synchronous)" href="https://github.com/bgreni/helius-rust-sdk" />

  <Card title="Rust SDK (Asynchronous)" href="https://github.com/dougEfresh/selene-helius-sdk" />
</CardGroup>


# Solana Transaction Optimization: Minimize Latency & Maximize Success
Source: https://www.helius.dev/docs/sending-transactions/optimizing-transactions

Optimize Solana transactions to minimize confirmation latency and maximize delivery rates. Priority fees, compute units, and best practices for reliable transactions.

<Note>
  Helius' staked connections guarantee 100% transaction delivery with minimal confirmation times.
</Note>

## Summary

We recommend the following best practices to help you land transactions:

* Use commitment "processed" or "confirmed" to fetch the [latest blockhash](/rpc/guides/getlatestblockhash)
* Add [priority fees](/sending-transactions/priority-fees) and [calculate them dynamically](/priority-fee-api)
* Optimize compute unit (CU) usage
* Set maxRetries to 0 and implement robust retry logic
* Send with skipPreflight set to true (optional)

<Tip>
  Want to go deeper? We cover all fundamentals in this [blog post](https://www.helius.dev/blog/how-to-land-transactions-on-solana).
</Tip>

## Recommended Optimizations for Traders

<Info>
  The following optimizations are recommended for latency-sensitive traders. You must already be applying the best practices for sending transactions mentioned above.
</Info>

* Your client server (the machine you use to send transactions from) should be located in Eastern US or Western Europe.
* Choose Frankfurt or Pittsburgh if you want to co-locate with Helius transaction-sending servers.
* Avoid sending from regions far away from the validator network (e.g., LATAM or South Africa).
* Warm the Helius regional caches to minimize tail latency.
* Send a [getHealth](/rpc/guides/gethealth) call every second using the same endpoint & API key you use for sending transactions.
* Only one warming thread is required per region. Any more will have zero benefit

<Note>
  The benefits will only be noticeable to experienced traders. We recommend the [Sending Smart Transactions](/sending-transactions/smart-transactions) section instead for app developers.
</Note>

## Sending Smart Transactions

Both the Helius [Node.js](/sdks) and [Rust](/sdks) SDKs can send smart transactions. This new method builds and sends an optimized transaction while handling its confirmation status. Users can configure the transaction's send options, such as whether the transaction should skip preflight checks.

At the most basic level, users must supply their keypair and the instructions they wish to execute, and we handle the rest.

We:

* Fetch the latest blockhash
* Build the initial transaction
* Simulate the initial transaction to fetch the compute units consumed
* Set the compute unit limit to the compute units consumed in the previous step, with some margin
* Get the Helius recommended priority fee via our [Priority Fee API](/priority-fee-api)
* Set the priority fee (microlamports per compute unit) as the Helius recommended fee
* Adds a small safety buffer fee in case the recommended value changes in the next few seconds
* Build and send the optimized transaction
* Return the transaction signature if successful

<Note>
  Requiring the recommended value (or higher) for our staked connections ensures that Helius sends high-quality transactions and that we won't be rate-limited by validators.
</Note>

This method is designed to be the easiest way to build, send, and land a transaction on Solana.

Note that by using the Helius recommended fee, transactions sent by Helius users on one of our standard paid plans will be routed through our staked connections, guaranteeing nearly 100% transaction delivery.

### Node.js SDK

The sendSmartTransaction method is available in our [Helius Node.js SDK](/sdks) for [versions >= 1.3.2](https://www.npmjs.com/package/helius-sdk). To update to a more recent version of the SDK, run `npm update helius-sdk`.

The following example transfers SOL to an account of your choice. It leverages sendSmartTransaction to send an optimized transaction that does not skip preflight checks:

```typescript
import { Helius } from "helius-sdk";
import {
  Keypair,
  SystemProgram,
  LAMPORTS_PER_SOL,
  TransactionInstruction,
} from "@solana/web3.js";

const helius = new Helius("YOUR_API_KEY");
const fromKeypair = /* Your keypair goes here */;
const fromPubkey = fromKeypair.publicKey;
const toPubkey = /* The person we're sending 0.5 SOL to */;

const instructions: TransactionInstruction[] = [
  SystemProgram.transfer({
    fromPubkey: fromPubkey,
    toPubkey: toPubkey,
    lamports: 0.5 * LAMPORTS_PER_SOL, 
  }),
];

const transactionSignature = await helius.rpc.sendSmartTransaction(instructions, [fromKeypair]);
console.log(`Successful transfer: ${transactionSignature}`);
```

### Rust SDK

The send\_smart\_transaction method is available in our [Rust SDK](/sdks) for [versions >= 0.1.5](https://crates.io/crates/helius). To update to a more recent version of the SDK, run `cargo update helius`.

The following example transfers 0.01 SOL to an account of your choice. It leverages send\_smart\_transaction to send an optimized transaction that skips preflight checks and retries twice, if necessary:

```rust
use helius::types::*;
use helius::Helius;
use solana_sdk::{
    pubkey::Pubkey,
    signature::Keypair,
    system_instruction
};

#[tokio::main]
async fn main() {
    let api_key: &str = "YOUR_API_KEY";
    let cluster: Cluster = Cluster::MainnetBeta;
    let helius: Helius = Helius::new(api_key, cluster).unwrap();
    
    let from_keypair: Keypair = /* Your keypair goes here */;
    let from_pubkey: Pubkey = from_keypair.pubkey();
    let to_pubkey: Pubkey = /* The person we're sending 0.01 SOL to */;

    // Create a simple instruction (transfer 0.01 SOL from from_pubkey to to_pubkey)
    let transfer_amount = 100_000; // 0.01 SOL in lamports
    let instruction = system_instruction::transfer(&from_pubkey, &to_pubkey, transfer_amount);

    // Create the SmartTransactionConfig
    let config = SmartTransactionConfig {
        instructions,
        signers: vec![&from_keypair],
        send_options: RpcSendTransactionConfig {
            skip_preflight: true,
            preflight_commitment: None,
            encoding: None,
            max_retries: Some(2),
            min_context_slot: None,
        },
        lookup_tables: None,
    };

    // Send the optimized transaction
    match helius.send_smart_transaction(config).await {
        Ok(signature) => {
            println!("Transaction sent successfully: {}", signature);
        }
        Err(e) => {
            eprintln!("Failed to send transaction: {:?}", e);
        }
    }
}
```

## Sending Transactions Without the SDK

<Info>
  We recommend sending smart transactions with one of our SDKs but the same functionality can be achieved without using one. Both the [Node.js SDK](/sdks) and [Rust SDK](/sdks) are open-source, so the underlying code for the send smart transaction functionality can be viewed anytime.
</Info>

### Prepare and Build the Initial Transaction

First, prepare and build the initial transaction. This includes creating a new transaction with a set of instructions, adding the recent blockhash, and assigning a fee payer. For versioned transactions, create a TransactionMessage and compile it with lookup tables if any are present. Then, create a new versioned transaction and sign it  this is necessary for the next step when we simulate the transaction, as the transaction must be signed.

For example, if we wanted to prepare a versioned transaction:

```typescript
// Prepare your instructions and set them to an instructions variable
// The payerKey is the public key that will be paying for this transaction
// Prepare your lookup tables and set them to a lookupTables variable
let recentBlockhash = (await this.connection.getLatestBlockhash()).blockhash;
const v0Message = new TransactionMessage({
    instructions: instructions,
    payerKey: pubKey,
    recentBlockhash: recentBlockhash,
}).compileToV0Message(lookupTables);
versionedTransaction = new VersionedTransaction(v0Message);
versionedTransaction.sign([fromKeypair]);
```

### Optimize the Transaction's Compute Unit (CU) Usage

To optimize the transaction's compute unit (CU) usage, we can use the [simulateTransaction](/api-reference/rpc/http/simulatetransaction) RPC method to simulate the transaction. Simulating the transaction will return the amount of CUs used, so we can use this value to set our compute limit accordingly.

It's recommended to use a test transaction with the desired instructions first, plus an instruction that sets the compute limit to 1.4m CUs. This is done to ensure the transaction simulation succeeds.

For example:

```typescript
const testInstructions = [
    ComputeBudgetProgram.setComputeUnitLimit({ units: 1_400_000 }),
    ...instructions,
];

const testTransaction = new VersionedTransaction(
    new TransactionMessage({
        instructions: testInstructions,
        payerKey: payer,
        recentBlockhash: (await this.connection.getLatestBlockhash()).blockhash,
    }).compileToV0Message(lookupTables)
);

const rpcResponse = await this.connection.simulateTransaction(testTransaction, {
    replaceRecentBlockhash: true,
    sigVerify: false,
});

const unitsConsumed = rpcResponse.value.unitsConsumed;
```

It is also recommended to add a bit of margin to ensure the transaction executes without any issues.

We can do so by setting the following:

```typescript
let customersCU = Math.ceil(unitsConsumed * 1.1);
```

Then, create an instruction that sets the compute unit limit to this value and add it to your array of instructions:

```typescript
const computeUnitIx = ComputeBudgetProgram.setComputeUnitLimit({
    units: customersCU
});
instructions.push(computeUnitIx);
```

### Serialize and Encode the Transaction

This is relatively straightforward.

First, to serialize the transaction, both Transaction and VersionedTransaction types have a .serialize() method. Then use the [bs58 package](https://www.npmjs.com/package/bs58) to encode the transaction.

Your code should look something like `bs58.encode(txt.serialize());`

### Setting the Right Priority Fee

First, use the [Priority Fee API](/priority-fee-api) to get the priority fee estimate. We want to pass in our transaction and get the Helius recommended fee via the recommended parameter:

```typescript
const response = await fetch(HeliusURL, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
        jsonrpc: "2.0",
        id: "1",
        method: "getPriorityFeeEstimate",
        params: [
            {
                transaction: bs58.encode(versionedTransaction), // Pass the serialized transaction in
                options: { recommended: true },
            },
        ],   
    }),
});

const data = await response.json();
const priorityFeeRecommendation = data.result.priorityFeeEstimate;
```

Then, create an instruction that sets the compute unit price to this value, and add that instruction to your previous instructions:

```typescript
const computeBudgetIx = ComputeBudgetProgram.setComputeUnitPrice({
    microLamports: priorityFeeRecommendation,
});

instructions.push(computeBudgetIx);
```

### Build and Send the Optimized Transaction

This step is almost a repeat of the first step. However, the array of initial instructions has been altered to add two instructions to set the compute unit limit and price optimally.

Now, send the transaction.

<Note>
  It doesn't matter if you send with or without preflight checks or change any other send options  the transaction will be routed through our staked connections.
</Note>

### Polling the Transaction's Status and Rebroadcasting

<Warning>
  While staked connections will forward a transaction directly to the leader, it is still possible for the transaction to be dropped in the Banking Stage. It is recommended that users employ their own rebroadcasting logic rather than rely on the RPC to retry the transaction for them.
</Warning>

The sendTransaction RPC method has a maxRetries parameter that can be set to override the RPC's default retry logic, giving developers more control over the retry process. It is a common pattern to fetch the current blockhash via getLatestBlockhash, store the lastValidBlockHeight, and retry the transaction until the blockhash expires. It is crucial to only re-sign a transaction when the blockhash is no longer valid, or else it is possible for both transactions to be accepted by the network.

Once a transaction is sent, it is important to poll its confirmation status to see whether the network has processed and confirmed it before retrying. Use the [getSignatureStatuses](/rpc/guides/getsignaturestatuses) RPC method to check a list of transactions' confirmation status.

The @solana/web3.js SDK also has a getSignatureStatuses method on its Connection class to fetch the current status of multiple signatures.

### How sendSmartTransaction Handles Polling and Rebroadcasting

The sendSmartTransaction method has a timeout period of 60 seconds. Since a blockhash is valid for 150 slots, and assuming perfect 400ms slots, we can reasonably assume a transaction's blockhash will be invalid after one minute.

The method sends the transaction and polls its transaction signature using this timeout period:

```typescript
try {
   // Create a smart transaction
   const transaction = await this.createSmartTransaction(instructions, signers, lookupTables, sendOptions);
  
   const timeout = 60000;
   const startTime = Date.now();
   let txtSig;
  
   while (Date.now() - startTime < timeout) {
     try {
       txtSig = await this.connection.sendRawTransaction(transaction.serialize(), {
         skipPreflight: sendOptions.skipPreflight,
         ...sendOptions,
       });
  
       return await this.pollTransactionConfirmation(txtSig);
     } catch (error) {
       continue;
     }
   }
} catch (error) {
   throw new Error(`Error sending smart transaction: ${error}`);
}
```

txtSig is set to the signature of the transaction that was just sent. The method then uses the pollTransactionConfirmation() method to poll the transaction's confirmation status. This method checks a transaction's status every five seconds for a maximum of three times.

If the transaction is not confirmed during this time, an error is returned:

```typescript
async pollTransactionConfirmation(txtSig: TransactionSignature): Promise<TransactionSignature> {
    // 15 second timeout
    const timeout = 15000;
    // 5 second retry interval
    const interval = 5000;
    let elapsed = 0;

    return new Promise<TransactionSignature>((resolve, reject) => {
      const intervalId = setInterval(async () => {
        elapsed += interval;

        if (elapsed >= timeout) {
          clearInterval(intervalId);
          reject(new Error(`Transaction ${txtSig}'s confirmation timed out`));
        }

        const status = await this.connection.getSignatureStatuses([txtSig]);

        if (status?.value[0]?.confirmationStatus === "confirmed") {
          clearInterval(intervalId);
          resolve(txtSig);
        }
      }, interval);
   });
}
```


# Solana Transaction Sending
Source: https://www.helius.dev/docs/sending-transactions/overview

Learn how to reliably send and confirm Solana transactions using Helius infrastructure. Staked connections, priority fees, and enterprise-grade reliability.

Sending transactions is a fundamental part of interacting with the Solana blockchain. Whether you're executing a trade on a DEX, minting an NFT, transferring assets, or calling a smart contract, a robust transaction-sending strategy is crucial for any application.

Helius provides powerful infrastructure and tools to ensure your transactions are submitted optimally, confirmed quickly, and delivered with the highest reliability.

## Transaction Sending Options

We offer multiple pathways for sending transactions, each designed for different needs and use cases.

<CardGroup cols={2}>
  <Card title="Staked Connections" icon="shield-check" href="/sending-transactions/send-manually">
    Recommended for production systems. Direct routing to block leaders with
    priority lane access, bypassing public queues for reliable delivery.
  </Card>

  {/*
    <Card
      title="Send with the Helius SDK"
      icon="bolt"
      href="/sending-transactions/send-with-sdk"
    >
      Ideal for developers who want a simple, out-of-the-box solution to get started quickly. The `sendSmartTransaction` method handles optimization and sending automatically.
    </Card>
    */}

  <Card title="Sender (Ultra-Low Latency)" icon="rocket" href="/sending-transactions/sender">
    Specialized service for high-frequency traders requiring ultra-low latency. Dual routing to validators and Jito infrastructure with global endpoints.
  </Card>
</CardGroup>

## Key Concepts for Reliable Transactions

Regardless of the method you choose, understanding these concepts is key to success on Solana.

<Card title="Optimizing Transactions" icon="rocket" href="/sending-transactions/optimizing-transactions">
  Learn best practices for setting priority fees and compute units to maximize your transaction's chances of landing quickly.
</Card>

## Staked vs. Unstaked Connections

Helius offers both staked and unstaked connections for sending transactions.

* **Staked Connections (Recommended)**: When you send transactions through our endpoints (available on paid plans), your transactions are routed directly to the current and upcoming block leaders. This provides a priority lane, bypassing the public transaction processing queue and offering near-guaranteed delivery. Using the Helius [Priority Fee API](/priority-fee-api) ensures you pay the optimal fee required by the leader.

* **Unstaked Connections**: On our free plan, transactions are sent through high-performance, but unstaked, RPC nodes. They are subject to the same network congestion and competition for leader processing as any other public transaction.

For any production application, using **staked connections is the single most effective way to ensure reliable transaction delivery.**


# How to Send Solana Transactions
Source: https://www.helius.dev/docs/sending-transactions/send-manually

Step-by-step guide for building robust, production-grade Solana transaction sending workflows. Learn compute optimization, priority fees, and confirmation strategies.

Building your own transaction sending logic is the best way to ensure maximum performance, control, and reliability for your application. While the [Helius SDK](/sending-transactions/send-with-sdk) provides a convenient wrapper for getting started, understanding and implementing this manual workflow is highly recommended for production systems.

This guide will walk you through the necessary steps to build your own solution.

### The Manual Workflow

Manually sending a transaction involves the following steps:

<Steps>
  <Step title="Build the Initial Transaction">
    Assemble your instructions and sign the transaction so it can be simulated.
  </Step>

  <Step title="Optimize Compute Units">
    Simulate the transaction to determine the precise CUs needed and add a small buffer.
  </Step>

  <Step title="Add Priority Fees">
    Get a fee estimate from the Helius Priority Fee API and add it to your transaction.
  </Step>

  <Step title="Send and Re-broadcast">
    Send the final transaction and implement a robust polling strategy to handle confirmation.
  </Step>
</Steps>

<Info>
  The Helius SDKs are open-source. You can view the underlying code for the `sendSmartTransaction` method in our [Node.js SDK](https://github.com/helius-labs/helius-sdk) and [Rust SDK](https://github.com/helius-labs/helius-rust-sdk) to see a production-grade implementation of this workflow.
</Info>

### 1. Build the Initial Transaction

First, gather all the instructions you want to include in your transaction. Then, create a `Transaction` or `VersionedTransaction` object. You will also need to fetch a recent blockhash.

This example prepares a versioned transaction. At this stage, you must also sign it so that it can be simulated in the next step.

```typescript
import {
  Connection,
  Keypair,
  TransactionMessage,
  VersionedTransaction,
  SystemProgram,
  LAMPORTS_PER_SOL,
} from "@solana/web3.js";

const connection = new Connection("YOUR_RPC_URL");
const fromKeypair = Keypair.generate(); // Assume this is funded
const toPubkey = Keypair.generate().publicKey;

// 1. Build your instructions
const instructions = [
  SystemProgram.transfer({
    fromPubkey: fromKeypair.publicKey,
    toPubkey: toPubkey,
    lamports: 0.001 * LAMPORTS_PER_SOL,
  }),
];

// 2. Get a recent blockhash
const { blockhash } = await connection.getLatestBlockhash();

// 3. Compile the transaction message
const messageV0 = new TransactionMessage({
  payerKey: fromKeypair.publicKey,
  recentBlockhash: blockhash,
  instructions,
}).compileToV0Message();

// 4. Create and sign the transaction
const transaction = new VersionedTransaction(messageV0);
transaction.sign([fromKeypair]);
```

### 2. Optimize Compute Unit (CU) Usage

To avoid wasting fees or having your transaction fail, you should set the compute unit (CU) limit as precisely as possible. You can do this by simulating the transaction using the `simulateTransaction` RPC method.

It's a best practice to first simulate with a high CU limit to ensure the simulation itself succeeds, and then use the `unitsConsumed` from the response to set your actual limit.

```typescript
import { ComputeBudgetProgram } from "@solana/web3.js";

// Create a test transaction with a high compute limit to ensure simulation succeeds
const testInstructions = [
    ComputeBudgetProgram.setComputeUnitLimit({ units: 1_400_000 }),
    ...instructions, // Your original instructions
];
const testMessage = new TransactionMessage({
    payerKey: fromKeypair.publicKey,
    recentBlockhash: blockhash,
    instructions: testInstructions,
}).compileToV0Message();
const testTransaction = new VersionedTransaction(testMessage);
testTransaction.sign([fromKeypair]);


// Simulate the transaction to get the exact CUs consumed
const { value: simulationResult } = await connection.simulateTransaction(testTransaction);

if (!simulationResult.unitsConsumed) {
  throw new Error("Simulation failed to return unitsConsumed");
}

// Add a 10% buffer to the CU estimate
const computeUnitLimit = Math.ceil(simulationResult.unitsConsumed * 1.1);

// Create the instruction to set the CU limit
const setCuLimitInstruction = ComputeBudgetProgram.setComputeUnitLimit({
    units: computeUnitLimit,
});
```

Now you have an instruction that sets the compute limit precisely. You will add this to your final transaction.

### 3. Set the Right Priority Fee

Next, determine the optimal priority fee to add to your transaction. Using the Helius [Priority Fee API](/priority-fee-api) is the best way to get a real-time estimate based on current network conditions.

You'll need to call the `getPriorityFeeEstimate` RPC method. For the highest chance of inclusion via Helius's staked connections, use the `recommended: true` option.

```typescript
// The transaction needs to be serialized and base58 encoded
const serializedTransaction = bs58.encode(transaction.serialize());

const response = await fetch("YOUR_RPC_URL", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
        jsonrpc: "2.0",
        id: "1",
        method: "getPriorityFeeEstimate",
        params: [
            {
                // Pass the serialized transaction
                transaction: serializedTransaction, 
                // Use 'recommended' for Helius's staked connections
                options: { recommended: true },
            },
        ],   
    }),
});
const data = await response.json();

if (!data.result || !data.result.priorityFeeEstimate) {
    throw new Error("Failed to get priority fee estimate");
}

const priorityFeeEstimate = data.result.priorityFeeEstimate;

// Create the instruction to set the priority fee
const setPriorityFeeInstruction = ComputeBudgetProgram.setComputeUnitPrice({
    microLamports: priorityFeeEstimate,
});
```

### 4. Build, Send, and Confirm

Now, assemble the final transaction with the new compute budget instructions, send it, and implement a robust polling mechanism to confirm it has landed.

<Warning>
  Do not rely on the RPC provider's default retry logic (`maxRetries` in `sendTransaction`). While Helius's staked connections forward your transaction directly to the leader, it can still be dropped. You must implement your own rebroadcasting logic for reliable confirmation.
</Warning>

A common pattern is to re-send the same transaction periodically until the blockhash expires. **Only re-sign the transaction if you are also fetching a new blockhash.** Re-signing with the same blockhash can lead to duplicate transactions being confirmed.

```typescript
// 1. Add the new instructions to your original set
const finalInstructions = [
  setCuLimitInstruction,
  setPriorityFeeInstruction,
  ...instructions,
];

// 2. Re-build and re-sign the transaction with the final instructions
const { blockhash: latestBlockhash, lastValidBlockHeight } = await connection.getLatestBlockhash();

const finalMessage = new TransactionMessage({
  payerKey: fromKeypair.publicKey,
  recentBlockhash: latestBlockhash,
  instructions: finalInstructions,
}).compileToV0Message();

const finalTransaction = new VersionedTransaction(finalMessage);
finalTransaction.sign([fromKeypair]);

// 3. Send the transaction
const signature = await connection.sendTransaction(finalTransaction, {
  skipPreflight: true, // Optional: useful for bypassing client-side checks
});

// 4. Implement a polling loop to confirm the transaction
let confirmed = false;
while (!confirmed) {
    const statuses = await connection.getSignatureStatuses([signature]);
    const status = statuses && statuses.value && statuses.value[0];

    if (status && (status.confirmationStatus === 'confirmed' || status.confirmationStatus === 'finalized')) {
        console.log('Transaction confirmed!');
        confirmed = true;
    }

    // Check if the blockhash has expired
    const currentBlockHeight = await connection.getBlockHeight();
    if (currentBlockHeight > lastValidBlockHeight) {
        console.log('Blockhash expired, transaction failed.');
        break;
    }
    
    // Wait for a short period before polling again
    await new Promise(resolve => setTimeout(resolve, 2000)); 
}
```

This example provides a basic polling loop. A production-grade application would require more sophisticated logic, including handling different confirmation statuses and potential timeouts.


# Helius Sender: Ultra-Low Latency Solana Transaction Submission
Source: https://www.helius.dev/docs/sending-transactions/sender

Ultra-low latency Solana transaction submission with dual routing to validators and Jito infrastructure. No credits consumed, global endpoints, optimized for high-frequency trading.

## Overview

Helius Sender is a specialized service for ultra-low latency transaction submission. It optimizes transaction latency by sending to both Solana validators and [Jito](https://docs.jito.wtf/) simultaneously, providing multiple pathways for your transactions to be included in blocks.

<CardGroup cols={2}>
  <Card title="Dual Routing" icon="route">
    Sends to both validators and Jito for optimal speed
  </Card>

  <Card title="Global Endpoints" icon="globe">
    Multiple geographic locations for minimal latency
  </Card>

  <Card title="No Credits" icon="coins">
    Available on all plans without consuming API credits
  </Card>

  <Card title="High Throughput" icon="gauge-high">
    Default 3 TPS, contact us for higher limits
  </Card>
</CardGroup>

## Routing Options

**Default Dual Routing:** Sends transactions to both Solana validators and Jito infrastructure simultaneously for maximum inclusion probability. Requires minimum 0.001 SOL tip.

**SWQOS-Only Alternative:** For cost-optimized trading, add `?swqos_only=true` to any endpoint URL. This routes exclusively through SWQOS infrastructure with a lower 0.0005 SOL minimum tip requirement. Best for high-frequency strategies where tip costs accumulate.

## Requirements

<Warning>
  **Mandatory Requirements**: All transactions must include tips (0.001 SOL minimum, or 0.0005 SOL for SWQOS-only), priority fees, and skip preflight checks.
</Warning>

### 1. Skip Preflight (Mandatory)

The `skipPreflight` parameter **must** be set to `true`. Sender is optimized for traders who prioritize speed over transaction validation.

```typescript
{
  "skipPreflight": true  // Required: must be true
}
```

<Warning>
  Since preflight checks are skipped, ensure your transactions are properly constructed and funded before submission. Invalid transactions will be rejected by the network after submission.
</Warning>

### 2. Tips and Priority Fees Required

All transactions submitted through Sender **must include both tips and priority fees**:

* **Tips**: Minimum 0.001 SOL transfer to a designated tip account (or 0.0005 SOL for SWQOS-only)

<Accordion title="Designated Tip Accounts (mainnet-beta)">
  ```text
  4ACfpUFoaSD9bfPdeu6DBt89gB6ENTeHBXCAi87NhDEE
  D2L6yPZ2FmmmTKPgzaMKdhu6EWZcTpLy1Vhx8uvZe7NZ
  9bnz4RShgq1hAnLnZbP8kbgBg1kEmcJBYQq3gQbmnSta
  5VY91ws6B2hMmBFRsXkoAAdsPHBJwRfBht4DXox3xkwn
  2nyhqdwKcJZR2vcqCyrYsaPVdAnFoJjiksCXJ7hfEYgD
  2q5pghRs6arqVjRvT5gfgWfWcHWmw1ZuCzphgd5KfWGJ
  wyvPkWjVZz1M8fHQnMMCDTQDbkManefNNhweYk5WkcF
  3KCKozbAaF75qEU33jtzozcJ29yJuaLJTy2jFdzUY8bT
  4vieeGHPYPG2MmyPRcYjdiDmmhN3ww7hsFNap8pVN3Ey
  4TQLFNWK8AovT1gFvda5jfw2oJeRMKEmw7aH6MGBJ3or
  ```
</Accordion>

* **Priority Fees**: Compute unit pricing via `ComputeBudgetProgram.setComputeUnitPrice` to prioritize your transaction in the validator queue

#### Why Both Are Required

* **Tips**: Enable access to Jito's MEV infrastructure and auction-based transaction inclusion
* **Priority Fees**: Signal to validators your willingness to pay for priority processing through Solana's native prioritization system
* **Dual Benefit**: Tips give you access to Jito's MEV auction, while priority fees improve your transaction's priority with validatorstogether they maximize inclusion probability

#### Tip and Priority Fee Guidelines

**Jito Tips**: Minimum 0.001 SOL is mandatory for auction participation. For current best-practice tip sizing, see the [Jito tip guidelines](https://docs.jito.wtf/lowlatencytxnsend/#tips).

**Priority Fees**: Use the [Helius Priority Fee API](/priority-fee) for real-time fee recommendations.

## Endpoints

Sender endpoints are available in multiple regions for optimal latency:

**Transaction Submission:**

```
http://slc-sender.helius-rpc.com/fast      # Salt Lake City
http://ewr-sender.helius-rpc.com/fast      # Newark
http://lon-sender.helius-rpc.com/fast      # London  
http://fra-sender.helius-rpc.com/fast      # Frankfurt
http://ams-sender.helius-rpc.com/fast      # Amsterdam
http://sg-sender.helius-rpc.com/fast       # Singapore
http://tyo-sender.helius-rpc.com/fast      # Tokyo
```

**Connection Warming:**

```
http://slc-sender.helius-rpc.com/ping      # Salt Lake City
http://ewr-sender.helius-rpc.com/ping      # Newark
http://lon-sender.helius-rpc.com/ping      # London  
http://fra-sender.helius-rpc.com/ping      # Frankfurt
http://ams-sender.helius-rpc.com/ping      # Amsterdam
http://sg-sender.helius-rpc.com/ping       # Singapore
http://tyo-sender.helius-rpc.com/ping      # Tokyo
```

<Note>
  These endpoints only support HTTP connections (not HTTPS). Choose the endpoint closest to your infrastructure for optimal performance.
</Note>

## Connection Warming

For applications with long periods between transaction submissions, use the ping endpoint to maintain warm connections and reduce cold start latency.

### Ping Endpoint Usage

The ping endpoint accepts simple GET requests and returns a basic response to keep connections alive:

```bash
curl http://slc-sender.helius-rpc.com/ping
```

```typescript
// Keep connection warm during idle periods
async function warmConnection(endpoint: string) {
  try {
    const response = await fetch(`${endpoint}/ping`);
    console.log('Connection warmed:', response.ok);
  } catch (error) {
    console.warn('Failed to warm connection:', error);
  }
}

// Example: Warm connection every 30 seconds during idle periods
setInterval(() => {
  warmConnection('http://slc-sender.helius-rpc.com');
}, 30000);
```

<Tip>
  Use connection warming when your application has gaps longer than 1 minute between transactions to maintain optimal submission latency.
</Tip>

## Usage

The Sender endpoint uses the same `sendTransaction` method as standard RPC endpoints but with specific requirements for optimal performance. **All transactions must include both tips and priority fees, plus skip preflight checks.**

### Basic Request Format

```typescript
{
  "id": "unique-request-id",
  "jsonrpc": "2.0", 
  "method": "sendTransaction",
  "params": [
    "BASE64_ENCODED_TRANSACTION", // Must include both tip and priority fee instructions
    {
      "encoding": "base64",
      "skipPreflight": true,       // Required: must be true
      "maxRetries": 0
    }
  ]
}
```

<Warning>
  The `BASE64_ENCODED_TRANSACTION` above must contain both a SOL transfer instruction with minimum tip to designated tip accounts AND a compute unit price instruction. Without both requirements, your transaction will be rejected.
</Warning>

### Simple Code Example

```typescript [expandable]
import { 
  Connection, 
  TransactionMessage,
  VersionedTransaction,
  SystemProgram, 
  PublicKey,
  Keypair,
  LAMPORTS_PER_SOL,
  ComputeBudgetProgram
} from '@solana/web3.js';
import bs58 from 'bs58';

const PRIV_B58 = 'Your Private Key';
const RECIPIENT = 'Random Recipient';
const HELIUS_API_KEY = 'Your API Key';
const TIP_ACCOUNTS = [
  "4ACfpUFoaSD9bfPdeu6DBt89gB6ENTeHBXCAi87NhDEE",
  "D2L6yPZ2FmmmTKPgzaMKdhu6EWZcTpLy1Vhx8uvZe7NZ", 
  "9bnz4RShgq1hAnLnZbP8kbgBg1kEmcJBYQq3gQbmnSta",
  "5VY91ws6B2hMmBFRsXkoAAdsPHBJwRfBht4DXox3xkwn",
  "2nyhqdwKcJZR2vcqCyrYsaPVdAnFoJjiksCXJ7hfEYgD",
  "2q5pghRs6arqVjRvT5gfgWfWcHWmw1ZuCzphgd5KfWGJ",
  "wyvPkWjVZz1M8fHQnMMCDTQDbkManefNNhweYk5WkcF",
  "3KCKozbAaF75qEU33jtzozcJ29yJuaLJTy2jFdzUY8bT",
  "4vieeGHPYPG2MmyPRcYjdiDmmhN3ww7hsFNap8pVN3Ey",
  "4TQLFNWK8AovT1gFvda5jfw2oJeRMKEmw7aH6MGBJ3or"
];

async function sendWithSender(
  keypair: Keypair, 
  recipientAddress: string
): Promise<string> {
  const connection = new Connection(
    `https://mainnet.helius-rpc.com/?api-key=${HELIUS_API_KEY}`
  );
  
  const { value: { blockhash } } = await connection.getLatestBlockhashAndContext('confirmed');
  
  // Build transaction with tip transfer and transfer to recipient
  const transaction = new VersionedTransaction(
    new TransactionMessage({
      instructions: [
        ComputeBudgetProgram.setComputeUnitLimit({ units: 100_000 }),
        ComputeBudgetProgram.setComputeUnitPrice({ microLamports: 200_000 }),
        SystemProgram.transfer({
          fromPubkey: keypair.publicKey,
          toPubkey: new PublicKey(recipientAddress),
          lamports: 0.001 * LAMPORTS_PER_SOL,
        }),
        SystemProgram.transfer({
          fromPubkey: keypair.publicKey,
          toPubkey: new PublicKey(TIP_ACCOUNTS[Math.floor(Math.random() * TIP_ACCOUNTS.length)]),
          lamports: 0.001 * LAMPORTS_PER_SOL,
        })
      ],
      payerKey: keypair.publicKey,
      recentBlockhash: blockhash,
    }).compileToV0Message()
  );

  // Sign transaction
  transaction.sign([keypair]);
  console.log('Sending transaction via Sender endpoint...');

  const SENDER_ENDPOINT = 'http://slc-sender.helius-rpc.com/fast'; // choose the region closest to your servers
  const response = await fetch(SENDER_ENDPOINT, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      jsonrpc: '2.0',
      id: Date.now().toString(),
      method: 'sendTransaction',
      params: [
        Buffer.from(transaction.serialize()).toString('base64'),
        {
          encoding: 'base64',
          skipPreflight: true, // Required for Sender
          maxRetries: 0
        }
      ]
    })
  });
  const json = await response.json();
  if (json.error) {
    throw new Error(json.error.message);
  }
  const signature = json.result;
  console.log('Transaction sent:', signature);
  
  // Confirmation check
  for (let i = 0; i < 30; i++) {
    const status = await connection.getSignatureStatuses([signature]);
    console.log('Status:', status?.value[0]?.confirmationStatus || 'pending');
    
    if (status?.value[0]?.confirmationStatus === "confirmed") {
      console.log('Transaction confirmed!');
      return signature;
    }
    
    await new Promise(resolve => setTimeout(resolve, 500));
  }
  
  console.log('Transaction may have succeeded but confirmation timed out');
  return signature;
}

// Send transaction
sendWithSender(Keypair.fromSecretKey(bs58.decode(PRIV_B58)), RECIPIENT);
```

### Advanced Example with Dynamic Optimization

The advanced example improves on the simple version with dynamic Jito tips (75th percentile), automatic compute unit calculation, dynamic priority fees, and retry logic.

```typescript [expandable]
import { 
  Connection, 
  TransactionMessage,
  VersionedTransaction,
  SystemProgram, 
  PublicKey,
  Keypair,
  LAMPORTS_PER_SOL,
  ComputeBudgetProgram,
  TransactionInstruction
} from '@solana/web3.js';
import bs58 from 'bs58';

const TIP_ACCOUNTS = [
  "4ACfpUFoaSD9bfPdeu6DBt89gB6ENTeHBXCAi87NhDEE",
  "D2L6yPZ2FmmmTKPgzaMKdhu6EWZcTpLy1Vhx8uvZe7NZ", 
  "9bnz4RShgq1hAnLnZbP8kbgBg1kEmcJBYQq3gQbmnSta",
  "5VY91ws6B2hMmBFRsXkoAAdsPHBJwRfBht4DXox3xkwn",
  "2nyhqdwKcJZR2vcqCyrYsaPVdAnFoJjiksCXJ7hfEYgD",
  "2q5pghRs6arqVjRvT5gfgWfWcHWmw1ZuCzphgd5KfWGJ",
  "wyvPkWjVZz1M8fHQnMMCDTQDbkManefNNhweYk5WkcF",
  "3KCKozbAaF75qEU33jtzozcJ29yJuaLJTy2jFdzUY8bT",
  "4vieeGHPYPG2MmyPRcYjdiDmmhN3ww7hsFNap8pVN3Ey",
  "4TQLFNWK8AovT1gFvda5jfw2oJeRMKEmw7aH6MGBJ3or"
];

async function getDynamicTipAmount(): Promise<number> {
  try {
    const response = await fetch('https://bundles.jito.wtf/api/v1/bundles/tip_floor');
    const data = await response.json();
    
    if (data && data[0] && typeof data[0].landed_tips_75th_percentile === 'number') {
      const tip75th = data[0].landed_tips_75th_percentile;
      // Use 75th percentile but minimum 0.001 SOL
      return Math.max(tip75th, 0.001);
    }
    
    // Fallback if API fails or data is invalid
    return 0.001;
  } catch (error) {
    console.warn('Failed to fetch dynamic tip amount, using fallback:', error);
    return 0.001; // Fallback to minimum
  }
}

async function sendWithSender(
  keypair: Keypair, 
  instructions: TransactionInstruction[]
): Promise<string> {
  const connection = new Connection('https://mainnet.helius-rpc.com/?api-key=YOUR_API_KEY');
  
  // Validate user hasn't included compute budget instructions
  const hasComputeBudget = instructions.some(ix => 
    ix.programId.equals(ComputeBudgetProgram.programId)
  );
  if (hasComputeBudget) {
    throw new Error('Do not include compute budget instructions - they are added automatically');
  }
  
  // Create copy of instructions to avoid modifying the original array
  const allInstructions = [...instructions];
  
  // Get dynamic tip amount from Jito API (75th percentile, minimum 0.001 SOL)
  const tipAmountSOL = await getDynamicTipAmount();
  const tipAccount = new PublicKey(TIP_ACCOUNTS[Math.floor(Math.random() * TIP_ACCOUNTS.length)]);
  
  console.log(`Using dynamic tip amount: ${tipAmountSOL} SOL`);
  
  allInstructions.push(
    SystemProgram.transfer({
      fromPubkey: keypair.publicKey,
      toPubkey: tipAccount,
      lamports: tipAmountSOL * LAMPORTS_PER_SOL,
    })
  );
  
  // Get recent blockhash with context (Helius best practice)
  const { value: blockhashInfo } = await connection.getLatestBlockhashAndContext('confirmed');
  const { blockhash, lastValidBlockHeight } = blockhashInfo;
  
  // Simulate transaction to get compute units
  const testInstructions = [
    ComputeBudgetProgram.setComputeUnitLimit({ units: 1_400_000 }),
    ...allInstructions,
  ];

  const testTransaction = new VersionedTransaction(
    new TransactionMessage({
      instructions: testInstructions,
      payerKey: keypair.publicKey,
      recentBlockhash: blockhash,
    }).compileToV0Message()
  );
  testTransaction.sign([keypair]);

  const simulation = await connection.simulateTransaction(testTransaction, {
    replaceRecentBlockhash: true,
    sigVerify: false,
  });

  if (!simulation.value.unitsConsumed) {
    throw new Error('Simulation failed to return compute units');
  }

  // Set compute unit limit with minimum 1000 CUs and 10% margin (Helius best practice)
  const units = simulation.value.unitsConsumed;
  const computeUnits = units < 1000 ? 1000 : Math.ceil(units * 1.1);
  
  // Get dynamic priority fee from Helius Priority Fee API
  const priorityFee = await getPriorityFee(
    connection, 
    allInstructions, 
    keypair.publicKey, 
    blockhash
  );
  
  // Add compute budget instructions at the BEGINNING (must be first)
  allInstructions.unshift(
    ComputeBudgetProgram.setComputeUnitPrice({ microLamports: priorityFee })
  );
  allInstructions.unshift(
    ComputeBudgetProgram.setComputeUnitLimit({ units: computeUnits })
  );

  // Build final optimized transaction
  const transaction = new VersionedTransaction(
    new TransactionMessage({
      instructions: allInstructions,
      payerKey: keypair.publicKey,
      recentBlockhash: blockhash,
    }).compileToV0Message()
  );
  transaction.sign([keypair]);

  // Send via Sender endpoint with retry logic
  return await sendWithRetry(transaction, connection, lastValidBlockHeight);
}

async function getPriorityFee(
  connection: Connection, 
  instructions: TransactionInstruction[], 
  payerKey: PublicKey, 
  blockhash: string
): Promise<number> {
  try {
    const tempTx = new VersionedTransaction(
      new TransactionMessage({
        instructions,
        payerKey,
        recentBlockhash: blockhash,
      }).compileToV0Message()
    );
    
    const response = await fetch(connection.rpcEndpoint, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        jsonrpc: "2.0",
        id: "1",
        method: "getPriorityFeeEstimate",
        params: [{
          transaction: bs58.encode(tempTx.serialize()),
          options: { recommended: true },
        }],   
      }),
    });
    
    const data = await response.json();
    return data.result?.priorityFeeEstimate ? 
      Math.ceil(data.result.priorityFeeEstimate * 1.2) : 50_000;
  } catch {
    return 50_000; // Fallback fee
  }
}

async function sendWithRetry(
  transaction: VersionedTransaction,
  connection: Connection,
  lastValidBlockHeight: number
): Promise<string> {
  const maxRetries = 3;
  const endpoint = 'http://slc-sender.helius-rpc.com/fast';
  
  for (let attempt = 0; attempt < maxRetries; attempt++) {
    try {
      // Check blockhash validity
      const currentHeight = await connection.getBlockHeight('confirmed');
      if (currentHeight > lastValidBlockHeight) {
        throw new Error('Blockhash expired');
      }
      
      // Send transaction via Sender endpoint
      const response = await fetch(endpoint, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          jsonrpc: "2.0",
          id: Date.now().toString(),
          method: "sendTransaction",
          params: [
            Buffer.from(transaction.serialize()).toString('base64'),
            {
              encoding: "base64",
              skipPreflight: true,    // Required for Sender
              maxRetries: 0           // Implement your own retry logic
            }
          ]
        })
      });
      
      const result = await response.json();
      if (result.error) throw new Error(result.error.message);
      
      console.log(`Transaction sent: ${result.result}`);
      return await confirmTransaction(result.result, connection);
      
    } catch (error) {
      console.warn(`Attempt ${attempt + 1} failed:`, error);
      if (attempt === maxRetries - 1) throw error;
      await new Promise(resolve => setTimeout(resolve, 2000));
    }
  }
  
  throw new Error('All retry attempts failed');
}

async function confirmTransaction(
  signature: string, 
  connection: Connection
): Promise<string> {
  const timeout = 15000;
  const interval = 3000;
  const startTime = Date.now();
  
  while (Date.now() - startTime < timeout) {
    try {
      const status = await connection.getSignatureStatuses([signature]);
      if (status?.value[0]?.confirmationStatus === "confirmed") {
        return signature;
      }
    } catch (error) {
      console.warn('Status check failed:', error);
    }
    await new Promise(resolve => setTimeout(resolve, interval));
  }
  
  throw new Error(`Transaction confirmation timeout: ${signature}`);
}

// Example usage following standard Helius docs pattern
export async function exampleUsage() {
  const keypair = Keypair.fromSecretKey(new Uint8Array([/* your secret key */]));
  
  // 1. Prepare your transaction instructions (USER ADDS THEIR INSTRUCTIONS HERE)
  const instructions: TransactionInstruction[] = [
    SystemProgram.transfer({
      fromPubkey: keypair.publicKey,
      toPubkey: new PublicKey("RECIPIENT_ADDRESS"),
      lamports: 0.1 * LAMPORTS_PER_SOL,
    }),
    // Add more instructions as needed
  ];
  
  // 2. Send with Sender (automatically adds tip + optimizations)
  try {
    const signature = await sendWithSender(keypair, instructions);
    console.log(`Successful transaction: ${signature}`);
  } catch (error) {
    console.error('Transaction failed:', error);
  }
}

export { sendWithSender };
```

## Best Practices

### Endpoint Selection

* **Salt Lake City**: `slc-sender.helius-rpc.com/fast`
* **Newark**: `ewr-sender.helius-rpc.com/fast`
* **London**: `lon-sender.helius-rpc.com/fast`
* **Frankfurt**: `fra-sender.helius-rpc.com/fast`
* **Amsterdam**: `ams-sender.helius-rpc.com/fast`
* **Singapore**: `sg-sender.helius-rpc.com/fast`
* **Tokyo**: `tyo-sender.helius-rpc.com/fast`

For optimal latency, consider co-locating with Helius servers in Frankfurt or London.

### Connection Warming

* Use the `/ping` endpoint during idle periods longer than 1 minute
* Implement periodic ping calls (every 30-60 seconds) to maintain warm connections
* Warm connections before high-frequency trading sessions begin

### Transaction Setup

* Use `skipPreflight: true` and `maxRetries: 0`
* Implement your own retry logic
* Include minimum 0.001 SOL tip to designated accounts
* Fetch blockhash with `'confirmed'` commitment
* Set appropriate compute unit limits

## Rate Limits and Scaling

* **Default Rate Limit**: 3 transactions per second
* **No Credit Usage**: Sender transactions don't consume API credits from your plan

## Support and Scaling

For production deployments requiring higher throughput:

1. **Create a Support Ticket**: Include your expected TPS and use case details
2. **Provide Metrics**: Share your current transaction patterns

Contact support through the [Helius Dashboard](https://dashboard.helius.dev) or join our [Discord community](https://discord.com/invite/6GXdee3gBj).


# Programmatic Solana Staking with Helius SDK
Source: https://www.helius.dev/docs/staking/how-to-stake-with-helius-programmatically

Build seamless Solana staking experiences with the Helius SDK. Complete guide from setup to withdrawal with 0% commission validator integration.

<Info>
  **Zero-Commission Validator**: Stake with the Helius validator and keep 100% of your staking rewards with our 0% commission rate.
</Info>

## Quick Overview

The Helius SDK provides simple methods to handle the complete SOL staking lifecycle programmatically. Perfect for building staking interfaces, DeFi protocols, or automated staking strategies.

<CardGroup cols={3}>
  <Card title="Create & Delegate" icon="plus">
    Set up new stake accounts and delegate to validators in one transaction
  </Card>

  <Card title="Monitor & Manage" icon="chart-line">
    Track rewards, check status, and manage existing stake accounts
  </Card>

  <Card title="Withdraw & Redeem" icon="money-bill">
    Deactivate stakes and withdraw SOL after cooldown periods
  </Card>
</CardGroup>

## Installation & Setup

<CodeGroup>
  ```bash npm
  npm install helius-sdk @solana/web3.js bs58
  ```

  ```bash yarn  
  yarn add helius-sdk @solana/web3.js bs58
  ```

  ```bash pnpm
  pnpm add helius-sdk @solana/web3.js bs58
  ```
</CodeGroup>

<CodeGroup>
  ```typescript Setup
  import { Helius } from 'helius-sdk';
  import { Keypair, Transaction } from '@solana/web3.js';
  import bs58 from 'bs58';

  // Initialize Helius client
  const helius = new Helius('YOUR_API_KEY');

  // Your wallet keypair (load from your secure storage)
  const payer = Keypair.fromSecretKey(/* your secret key */);
  ```
</CodeGroup>

## Staking Basics

<AccordionGroup>
  <Accordion title="How Solana Staking Works">
    **Stake Account**: A special account that locks SOL and delegates it to a validator. Each stake account points to exactly one validator.

    **Rewards**: Validators earn rewards for securing the network. These rewards are distributed to all stake accounts delegated to that validator.

    **Lifecycle**: Create  Delegate  Earn Rewards  Deactivate  Withdraw
  </Accordion>

  <Accordion title="Why Choose Helius Validator">
    * **0% Commission**: Keep 100% of your staking rewards
    * **High Performance**: Reliable block production and minimal downtime
    * **Easy Integration**: Optimized for the Helius SDK with built-in helpers
  </Accordion>

  <Accordion title="Timing & Epochs">
    * **Activation**: Stakes become active at the start of the next epoch (\~2 days)
    * **Deactivation**: Takes effect at the end of the current epoch
    * **Cooldown**: Deactivated stakes can be withdrawn immediately after epoch end
  </Accordion>
</AccordionGroup>

## Getting Started

<Tabs>
  <Tab title="Quick Start">
    Stake SOL in just 3 lines of code:

    ```typescript
    // 1. Create the staking transaction
    const { serializedTx, stakeAccountPubkey } = 
      await helius.rpc.createStakeTransaction(payer.publicKey, 1.5);

    // 2. Sign and send
    const tx = Transaction.from(bs58.decode(serializedTx));
    tx.partialSign(payer);
    const signature = await helius.connection.sendRawTransaction(tx.serialize());

    console.log(`Staked! Transaction: ${signature}`);
    console.log(`Stake Account: ${stakeAccountPubkey}`);
    ```

    <Info>
      The SDK automatically handles rent calculation and stake account creation. The `1.5` parameter is the amount in SOL you want to stake.
    </Info>
  </Tab>

  <Tab title="Complete Example">
    Full staking implementation with error handling:

    ```typescript
    async function stakeSOL(amountInSol: number) {
      try {
        // Create staking transaction
        const { serializedTx, stakeAccountPubkey } = 
          await helius.rpc.createStakeTransaction(payer.publicKey, amountInSol);
        
        // Deserialize and sign transaction
        const transaction = Transaction.from(bs58.decode(serializedTx));
        transaction.partialSign(payer);
        
        // Send transaction
        const signature = await helius.connection.sendRawTransaction(
          transaction.serialize(),
          { 
            skipPreflight: false,
            preflightCommitment: 'confirmed'
          }
        );
        
        // Wait for confirmation
        await helius.connection.confirmTransaction(signature, 'confirmed');
        
        return {
          signature,
          stakeAccount: stakeAccountPubkey,
          amount: amountInSol
        };
        
      } catch (error) {
        console.error('Staking failed:', error);
        throw error;
      }
    }

    // Usage
    const result = await stakeSOL(2.5);
    console.log(`Successfully staked ${result.amount} SOL`);
    ```
  </Tab>
</Tabs>

## SDK Methods Reference

<AccordionGroup>
  <Accordion title="createStakeTransaction(owner, amount)">
    Creates a complete staking transaction that can be signed and sent.

    **Parameters:**

    * `owner` (PublicKey): The wallet that will own the stake account
    * `amount` (number): Amount of SOL to stake

    **Returns:**

    ```typescript
    {
      serializedTx: string,        // Base58 encoded transaction
      stakeAccountPubkey: string   // New stake account address
    }
    ```

    **Example:**

    ```typescript
    const result = await helius.rpc.createStakeTransaction(
      payer.publicKey, 
      1.5  // 1.5 SOL
    );
    ```
  </Accordion>

  <Accordion title="getStakeInstructions(owner, amount)">
    Returns just the instructions for staking (useful for custom transaction building).

    **Returns:**

    ```typescript
    {
      instructions: TransactionInstruction[],
      stakeAccount: Keypair
    }
    ```

    **Example:**

    ```typescript
    const { instructions } = await helius.rpc.getStakeInstructions(
      payer.publicKey, 
      1.5
    );

    // Use with Smart Transactions
    const signature = await helius.rpc.sendSmartTransaction(
      instructions, 
      [payer]
    );
    ```
  </Accordion>

  <Accordion title="getHeliusStakeAccounts(wallet)">
    Retrieves all stake accounts delegated to the Helius validator for a wallet.

    **Example:**

    ```typescript
    const accounts = await helius.rpc.getHeliusStakeAccounts(
      payer.publicKey.toBase58()
    );

    accounts.forEach(account => {
      const delegation = account.account.data.parsed.info.stake.delegation;
      console.log(`Account: ${account.pubkey}`);
      console.log(`Stake: ${delegation.stake / LAMPORTS_PER_SOL} SOL`);
    });
    ```
  </Accordion>

  <Accordion title="createUnstakeTransaction(owner, stakeAccount)">
    Creates a transaction to deactivate (begin unstaking) a stake account.

    **Example:**

    ```typescript
    const tx = await helius.rpc.createUnstakeTransaction(
      payer.publicKey,
      stakeAccountPubkey
    );

    const transaction = Transaction.from(bs58.decode(tx));
    transaction.partialSign(payer);
    await helius.connection.sendRawTransaction(transaction.serialize());
    ```
  </Accordion>

  <Accordion title="getWithdrawableAmount(stakeAccount, includeRent?)">
    Check how much SOL can be withdrawn from a deactivated stake account.

    **Parameters:**

    * `includeRent` (boolean): Whether to include rent-exempt amount

    **Example:**

    ```typescript
    const available = await helius.rpc.getWithdrawableAmount(stakeAccountPubkey);
    const total = await helius.rpc.getWithdrawableAmount(stakeAccountPubkey, true);

    console.log(`Available now: ${available / LAMPORTS_PER_SOL} SOL`);
    console.log(`Total balance: ${total / LAMPORTS_PER_SOL} SOL`);
    ```
  </Accordion>

  <Accordion title="createWithdrawTransaction(owner, stakeAccount, destination, amount)">
    Creates a transaction to withdraw SOL from a deactivated stake account.

    **Example:**

    ```typescript
    const tx = await helius.rpc.createWithdrawTransaction(
      payer.publicKey,
      stakeAccountPubkey,
      destinationPubkey,
      withdrawAmount  // in lamports
    );
    ```
  </Accordion>
</AccordionGroup>

## Complete Staking Workflow

<Steps>
  <Step title="Create and Delegate">
    ```typescript
    // Stake 2 SOL to Helius validator
    const { serializedTx, stakeAccountPubkey } = 
      await helius.rpc.createStakeTransaction(payer.publicKey, 2.0);

    const tx = Transaction.from(bs58.decode(serializedTx));
    tx.partialSign(payer);

    const signature = await helius.connection.sendRawTransaction(tx.serialize());
    console.log(`Stake created: ${stakeAccountPubkey}`);
    ```
  </Step>

  <Step title="Monitor Your Stakes">
    ```typescript
    // Get all your Helius stake accounts
    const accounts = await helius.rpc.getHeliusStakeAccounts(
      payer.publicKey.toBase58()
    );

    console.log(`You have ${accounts.length} active stake accounts`);

    accounts.forEach((account, index) => {
      const info = account.account.data.parsed.info;
      const delegation = info.stake.delegation;
      
      console.log(`Stake ${index + 1}:`);
      console.log(`  Amount: ${delegation.stake / LAMPORTS_PER_SOL} SOL`);
      console.log(`  Activated: Epoch ${delegation.activationEpoch}`);
      console.log(`  Status: ${info.meta.lockup.unixTimestamp === 0 ? 'Active' : 'Locked'}`);
    });
    ```
  </Step>

  <Step title="Deactivate (Start Unstaking)">
    ```typescript
    // Begin the unstaking process
    const unstakeTx = await helius.rpc.createUnstakeTransaction(
      payer.publicKey,
      stakeAccountPubkey
    );

    const tx = Transaction.from(bs58.decode(unstakeTx));
    tx.partialSign(payer);

    await helius.connection.sendRawTransaction(tx.serialize());
    console.log('Deactivation started. Will be withdrawable next epoch.');
    ```
  </Step>

  <Step title="Withdraw SOL">
    ```typescript
    // Check withdrawable amount
    const withdrawable = await helius.rpc.getWithdrawableAmount(
      stakeAccountPubkey, 
      true  // include rent
    );

    if (withdrawable > 0) {
      // Create withdrawal instruction
      const withdrawInstruction = helius.rpc.getWithdrawInstruction(
        payer.publicKey,
        stakeAccountPubkey,
        payer.publicKey,  // withdraw to same wallet
        withdrawable
      );
      
      // Send using Smart Transactions for better reliability
      const signature = await helius.rpc.sendSmartTransaction(
        [withdrawInstruction], 
        [payer]
      );
      
      console.log(`Withdrawn ${withdrawable / LAMPORTS_PER_SOL} SOL`);
    }
    ```
  </Step>
</Steps>

## Advanced Patterns

<Tabs>
  <Tab title="Browser Integration">
    For browser applications using wallet adapters:

    ```typescript
    // Get instructions instead of full transaction
    const { instructions, stakeAccount } = await helius.rpc.getStakeInstructions(
      wallet.publicKey,
      stakeAmount
    );

    // Let the wallet handle transaction building and signing
    const transaction = new Transaction().add(...instructions);

    // Sign with wallet adapter
    const signature = await wallet.sendTransaction(transaction, connection);

    console.log(`Stake account: ${stakeAccount.publicKey.toBase58()}`);
    ```
  </Tab>

  <Tab title="Batch Operations">
    Stake for multiple wallets efficiently:

    ```typescript
    async function batchStake(wallets: Keypair[], amount: number) {
      const promises = wallets.map(async (wallet) => {
        try {
          const { serializedTx, stakeAccountPubkey } = 
            await helius.rpc.createStakeTransaction(wallet.publicKey, amount);
          
          const tx = Transaction.from(bs58.decode(serializedTx));
          tx.partialSign(wallet);
          
          return helius.connection.sendRawTransaction(tx.serialize());
        } catch (error) {
          console.error(`Failed to stake for ${wallet.publicKey.toBase58()}:`, error);
          return null;
        }
      });
      
      const results = await Promise.allSettled(promises);
      const successful = results.filter(r => r.status === 'fulfilled').length;
      
      console.log(`Successfully staked for ${successful}/${wallets.length} wallets`);
    }
    ```
  </Tab>

  <Tab title="Smart Transactions">
    Use Smart Transactions for better reliability and optimization:

    ```typescript
    // Get individual instructions
    const { instructions } = await helius.rpc.getStakeInstructions(
      payer.publicKey,
      2.5
    );

    // Send with Smart Transaction features:
    // - Automatic priority fee optimization
    // - Retry logic with backoff
    // - Better error handling
    const signature = await helius.rpc.sendSmartTransaction(
      instructions,
      [payer],
      {
        skipPreflight: false,
        maxRetries: 3
      }
    );

    console.log(`Smart transaction sent: ${signature}`);
    ```
  </Tab>
</Tabs>

## Important Notes

<Warning>
  **Epoch Timing**: Solana epochs last \~2 days. Stakes activate at the next epoch start, and deactivation takes effect at the current epoch end.
</Warning>

<Note>
  **Rent Considerations**: Stake accounts need rent-exempt reserves (\~0.00228 SOL). Withdrawing the full balance closes the account.
</Note>

<Tip>
  **Hardware Wallets**: Users will see two signature prompts - one for the stake account (pre-signed) and one for the fee payer. Design your UX accordingly.
</Tip>

## Quick Reference

Need a quick reminder? Here are the essential methods:

```typescript
// Stake SOL
await helius.rpc.createStakeTransaction(owner, amountInSol);

// Check your stakes  
await helius.rpc.getHeliusStakeAccounts(ownerAddress);

// Start unstaking
await helius.rpc.createUnstakeTransaction(owner, stakeAccount);

// Check withdrawable amount
await helius.rpc.getWithdrawableAmount(stakeAccount, includeRent);

// Withdraw SOL
helius.rpc.getWithdrawInstruction(owner, stakeAccount, destination, amount);
```

## Next Steps

<CardGroup cols={2}>
  <Card title="Helius SDK Documentation" icon="code" href="https://github.com/helius-labs/helius-sdk">
    Complete SDK reference with all available methods
  </Card>

  <Card title="Smart Transactions" icon="bolt" href="/sending-transactions/smart-transactions">
    Optimize your transactions with priority fees and retry logic
  </Card>

  <Card title="Join Discord" icon="discord" href="https://discord.com/invite/6GXdee3gBj">
    Get help from our developer community
  </Card>

  <Card title="Validator Dashboard" icon="chart-bar" href="https://www.validators.app/validators/EKgWgpJY5BtX7TeJfhKbqcJT7gzLKFFtj7cjX1XY6CxA">
    Monitor Helius validator performance and rewards
  </Card>
</CardGroup>


# Contact Helius Support: Get Help with Solana API Issues
Source: https://www.helius.dev/docs/support/contact-support

Get expert help with Helius Solana API issues. Discord community, chat support, email assistance for billing, technical questions, and troubleshooting.

<CardGroup cols={2}>
  <Card title="Discord Community" icon="discord" href="https://discord.com/invite/6GXdee3gBj">
    Join our community and get help from other developers.
  </Card>

  <Card title="Chat support" icon="headset" href="https://dashboard.helius.dev/support">
    Developer plan and higher tier customers can use the dashboard chat to get
    help from the Helius team.
  </Card>
</CardGroup>

<Card title="Email Support" icon="envelope">
  For billing, account, or technical questions, email us at
  [support@helius.xyz](mailto:support@helius.xyz)
</Card>

## Reporting Technical Issues

<Card title="When Reporting Technical Issues" icon="bug">
  <p>Please include the following information:</p>

  <ol>
    <li>Your Project ID</li>
    <li>Request details (endpoint, parameters)</li>
    <li>Error messages or response codes</li>
    <li>Timestamps of when the issue occurred</li>
    <li>Steps to reproduce the issue</li>
  </ol>
</Card>


# Helius FAQs: Common Questions & Answers
Source: https://www.helius.dev/docs/support/frequently-asked-questions

Answers to common questions about Helius Solana API services, billing, credit limits, account management, and plan upgrades. Quick solutions and guidance.

<Accordion title="How do I get my Project ID?">
  You can find your Project ID in the top left corner of the [Helius
  Dashboard](https://dashboard.helius.dev/project-settings).
</Accordion>

<Accordion title="What happens if I exceed my credit limit?">
  If you exceed your credit limit, you can enable autoscaling or purchase
  additional prepaid credits. Learn more on the [Credits
  page](/billing/credits).
</Accordion>

<Accordion title="How do I upgrade my plan?">
  You can upgrade your plan anytime from the [Helius
  Dashboard](https://dashboard.helius.dev/billing).
</Accordion>

<Accordion title="Do you offer custom solutions?">
  Yes, Enterprise customers can request custom solutions. Contact our [sales
  team](mailto:sales@helius.xyz) to discuss your requirements.
</Accordion>

<CardGroup cols={2}>
  <Card title="Developer Community" icon="discord" href="https://discord.com/invite/6GXdee3gBj">
    Join thousands of developers building on Solana. Share knowledge,
    get help, and connect with peers.
  </Card>

  <Card title="Direct Support" icon="headset" href="https://dashboard.helius.dev/support">
    Get help directly from the Helius team. Available to Developer plan
    subscribers and above.
  </Card>
</CardGroup>


# Helius Status Page: Real-Time Service Monitoring
Source: https://www.helius.dev/docs/support/status-page

Check the Helius system status for real-time service availability and performance information. Monitor Solana API uptime and service health.

<Card title="System Status" icon="wave-pulse" href="https://helius.statuspage.io/">
  Check our Status Page for real-time information about Helius service
  availability and performance.
</Card>


# Solana Webhooks: Real-Time Blockchain Event Notifications
Source: https://www.helius.dev/docs/webhooks

Monitor Solana blockchain events with real-time webhooks. Get instant notifications for NFT sales, token transfers, and transactions sent to your endpoints.

Helius Webhooks enable seamless monitoring of Solana on-chain events, such as sales, listings, swaps, and more. We offer a user-friendly interface, programmatic API, and SDK access for easily creating and managing webhooks.

For a detailed list of supported events, please refer to our [documentation](/webhooks/faqs).

<Warning>
  Webhook events are charged at 1 credit **when Helius processes and sends the event to your endpoint**. You are charged regardless of whether your endpoint successfully processes the webhook or not. Editing, adding, or deleting a webhook via the API will cost 100 credits/request.
</Warning>

## Types of Webhooks

We currently offer several types of webhooks tailored to different needs:

* **Enhanced Transaction Webhooks**: Provide human-readable, parsed data for specific transaction types (e.g., NFT sales) related to the addresses you monitor. This is ideal if you want filtered, actionable insights.
* **Raw Transaction Webhooks**: This option delivers raw transaction data for all transactions involving the addresses you monitor. It does not allow filtering by transaction type.
* **Discord Webhooks**: Stream updates for specific transaction types directly to a designated Discord channel as formatted messages. To use this option, you must submit your Discord Webhook URL.

<Info>
  Raw Transaction Webhooks offer lower latency since they do not involve parsing event types.
</Info>

### Event Payload Example

<Accordion title="Enhanced">
  ```json
  [
    {
      "accountData": [
        {
          "account": "CKs1E69a2e9TmH4mKKLrXFF8kD3ZnwKjoEuXa6sz9WqX",
          "nativeBalanceChange": -72938049280,
          "tokenBalanceChanges": []
        },
        {
          "account": "NTYeYJ1wr4bpM5xo6zx5En44SvJFAd35zTxxNoERYqd",
          "nativeBalanceChange": 0,
          "tokenBalanceChanges": []
        },
        {
          "account": "AAaTGaA3uVqikfVEwoSG7EwkCb4bBDsMEyueiVUS5CaU",
          "nativeBalanceChange": 0,
          "tokenBalanceChanges": []
        },
        {
          "account": "autMW8SgBkVYeBgqYiTuJZnkvDZMVU2MHJh9Jh7CSQ2",
          "nativeBalanceChange": 0,
          "tokenBalanceChanges": []
        },
        {
          "account": "D8TxfGwdu9MiNMoJmUoC9wQfNfNT7Lnm6DzifQHRTy6B",
          "nativeBalanceChange": 0,
          "tokenBalanceChanges": []
        },
        {
          "account": "5DxD5ViWjvRZEkxQEaJHZw2sBsso6xoXx3wGFNKgXUzE",
          "nativeBalanceChange": 71860273440,
          "tokenBalanceChanges": []
        },
        {
          "account": "25DTUAd1roBFoUQaxJQByL6Qy2cKQCBp4bK9sgfy9UiM",
          "nativeBalanceChange": -2039280,
          "tokenBalanceChanges": [
            {
              "mint": "FdsNQE5EeCe57tbEYCRV1JwW5dzNCof7MUTaGWhmzYqu",
              "rawTokenAmount": {
                "decimals": 0,
                "tokenAmount": "-1"
              },
              "tokenAccount": "25DTUAd1roBFoUQaxJQByL6Qy2cKQCBp4bK9sgfy9UiM",
              "userAccount": "1BWutmTvYPwDtmw9abTkS4Ssr8no61spGAvW1X6NDix"
            }
          ]
        },
        {
          "account": "DTYuh7gAGGZg2okM7hdFfU1yMY9LUemCiPyD5Z5GCs6Z",
          "nativeBalanceChange": 2039280,
          "tokenBalanceChanges": [
            {
              "mint": "FdsNQE5EeCe57tbEYCRV1JwW5dzNCof7MUTaGWhmzYqu",
              "rawTokenAmount": {
                "decimals": 0,
                "tokenAmount": "1"
              },
              "tokenAccount": "DTYuh7gAGGZg2okM7hdFfU1yMY9LUemCiPyD5Z5GCs6Z",
              "userAccount": "CKs1E69a2e9TmH4mKKLrXFF8kD3ZnwKjoEuXa6sz9WqX"
            }
          ]
        },
        {
          "account": "rFqFJ9g7TGBD8Ed7TPDnvGKZ5pWLPDyxLcvcH2eRCtt",
          "nativeBalanceChange": 1080000000,
          "tokenBalanceChanges": []
        },
        {
          "account": "CgXS5xC3qAGSg9txD9bS7BUgugZwshivGXpCJcGmdwrd",
          "nativeBalanceChange": -2234160,
          "tokenBalanceChanges": []
        },
        {
          "account": "M2mx93ekt1fmXSVkTrUL9xVFHkmME8HTUi5Cyc5aF7K",
          "nativeBalanceChange": 0,
          "tokenBalanceChanges": []
        },
        {
          "account": "E8cU1WiRWjanGxmn96ewBgk9vPTcL6AEZ1t6F6fkgUWe",
          "nativeBalanceChange": 0,
          "tokenBalanceChanges": []
        },
        {
          "account": "11111111111111111111111111111111",
          "nativeBalanceChange": 0,
          "tokenBalanceChanges": []
        },
        {
          "account": "FdsNQE5EeCe57tbEYCRV1JwW5dzNCof7MUTaGWhmzYqu",
          "nativeBalanceChange": 0,
          "tokenBalanceChanges": []
        },
        {
          "account": "AYZsWahcrSnkwqbA1ji7wEzgAnGjLNJhVUMDPfACECZf",
          "nativeBalanceChange": 0,
          "tokenBalanceChanges": []
        },
        {
          "account": "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA",
          "nativeBalanceChange": 0,
          "tokenBalanceChanges": []
        },
        {
          "account": "SysvarRent111111111111111111111111111111111",
          "nativeBalanceChange": 0,
          "tokenBalanceChanges": []
        },
        {
          "account": "ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL",
          "nativeBalanceChange": 0,
          "tokenBalanceChanges": []
        },
        {
          "account": "1BWutmTvYPwDtmw9abTkS4Ssr8no61spGAvW1X6NDix",
          "nativeBalanceChange": 0,
          "tokenBalanceChanges": []
        }
      ],
      "description": "5DxD5ViWjvRZEkxQEaJHZw2sBsso6xoXx3wGFNKgXUzE sold Fox #7637 to CKs1E69a2e9TmH4mKKLrXFF8kD3ZnwKjoEuXa6sz9WqX for 72 SOL on MAGIC_EDEN.",
      "events": {
        "nft": {
          "amount": 72000000000,
          "buyer": "CKs1E69a2e9TmH4mKKLrXFF8kD3ZnwKjoEuXa6sz9WqX",
          "description": "5DxD5ViWjvRZEkxQEaJHZw2sBsso6xoXx3wGFNKgXUzE sold Fox #7637 to CKs1E69a2e9TmH4mKKLrXFF8kD3ZnwKjoEuXa6sz9WqX for 72 SOL on MAGIC_EDEN.",
          "fee": 10000,
          "feePayer": "CKs1E69a2e9TmH4mKKLrXFF8kD3ZnwKjoEuXa6sz9WqX",
          "nfts": [
            {
              "mint": "FdsNQE5EeCe57tbEYCRV1JwW5dzNCof7MUTaGWhmzYqu",
              "tokenStandard": "NonFungible"
            }
          ],
          "saleType": "INSTANT_SALE",
          "seller": "5DxD5ViWjvRZEkxQEaJHZw2sBsso6xoXx3wGFNKgXUzE",
          "signature": "5nNtjezQMYBHvgSQmoRmJPiXGsPAWmJPoGSa64xanqrauogiVzFyGQhKeFataHGXq51jR2hjbzNTkPUpP787HAmL",
          "slot": 171942732,
          "source": "MAGIC_EDEN",
          "staker": "",
          "timestamp": 1673445241,
          "type": "NFT_SALE"
        }
      },
      "fee": 10000,
      "feePayer": "CKs1E69a2e9TmH4mKKLrXFF8kD3ZnwKjoEuXa6sz9WqX",
      "nativeTransfers": [
        {
          "amount": 72936000000,
          "fromUserAccount": "CKs1E69a2e9TmH4mKKLrXFF8kD3ZnwKjoEuXa6sz9WqX",
          "toUserAccount": "AAaTGaA3uVqikfVEwoSG7EwkCb4bBDsMEyueiVUS5CaU"
        },
        {
          "amount": 2011440,
          "fromUserAccount": "CKs1E69a2e9TmH4mKKLrXFF8kD3ZnwKjoEuXa6sz9WqX",
          "toUserAccount": "D8TxfGwdu9MiNMoJmUoC9wQfNfNT7Lnm6DzifQHRTy6B"
        },
        {
          "amount": 71856000000,
          "fromUserAccount": "AAaTGaA3uVqikfVEwoSG7EwkCb4bBDsMEyueiVUS5CaU",
          "toUserAccount": "5DxD5ViWjvRZEkxQEaJHZw2sBsso6xoXx3wGFNKgXUzE"
        },
        {
          "amount": 1080000000,
          "fromUserAccount": "AAaTGaA3uVqikfVEwoSG7EwkCb4bBDsMEyueiVUS5CaU",
          "toUserAccount": "rFqFJ9g7TGBD8Ed7TPDnvGKZ5pWLPDyxLcvcH2eRCtt"
        },
        {
          "amount": 2039280,
          "fromUserAccount": "CKs1E69a2e9TmH4mKKLrXFF8kD3ZnwKjoEuXa6sz9WqX",
          "toUserAccount": "DTYuh7gAGGZg2okM7hdFfU1yMY9LUemCiPyD5Z5GCs6Z"
        }
      ],
      "signature": "5nNtjezQMYBHvgSQmoRmJPiXGsPAWmJPoGSa64xanqrauogiVzFyGQhKeFataHGXq51jR2hjbzNTkPUpP787HAmL",
      "slot": 171942732,
      "source": "MAGIC_EDEN",
      "timestamp": 1673445241,
      "tokenTransfers": [
        {
          "fromTokenAccount": "25DTUAd1roBFoUQaxJQByL6Qy2cKQCBp4bK9sgfy9UiM",
          "fromUserAccount": "1BWutmTvYPwDtmw9abTkS4Ssr8no61spGAvW1X6NDix",
          "mint": "FdsNQE5EeCe57tbEYCRV1JwW5dzNCof7MUTaGWhmzYqu",
          "toTokenAccount": "DTYuh7gAGGZg2okM7hdFfU1yMY9LUemCiPyD5Z5GCs6Z",
          "toUserAccount": "CKs1E69a2e9TmH4mKKLrXFF8kD3ZnwKjoEuXa6sz9WqX",
          "tokenAmount": 1,
          "tokenStandard": "NonFungible"
        }
      ],
      "type": "NFT_SALE"
    }
  ]
  ```
</Accordion>

<Accordion title="Raw">
  ```javascript
  [
    {
      "blockTime": 1673445241,
      "indexWithinBlock": 2557,
      "meta": {
        "err": null,
        "fee": 10000,
        "innerInstructions": [
          {
            "index": 0,
            "instructions": [
              {
                "accounts": [
                  0,
                  2
                ],
                "data": "3Bxs3zs3x6pg4XWo",
                "programIdIndex": 12
              }
            ]
          },
          {
            "index": 1,
            "instructions": [
              {
                "accounts": [
                  0,
                  4
                ],
                "data": "11112nba6qLH4BKL4MW8GP9ayKApZeYn3LQKJdPdeSXbRW1n6UPeJ8y77ps6sAVwAjdxzh",
                "programIdIndex": 12
              }
            ]
          },
          {
            "index": 2,
            "instructions": [
              {
                "accounts": [
                  2,
                  5
                ],
                "data": "3Bxs3zx147oWJQej",
                "programIdIndex": 12
              },
              {
                "accounts": [
                  2,
                  8
                ],
                "data": "3Bxs3zwT1TGLhiT9",
                "programIdIndex": 12
              },
              {
                "accounts": [
                  0,
                  7,
                  0,
                  13,
                  12,
                  15
                ],
                "data": "1",
                "programIdIndex": 17
              },
              {
                "accounts": [
                  13
                ],
                "data": "84eT",
                "programIdIndex": 15
              },
              {
                "accounts": [
                  0,
                  7
                ],
                "data": "11119os1e9qSs2u7TsThXqkBSRVFxhmYaFKFZ1waB2X7armDmvK3p5GmLdUxYdg3h7QSrL",
                "programIdIndex": 12
              },
              {
                "accounts": [
                  7
                ],
                "data": "P",
                "programIdIndex": 15
              },
              {
                "accounts": [
                  7,
                  13
                ],
                "data": "6YTZgAHgNKVRJ2mAHQUYC1DgXF6dPCgbSWA5P4gZoSfGV",
                "programIdIndex": 15
              },
              {
                "accounts": [
                  6,
                  7,
                  18
                ],
                "data": "3DdGGhkhJbjm",
                "programIdIndex": 15
              },
              {
                "accounts": [
                  6,
                  5,
                  18
                ],
                "data": "A",
                "programIdIndex": 15
              }
            ]
          }
        ],
        "loadedAddresses": {
          "readonly": [],
          "writable": []
        },
        "logMessages": [
          "Program M2mx93ekt1fmXSVkTrUL9xVFHkmME8HTUi5Cyc5aF7K invoke [1]",
          "Program log: Instruction: Deposit",
          "Program 11111111111111111111111111111111 invoke [2]",
          "Program 11111111111111111111111111111111 success",
          "Program M2mx93ekt1fmXSVkTrUL9xVFHkmME8HTUi5Cyc5aF7K consumed 10148 of 600000 compute units",
          "Program M2mx93ekt1fmXSVkTrUL9xVFHkmME8HTUi5Cyc5aF7K success",
          "Program M2mx93ekt1fmXSVkTrUL9xVFHkmME8HTUi5Cyc5aF7K invoke [1]",
          "Program log: Instruction: Buy",
          "Program 11111111111111111111111111111111 invoke [2]",
          "Program 11111111111111111111111111111111 success",
          "Program log: {\"price\":72000000000,\"buyer_expiry\":0}",
          "Program M2mx93ekt1fmXSVkTrUL9xVFHkmME8HTUi5Cyc5aF7K consumed 30501 of 589852 compute units",
          "Program M2mx93ekt1fmXSVkTrUL9xVFHkmME8HTUi5Cyc5aF7K success",
          "Program M2mx93ekt1fmXSVkTrUL9xVFHkmME8HTUi5Cyc5aF7K invoke [1]",
          "Program log: Instruction: ExecuteSaleV2",
          "Program 11111111111111111111111111111111 invoke [2]",
          "Program 11111111111111111111111111111111 success",
          "Program 11111111111111111111111111111111 invoke [2]",
          "Program 11111111111111111111111111111111 success",
          "Program ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL invoke [2]",
          "Program log: Create",
          "Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA invoke [3]",
          "Program log: Instruction: GetAccountDataSize",
          "Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA consumed 1622 of 497733 compute units",
          "Program return: TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA pQAAAAAAAAA=",
          "Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA success",
          "Program 11111111111111111111111111111111 invoke [3]",
          "Program 11111111111111111111111111111111 success",
          "Program log: Initialize the associated token account",
          "Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA invoke [3]",
          "Program log: Instruction: InitializeImmutableOwner",
          "Program log: Please upgrade to SPL Token 2022 for immutable owner support",
          "Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA consumed 1405 of 491243 compute units",
          "Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA success",
          "Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA invoke [3]",
          "Program log: Instruction: InitializeAccount3",
          "Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA consumed 4241 of 487361 compute units",
          "Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA success",
          "Program ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL consumed 21793 of 504630 compute units",
          "Program ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL success",
          "Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA invoke [2]",
          "Program log: Instruction: Transfer",
          "Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA consumed 4645 of 475696 compute units",
          "Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA success",
          "Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA invoke [2]",
          "Program log: Instruction: CloseAccount",
          "Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA consumed 3033 of 456654 compute units",
          "Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA success",
          "Program log: {\"price\":72000000000,\"seller_expiry\":-1,\"buyer_expiry\":0}",
          "Program M2mx93ekt1fmXSVkTrUL9xVFHkmME8HTUi5Cyc5aF7K consumed 109266 of 559351 compute units",
          "Program M2mx93ekt1fmXSVkTrUL9xVFHkmME8HTUi5Cyc5aF7K success"
        ],
        "postBalances": [
          371980779080,
          0,
          0,
          100129388687,
          0,
          81872924494,
          0,
          2039280,
          993583055919,
          0,
          1141440,
          3654000,
          1,
          1461600,
          5616720,
          934087680,
          1009200,
          731913600,
          457953014766
        ],
        "postTokenBalances": [
          {
            "accountIndex": 7,
            "mint": "FdsNQE5EeCe57tbEYCRV1JwW5dzNCof7MUTaGWhmzYqu",
            "owner": "CKs1E69a2e9TmH4mKKLrXFF8kD3ZnwKjoEuXa6sz9WqX",
            "programId": "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA",
            "uiTokenAmount": {
              "amount": "1",
              "decimals": 0,
              "uiAmount": 1,
              "uiAmountString": "1"
            }
          }
        ],
        "preBalances": [
          444918828360,
          0,
          0,
          100129388687,
          0,
          10012651054,
          2039280,
          0,
          992503055919,
          2234160,
          1141440,
          3654000,
          1,
          1461600,
          5616720,
          934087680,
          1009200,
          731913600,
          457953014766
        ],
        "preTokenBalances": [
          {
            "accountIndex": 6,
            "mint": "FdsNQE5EeCe57tbEYCRV1JwW5dzNCof7MUTaGWhmzYqu",
            "owner": "1BWutmTvYPwDtmw9abTkS4Ssr8no61spGAvW1X6NDix",
            "programId": "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA",
            "uiTokenAmount": {
              "amount": "1",
              "decimals": 0,
              "uiAmount": 1,
              "uiAmountString": "1"
            }
          }
        ],
        "rewards": []
      },
      "slot": 171942732,
      "transaction": {
        "message": {
          "accountKeys": [
            "CKs1E69a2e9TmH4mKKLrXFF8kD3ZnwKjoEuXa6sz9WqX",
            "NTYeYJ1wr4bpM5xo6zx5En44SvJFAd35zTxxNoERYqd",
            "AAaTGaA3uVqikfVEwoSG7EwkCb4bBDsMEyueiVUS5CaU",
            "autMW8SgBkVYeBgqYiTuJZnkvDZMVU2MHJh9Jh7CSQ2",
            "D8TxfGwdu9MiNMoJmUoC9wQfNfNT7Lnm6DzifQHRTy6B",
            "5DxD5ViWjvRZEkxQEaJHZw2sBsso6xoXx3wGFNKgXUzE",
            "25DTUAd1roBFoUQaxJQByL6Qy2cKQCBp4bK9sgfy9UiM",
            "DTYuh7gAGGZg2okM7hdFfU1yMY9LUemCiPyD5Z5GCs6Z",
            "rFqFJ9g7TGBD8Ed7TPDnvGKZ5pWLPDyxLcvcH2eRCtt",
            "CgXS5xC3qAGSg9txD9bS7BUgugZwshivGXpCJcGmdwrd",
            "M2mx93ekt1fmXSVkTrUL9xVFHkmME8HTUi5Cyc5aF7K",
            "E8cU1WiRWjanGxmn96ewBgk9vPTcL6AEZ1t6F6fkgUWe",
            "11111111111111111111111111111111",
            "FdsNQE5EeCe57tbEYCRV1JwW5dzNCof7MUTaGWhmzYqu",
            "AYZsWahcrSnkwqbA1ji7wEzgAnGjLNJhVUMDPfACECZf",
            "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA",
            "SysvarRent111111111111111111111111111111111",
            "ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL",
            "1BWutmTvYPwDtmw9abTkS4Ssr8no61spGAvW1X6NDix"
          ],
          "addressTableLookups": null,
          "header": {
            "numReadonlySignedAccounts": 1,
            "numReadonlyUnsignedAccounts": 9,
            "numRequiredSignatures": 2
          },
          "instructions": [
            {
              "accounts": [
                0,
                1,
                2,
                3,
                11,
                12
              ],
              "data": "3GyWrkssW12wSfxjTynBnbif",
              "programIdIndex": 10
            },
            {
              "accounts": [
                0,
                1,
                13,
                14,
                2,
                3,
                11,
                4,
                3,
                15,
                12,
                16
              ],
              "data": "3Jmjmsq2jyrch5iz612vBLZCRB498owPe7qezQVetRZhiMu",
              "programIdIndex": 10
            },
            {
              "accounts": [
                0,
                5,
                1,
                6,
                13,
                14,
                2,
                7,
                3,
                11,
                8,
                4,
                3,
                9,
                3,
                15,
                12,
                17,
                18,
                16
              ],
              "data": "B2rqPwAgvj3t35y6HpdumfhdhsZMLNFLmXMC9Uz2HX4nNAwirTk3o98vTazFB1y",
              "programIdIndex": 10
            }
          ],
          "recentBlockhash": "3NRncb7FJuDruQjMDxnHvJBQkvkHa7KSUBqBsxG21roZ"
        },
        "signatures": [
          "5nNtjezQMYBHvgSQmoRmJPiXGsPAWmJPoGSa64xanqrauogiVzFyGQhKeFataHGXq51jR2hjbzNTkPUpP787HAmL",
          "4dWBkbLHGvU2jw9Sjj6YETtKfaVKAAN1M8aWzXRNC4aHBckUzM73n3FddNbWTtfUvkU2vFRQ7bKHMwKZQ5dGy1iH"
        ]
      }
    }
  ]
  ```
</Accordion>

## Quick Start

We provide three convenient methods to create, edit, and manage webhooks on Helius.

### Via Helius Dashboard

The Helius UI is perfect if you prefer a no-code solution with additional features like viewing logs and sending test webhook events. You can access it directly through our [Dashboard](https://dashboard.helius.dev/webhooks). You can add up to 25 addresses via the Dashboard. To monitor more than 25 addresses, you can use our API or SDK.

<Accordion title="Via Dashboard">
  You can create a webhook directly from the dashboard:

  1. Navigate to the [Helius Dashboard](https://dashboard.helius.dev/webhooks)
  2. Click "Add Webhook"
  3. Complete the required fields
  4. Click "Create Webhook"
</Accordion>

### Via Helius API

If you're not working with Typescript or Javascript, you'll need to interact with our webhooks through REST API:

<Card title="API Reference" icon="code" href="/api-reference/webhooks">
  Learn about the Webhooks API endpoints and how to use them.
</Card>

### Via Helius SDK

The easiestand most enjoyableway to interact with Helius webhooks is through our official SDKs. We currently offer SDKs for **TypeScript** and **Rust**.

<CardGroup cols={2}>
  <Card title="TypeScript SDK" icon="js" href="https://github.com/helius-labs/helius-sdk#webhooks">
    The TypeScript SDK provides powerful abstractions for webhooks.
  </Card>

  <Card title="Rust SDK" icon="rust" href="https://github.com/helius-labs/helius-rust-sdk">
    Our Rust SDK offers native Rust support for Helius webhooks.
  </Card>
</CardGroup>

The SDKs provide powerful abstractions that enhance the functionality of webhooks.

## Example Uses

* **Bots**
  * When an NFT is listed on marketplace X, trigger an "NFT buy" action.
  * When a margin position is unhealthy, trigger a "liquidation" action.
* **Monitoring & Alerts**
  * When a program emits a certain log, it triggers PagerDuty integration.
  * When a token account balance changes by more than X%, use Dialect to communicate a warning action.
* **Event-driven Indexing**
  * When any transaction occurs for a given program, send it directly to your database or backend.
* **Notifications & Activity Tracking**
  * When transferring from wallet X to wallet Y  send a Slack notification or email.
* **Analytics & Logs**
  * When event X happens, send it to an ETL pipeline or persist it directly on Helius to view trends over time.
* **Workflow Automation**
  * When event X happens, trigger any set of actions.


# Solana Webhook FAQ: Common Questions & Answers
Source: https://www.helius.dev/docs/webhooks/faqs

Find answers to common questions about Helius Solana webhooks including retry policies, transaction types, rate limits, and implementation tips.

## What is the retry policy for webhooks?

Currently, we resend unacknowledged webhook events once per minute for three minutes. We also offer customizable retry policies for enterprise plans.

## When does the Webhook send a notification?

Webhooks notify as soon as a transaction is confirmed.

## What is the difference between "raw" and "enhanced" webhooks?

Raw webhooks are regular Solana transactions. When a transaction occurs for the given addresses in a raw webhook, those transactions will be directly sent to the webhook URL supplied by the user.\
\
Enhanced webhooks are for Helius' interpreted transaction types. We parse over 100 types of Solana transactions, including NFT listings, DeFi swaps, Solana transfers, etc., and abstract these into our own schema. If you want to listen for any transaction and don't want Helius abstractions, use raw webhooks. If you want built-in transaction type detectio&#x6E;**, use enhanced webhooks.**

## **Are webhooks available on Devnet?**

Yes!

## How many addresses can I input for 1 webhook?

Up to 100,000 addresses.

## How can I verify that the webhook came from Helius?

You can specify an authorization header when creating (or updating) a webhook. Helius will include set the value in the `Authorization` header when sending data to your webhook.

## Can I input "localhost" for my webhook URL?

No! This is a very common mistake. We can not detect your own local servers from just "localhost."

## Can I monitor an entire NFT collection?

Yes, you can! See the [Helius SDK](https://github.com/helius-labs/helius-sdk#collection-webhooks) for a code example.

## Do webhooks post failed transactions?

It depends on the type. Enhanced webhooks do not, but raw webhooks do!


# Solana Webhook Transaction Types
Source: https://www.helius.dev/docs/webhooks/transaction-types

Complete reference guide to Solana webhook transaction types. Learn about NFT sales, DeFi swaps, staking, and 100+ supported blockchain transaction types.

## Understanding Transaction Types

Transaction types represent different blockchain actions decoded by our system. Each transaction type corresponds to specific on-chain activities like NFT minting, bidding, or staking.

Below is the full list of transaction types supported:

```yaml [expandable]
- UNKNOWN
- NFT_BID 
- NFT_BID_CANCELLED
- NFT_LISTING
- NFT_CANCEL_LISTING
- NFT_SALE
- NFT_MINT
- NFT_AUCTION_CREATED
- NFT_AUCTION_UPDATED
- NFT_AUCTION_CANCELLED
- NFT_PARTICIPATION_REWARD 
- NFT_MINT_REJECTED
- CREATE_STORE
- WHITELIST_CREATOR
- ADD_TO_WHITELIST
- REMOVE_FROM_WHITELIST
- AUCTION_MANAGER_CLAIM_BID
- EMPTY_PAYMENT_ACCOUNT
- UPDATE_PRIMARY_SALE_METADATA
- ADD_TOKEN_TO_VAULT
- ACTIVATE_VAULT
- INIT_VAULT
- INIT_BANK
- INIT_STAKE
- MERGE_STAKE
- SPLIT_STAKE
- SET_BANK_FLAGS
- SET_VAULT_LOCK
- UPDATE_VAULT_OWNER
- UPDATE_BANK_MANAGER
- RECORD_RARITY_POINTS
- ADD_RARITIES_TO_BANK
- INIT_FARM
- INIT_FARMER
- REFRESH_FARMER
- UPDATE_FARM
- AUTHORIZE_FUNDER
- DEAUTHORIZE_FUNDER
- FUND_REWARD
- CANCEL_REWARD
- LOCK_REWARD
- PAYOUT
- VALIDATE_SAFETY_DEPOSIT_BOX_V2
- SET_AUTHORITY
- INIT_AUCTION_MANAGER_V2
- UPDATE_EXTERNAL_PRICE_ACCOUNT
- AUCTION_HOUSE_CREATE
- CLOSE_ESCROW_ACCOUNT
- WITHDRAW
- DEPOSIT 
- TRANSFER
- BURN
- BURN_NFT
- PLATFORM_FEE
- LOAN
- REPAY_LOAN
- ADD_TO_POOL
- REMOVE_FROM_POOL
- CLOSE_POSITION
- UNLABELED
- CLOSE_ACCOUNT
- WITHDRAW_GEM
- DEPOSIT_GEM
- STAKE_TOKEN
- UNSTAKE_TOKEN
- STAKE_SOL
- UNSTAKE_SOL
- CLAIM_REWARDS
- BUY_SUBSCRIPTION
- BUY
- SELL
- SWAP
- INIT_SWAP
- CANCEL_SWAP
- REJECT_SWAP
- INITIALIZE_ACCOUNT
- TOKEN_MINT
- CREATE_APPARAISAL
- FUSE
- DEPOSIT_FRACTIONAL_POOL
- FRACTIONALIZE
- CREATE_RAFFLE
- BUY_TICKETS
- UPDATE_ITEM
- LIST_ITEM
- DELIST_ITEM
- ADD_ITEM
- CLOSE_ITEM
- BUY_ITEM
- FILL_ORDER
- UPDATE_ORDER
- CREATE_ORDER
- CLOSE_ORDER
- CANCEL_ORDER
- KICK_ITEM
- UPGRADE_FOX
- UPGRADE_FOX_REQUEST
- LOAN_FOX
- BORROW_FOX
- SWITCH_FOX_REQUEST
- SWITCH_FOX
- CREATE_ESCROW
- ACCEPT_REQUEST_ARTIST
- CANCEL_ESCROW
- ACCEPT_ESCROW_ARTIST
- ACCEPT_ESCROW_USER
- PLACE_BET
- PLACE_SOL_BET
- CREATE_BET
- NFT_RENT_UPDATE_LISTING
- NFT_RENT_ACTIVATE
- NFT_RENT_CANCEL_LISTING
- NFT_RENT_LISTING
- FINALIZE_PROGRAM_INSTRUCTION
- UPGRADE_PROGRAM_INSTRUCTION
- NFT_GLOBAL_BID
- NFT_GLOBAL_BID_CANCELLED
- EXECUTE_TRANSACTION
- APPROVE_TRANSACTION
- ACTIVATE_TRANSACTION
- CREATE_TRANSACTION
- REJECT_TRANSACTION
- CANCEL_TRANSACTION
- ADD_INSTRUCTION
- ATTACH_METADATA
- REQUEST_PNFT_MIGRATION
- START_PNFT_MIGRATION
- MIGRATE_TO_PNFT
- UPDATE_RAFFLE
- CREATE_POOL
- ADD_LIQUIDITY
- WITHDRAW_LIQUIDITY
```

If you'd like us to parse a transaction type that isn't listed above, feel free to reach out on our [Discord](https://discord.com/invite/6GXdee3gBj).

## Mapping Transaction Types to Sources

Each transaction type is generated by specific program sources. Understanding these relationships helps identify which programs are triggering particular transaction types.

The mappings below illustrate the relationship between sources (programs) and specific transaction types:

* **Type-to-Source**: Shows which programs generate a specific transaction type
* **Source-to-Type**: Shows all transaction types a specific program can generate

For example, **NFT\_GLOBAL\_BID** transactions are generated by **MAGIC\_EDEN** or **SOLANART**, while **CANDY\_MACHINE\_V2** exclusively generates **NFT\_MINT** events.

## Type-to-Source Reference

This mapping shows which program sources can generate each transaction type.

```json [expandable]
{
  "NFT_MINT": [
    "CANDY_MACHINE_V2",
    "CANDY_MACHINE_V1",
    "CANDY_MACHINE_V3",
    "FORM_FUNCTION",
    "MAGIC_EDEN",
    "LAUNCH_MY_NFT",
    "BIFROST",
    "ATADIA",
    "ELIXIR_LAUNCHPAD",
    "SOLANA_PROGRAM_LIBRARY",
    "METAPLEX"
  ],
  "TOKEN_MINT": [
    "CANDY_MACHINE_V1",
    "ATADIA",
    "SOLANA_PROGRAM_LIBRARY"
  ],
  "CANDY_MACHINE_UPDATE": [
    "CANDY_MACHINE_V3"
  ],
  "CANDY_MACHINE_ROUTE": [
    "CANDY_MACHINE_V3"
  ],
  "CANDY_MACHINE_WRAP": [
    "CANDY_MACHINE_V3"
  ],
  "CANDY_MACHINE_UNWRAP": [
    "CANDY_MACHINE_V3"
  ],
  "NFT_BID": [
    "FORM_FUNCTION",
    "EXCHANGE_ART",
    "SOLANART",
    "MAGIC_EDEN",
    "ENGLISH_AUCTION",
    "YAWWW",
    "HYPERSPACE",
    "METAPLEX",
    "FOXY_AUCTION"
  ],
  "NFT_SALE": [
    "FORM_FUNCTION",
    "EXCHANGE_ART",
    "SOLANART",
    "MAGIC_EDEN",
    "ENGLISH_AUCTION",
    "SOLSEA",
    "YAWWW",
    "DIGITAL_EYES",
    "HYPERSPACE",
    "TENSOR",
    "METAPLEX",
    "FOXY_AUCTION"
  ],
  "NFT_LISTING": [
    "FORM_FUNCTION",
    "EXCHANGE_ART",
    "SOLANART",
    "MAGIC_EDEN",
    "SOLSEA",
    "YAWWW",
    "HYPERSPACE",
    "TENSOR",
    "METAPLEX"
  ],
  "NFT_CANCEL_LISTING": [
    "EXCHANGE_ART",
    "SOLANART",
    "MAGIC_EDEN",
    "SOLSEA",
    "YAWWW",
    "HYPERSPACE",
    "TENSOR"
  ],
  "NFT_BID_CANCELLED": [
    "EXCHANGE_ART",
    "SOLANART",
    "MAGIC_EDEN",
    "YAWWW",
    "HYPERSPACE",
    "METAPLEX"
  ],
  "NFT_GLOBAL_BID": [
    "SOLANART",
    "MAGIC_EDEN"
  ],
  "NFT_GLOBAL_BID_CANCELLED": [
    "SOLANART",
    "MAGIC_EDEN"
  ],
  "WITHDRAW": [
    "MAGIC_EDEN",
    "BIFROST",
    "STAKE_PROGRAM",
    "PUMP_AMM"
  ],
  "DEPOSIT": [
    "MAGIC_EDEN",
    "PUMP_AMM"
  ],
  "NFT_AUCTION_CREATED": [
    "ENGLISH_AUCTION",
    "METAPLEX",
    "FOXY_AUCTION"
  ],
  "NFT_AUCTION_UPDATED": [
    "ENGLISH_AUCTION"
  ],
  "NFT_AUCTION_CANCELLED": [
    "ENGLISH_AUCTION",
    "FOXY_AUCTION"
  ],
  "TRANSFER": [
    "PHANTOM",
    "SOLANA_PROGRAM_LIBRARY",
    "SYSTEM_PROGRAM"
  ],
  "INIT_BANK": [
    "GEM_BANK",
    "DEGODS",
    "BLOCKSMITH_LABS"
  ],
  "SET_BANK_FLAGS": [
    "GEM_BANK",
    "DEGODS",
    "BLOCKSMITH_LABS"
  ],
  "INIT_VAULT": [
    "GEM_BANK",
    "DEGODS",
    "BLOCKSMITH_LABS",
    "METAPLEX"
  ],
  "SET_VAULT_LOCK": [
    "GEM_BANK",
    "DEGODS",
    "BLOCKSMITH_LABS"
  ],
  "UPDATE_VAULT_OWNER": [
    "GEM_BANK",
    "DEGODS",
    "BLOCKSMITH_LABS"
  ],
  "DEPOSIT_GEM": [
    "GEM_BANK",
    "GEM_FARM",
    "DEGODS",
    "BLOCKSMITH_LABS"
  ],
  "WITHDRAW_GEM": [
    "GEM_BANK",
    "DEGODS",
    "BLOCKSMITH_LABS"
  ],
  "ADD_TO_WHITELIST": [
    "GEM_BANK",
    "GEM_FARM",
    "DEGODS",
    "BLOCKSMITH_LABS"
  ],
  "REMOVE_FROM_WHITELIST": [
    "GEM_BANK",
    "GEM_FARM",
    "DEGODS",
    "BLOCKSMITH_LABS"
  ],
  "UPDATE_BANK_MANAGER": [
    "GEM_BANK",
    "DEGODS",
    "BLOCKSMITH_LABS"
  ],
  "RECORD_RARITY_POINTS": [
    "GEM_BANK",
    "DEGODS",
    "BLOCKSMITH_LABS"
  ],
  "INIT_FARM": [
    "GEM_FARM",
    "DEGODS",
    "BLOCKSMITH_LABS"
  ],
  "UPDATE_FARM": [
    "GEM_FARM",
    "DEGODS",
    "BLOCKSMITH_LABS"
  ],
  "PAYOUT": [
    "GEM_FARM",
    "DEGODS",
    "BLOCKSMITH_LABS"
  ],
  "STAKE_TOKEN": [
    "GEM_FARM",
    "DEGODS",
    "BLOCKSMITH_LABS",
    "FOXY_STAKING",
    "CARDINAL_STAKING"
  ],
  "UNSTAKE_TOKEN": [
    "GEM_FARM",
    "DEGODS",
    "BLOCKSMITH_LABS",
    "FOXY_STAKING",
    "CARDINAL_STAKING"
  ],
  "CLAIM_REWARDS": [
    "GEM_FARM",
    "DEGODS",
    "BLOCKSMITH_LABS"
  ],
  "INIT_FARMER": [
    "GEM_FARM",
    "DEGODS",
    "BLOCKSMITH_LABS"
  ],
  "REFRESH_FARMER": [
    "GEM_FARM",
    "DEGODS",
    "BLOCKSMITH_LABS"
  ],
  "AUTHORIZE_FUNDER": [
    "GEM_FARM",
    "DEGODS",
    "BLOCKSMITH_LABS"
  ],
  "DEAUTHORIZE_FUNDER": [
    "GEM_FARM",
    "DEGODS",
    "BLOCKSMITH_LABS"
  ],
  "FUND_REWARD": [
    "GEM_FARM",
    "DEGODS",
    "BLOCKSMITH_LABS"
  ],
  "CANCEL_REWARD": [
    "GEM_FARM",
    "DEGODS",
    "BLOCKSMITH_LABS"
  ],
  "LOCK_REWARD": [
    "GEM_FARM",
    "DEGODS",
    "BLOCKSMITH_LABS"
  ],
  "ADD_RARITIES_TO_BANK": [
    "GEM_FARM",
    "DEGODS",
    "BLOCKSMITH_LABS"
  ],
  "BUY_SUBSCRIPTION": [
    "YAWWW"
  ],
  "BUY": [
    "PUMP_AMM"
  ],
  "SELL": [
    "PUMP_AMM"
  ],
  "FUSE": [
    "ELIXIR"
  ],
  "SWAP": [
    "ELIXIR",
    "JUPITER",
    "FOXY",
    "ALDRIN",
    "HADESWAP",
    "RAYDIUM"
  ],
  "DEPOSIT_FRACTIONAL_POOL": [
    "ELIXIR"
  ],
  "FRACTIONALIZE": [
    "ELIXIR"
  ],
  "CREATE_APPRAISAL": [
    "ELIXIR"
  ],
  "addCollateralType": [
    "HEDGE"
  ],
  "AUCTION_HOUSE_CREATE": [
    "METAPLEX"
  ],
  "CLOSE_ESCROW_ACCOUNT": [
    "METAPLEX"
  ],
  "AUCTION_MANAGER_CLAIM_BID": [
    "METAPLEX"
  ],
  "EMPTY_PAYMENT_ACCOUNT": [
    "METAPLEX"
  ],
  "NFT_PARTICIPATION_REWARD": [
    "METAPLEX"
  ],
  "VALIDATE_SAFETY_DEPOSIT_BOX_V2": [
    "METAPLEX"
  ],
  "INIT_AUCTION_MANAGER_V2": [
    "METAPLEX"
  ],
  "SET_AUTHORITY": [
    "METAPLEX"
  ],
  "CREATE_STORE": [
    "METAPLEX"
  ],
  "WHITELIST_CREATOR": [
    "METAPLEX"
  ],
  "CREATE_RAFFLE": [
    "FOXY_RAFFLE"
  ],
  "UPDATE_RAFFLE": [
    "FOXY_RAFFLE"
  ],
  "BUY_TICKETS": [
    "FOXY_RAFFLE"
  ],
  "ADD_ITEM": [
    "FOXY_TOKEN_MARKET"
  ],
  "UPGRADE_FOX": [
    "FOXY_MISSIONS"
  ],
  "CREATE_ESCROW": [
    "FOXY_MARMALADE"
  ],
  "CREATE_BET": [
    "FOXY_COINFLIP"
  ],
  "NFT_RENT_LISTING": [
    "CARDINAL_RENT"
  ],
  "NFT_RENT_ACTIVATE": [
    "CARDINAL_RENT"
  ],
  "NFT_RENT_CANCEL_LISTING": [
    "CARDINAL_RENT"
  ],
  "NFT_RENT_UPDATE_LISTING": [
    "CARDINAL_RENT"
  ],
  "EXECUTE_TRANSACTION": [
    "SQUADS"
  ],
  "CREATE_TRANSACTION": [
    "SQUADS"
  ],
  "APPROVE_TRANSACTION": [
    "SQUADS"
  ],
  "ACTIVATE_TRANSACTION": [
    "SQUADS"
  ],
  "REJECT_TRANSACTION": [
    "SQUADS"
  ],
  "CANCEL_TRANSACTION": [
    "SQUADS"
  ],
  "ADD_INSTRUCTION": [
    "SQUADS"
  ],
  "BURN": [
    "SOLANA_PROGRAM_LIBRARY"
  ],
  "UPDATE_PRIMARY_SALE_METADATA": [
    "METAPLEX"
  ],
  "BURN_NFT": [
    "METAPLEX"
  ],
  "ADD_TOKEN_TO_VAULT": [
    "METAPLEX"
  ],
  "ACTIVATE_VAULT": [
    "METAPLEX"
  ],
  "UPDATE_EXTERNAL_PRICE_ACCOUNT": [
    "METAPLEX"
  ],
  "STAKE_SOL": [
    "STAKE_PROGRAM"
  ],
  "UNSTAKE_SOL": [
    "STAKE_PROGRAM"
  ],
  "INIT_STAKE": [
    "STAKE_PROGRAM"
  ],
  "MERGE_STAKE": [
    "STAKE_PROGRAM"
  ],
  "SPLIT_STAKE": [
    "STAKE_PROGRAM"
  ],
  "UPGRADE_PROGRAM_INSTRUCTION": [
    "BPF_UPGRADEABLE_LOADER"
  ],
  "FINALIZE_PROGRAM_INSTRUCTION": [
    "BPF_LOADER"
  ],
  "REQUEST_PNFT_MIGRATION": [
    "METAPLEX"
  ],
  "START_PNFT_MIGRATION": [
    "METAPLEX"
  ],
  "MIGRATE_TO_PNFT": [
    "METAPLEX"
  ],
  "OFFER_LOAN": [
    "SHARKY_FI",
    "CITRUS"
  ],
  "RESCIND_LOAN": [
    "SHARKY_FI"
  ],
  "REPAY_LOAN": [
    "SHARKY_FI",
    "CITRUS"
  ],
  "TAKE_LOAN": [
    "SHARKY_FI"
  ],
  "FORECLOSE_LOAN": [
    "SHARKY_FI"
  ],
  "CANCEL_OFFER": [
    "CITRUS"
  ],
  "LEND_FOR_NFT": [
    "CITRUS"
  ],
  "REQUEST_LOAN": [
    "CITRUS"
  ],
  "CANCEL_LOAN_REQUEST": [
    "CITRUS"
  ],
  "BORROW_SOL_FOR_NFT": [
    "CITRUS"
  ],
  "CLAIM_NFT": [
    "CITRUS"
  ],
  "REBORROW_SOL_FOR_NFT": [
    "CITRUS"
  ],
  "UPDATE_OFFER": [
    "CITRUS"
  ],
  "CREATE_POOL": [
    "RAYDIUM",
    "PUMP_AMM"
  ],
  "ADD_LIQUIDITY": [
    "RAYDIUM"
  ],
  "WITHDRAW_LIQUIDITY": [
    "RAYDIUM"
  ]
}
```

## Source-to-Type Reference

This mapping shows all transaction types that can be generated by each program source.

````json [expandable]
<summary>Source to Type</summary>

```json
{
  "CANDY_MACHINE_V2": [
    "NFT_MINT"
  ],
  "CANDY_MACHINE_V1": [
    "TOKEN_MINT",
    "NFT_MINT"
  ],
  "CANDY_MACHINE_V3": [
    "NFT_MINT",
    "CANDY_MACHINE_UPDATE",
    "CANDY_MACHINE_ROUTE",
    "CANDY_MACHINE_WRAP",
    "CANDY_MACHINE_UNWRAP"
  ],
  "FORM_FUNCTION": [
    "NFT_BID",
    "NFT_SALE",
    "NFT_LISTING",
    "NFT_MINT"
  ],
  "EXCHANGE_ART": [
    "NFT_LISTING",
    "NFT_BID",
    "NFT_SALE",
    "NFT_CANCEL_LISTING",
    "NFT_BID_CANCELLED"
  ],
  "SOLANART": [
    "NFT_BID",
    "NFT_BID_CANCELLED",
    "NFT_SALE",
    "NFT_LISTING",
    "NFT_CANCEL_LISTING",
    "NFT_GLOBAL_BID",
    "NFT_GLOBAL_BID_CANCELLED"
  ],
  "MAGIC_EDEN": [
    "NFT_LISTING",
    "NFT_CANCEL_LISTING",
    "NFT_BID",
    "NFT_BID_CANCELLED",
    "NFT_SALE",
    "WITHDRAW",
    "DEPOSIT",
    "NFT_MINT",
    "NFT_GLOBAL_BID",
    "NFT_GLOBAL_BID_CANCELLED"
  ],
  "ENGLISH_AUCTION": [
    "NFT_AUCTION_CREATED",
    "NFT_AUCTION_UPDATED",
    "NFT_BID",
    "NFT_AUCTION_CANCELLED",
    "NFT_SALE"
  ],
  "PHANTOM": [
    "TRANSFER"
  ],
  "SOLSEA": [
    "NFT_SALE",
    "NFT_LISTING",
    "NFT_CANCEL_LISTING"
  ],
  "LAUNCH_MY_NFT": [
    "NFT_MINT"
  ],
  "GEM_BANK": [
    "INIT_BANK",
    "SET_BANK_FLAGS",
    "INIT_VAULT",
    "SET_VAULT_LOCK",
    "UPDATE_VAULT_OWNER",
    "DEPOSIT_GEM",
    "WITHDRAW_GEM",
    "ADD_TO_WHITELIST",
    "REMOVE_FROM_WHITELIST",
    "UPDATE_BANK_MANAGER",
    "RECORD_RARITY_POINTS"
  ],
  "GEM_FARM": [
    "INIT_FARM",
    "UPDATE_FARM",
    "PAYOUT",
    "ADD_TO_WHITELIST",
    "REMOVE_FROM_WHITELIST",
    "STAKE_TOKEN",
    "UNSTAKE_TOKEN",
    "CLAIM_REWARDS",
    "INIT_FARMER",
    "DEPOSIT_GEM",
    "REFRESH_FARMER",
    "AUTHORIZE_FUNDER",
    "DEAUTHORIZE_FUNDER",
    "FUND_REWARD",
    "CANCEL_REWARD",
    "LOCK_REWARD",
    "ADD_RARITIES_TO_BANK"
  ],
  "DEGODS": [
    "INIT_BANK",
    "SET_BANK_FLAGS",
    "INIT_VAULT",
    "SET_VAULT_LOCK",
    "UPDATE_VAULT_OWNER",
    "DEPOSIT_GEM",
    "WITHDRAW_GEM",
    "ADD_TO_WHITELIST",
    "REMOVE_FROM_WHITELIST",
    "UPDATE_BANK_MANAGER",
    "RECORD_RARITY_POINTS",
    "INIT_FARM",
    "UPDATE_FARM",
    "PAYOUT",
    "STAKE_TOKEN",
    "UNSTAKE_TOKEN",
    "CLAIM_REWARDS",
    "INIT_FARMER",
    "REFRESH_FARMER",
    "AUTHORIZE_FUNDER",
    "DEAUTHORIZE_FUNDER",
    "FUND_REWARD",
    "CANCEL_REWARD",
    "LOCK_REWARD",
    "ADD_RARITIES_TO_BANK"
  ],
  "BLOCKSMITH_LABS": [
    "INIT_BANK",
    "SET_BANK_FLAGS",
    "INIT_VAULT",
    "SET_VAULT_LOCK",
    "UPDATE_VAULT_OWNER",
    "DEPOSIT_GEM",
    "WITHDRAW_GEM",
    "ADD_TO_WHITELIST",
    "REMOVE_FROM_WHITELIST",
    "UPDATE_BANK_MANAGER",
    "RECORD_RARITY_POINTS",
    "INIT_FARM",
    "UPDATE_FARM",
    "PAYOUT",
    "STAKE_TOKEN",
    "UNSTAKE_TOKEN",
    "CLAIM_REWARDS",
    "INIT_FARMER",
    "REFRESH_FARMER",
    "AUTHORIZE_FUNDER",
    "DEAUTHORIZE_FUNDER",
    "FUND_REWARD",
    "CANCEL_REWARD",
    "LOCK_REWARD",
    "ADD_RARITIES_TO_BANK"
  ],
  "YAWWW": [
    "NFT_SALE",
    "NFT_LISTING",
    "NFT_CANCEL_LISTING",
    "NFT_BID",
    "NFT_BID_CANCELLED",
    "BUY_SUBSCRIPTION"
  ],
  "DIGITAL_EYES": [
    "NFT_SALE"
  ],
  "HYPERSPACE": [
    "NFT_BID",
    "NFT_BID_CANCELLED",
    "NFT_LISTING",
    "NFT_CANCEL_LISTING",
    "NFT_SALE"
  ],
  "TENSOR": [
    "NFT_LISTING",
    "NFT_SALE",
    "NFT_CANCEL_LISTING"
  ],
  "ELIXIR": [
    "FUSE",
    "SWAP",
    "DEPOSIT_FRACTIONAL_POOL",
    "FRACTIONALIZE",
    "CREATE_APPRAISAL"
  ],
  "BIFROST": [
    "NFT_MINT",
    "WITHDRAW"
  ],
  "HEDGE": [
    "addCollateralType"
  ],
  "ATADIA": [
    "TOKEN_MINT",
    "NFT_MINT"
  ],
  "JUPITER": [
    "SWAP"
  ],
  "METAPLEX": [
    "NFT_SALE",
    "NFT_LISTING",
    "NFT_BID",
    "AUCTION_HOUSE_CREATE",
    "CLOSE_ESCROW_ACCOUNT",
    "AUCTION_MANAGER_CLAIM_BID",
    "EMPTY_PAYMENT_ACCOUNT",
    "NFT_PARTICIPATION_REWARD",
    "VALIDATE_SAFETY_DEPOSIT_BOX_V2",
    "INIT_AUCTION_MANAGER_V2",
    "NFT_AUCTION_CREATED",
    "NFT_BID_CANCELLED",
    "SET_AUTHORITY",
    "CREATE_STORE",
    "WHITELIST_CREATOR",
    "UPDATE_PRIMARY_SALE_METADATA",
    "NFT_MINT",
    "BURN_NFT",
    "INIT_VAULT",
    "ADD_TOKEN_TO_VAULT",
    "ACTIVATE_VAULT",
    "UPDATE_EXTERNAL_PRICE_ACCOUNT",
    "REQUEST_PNFT_MIGRATION",
    "START_PNFT_MIGRATION",
    "MIGRATE_TO_PNFT"
  ],
  "FOXY": [
    "SWAP"
  ],
  "FOXY_STAKING": [
    "STAKE_TOKEN",
    "UNSTAKE_TOKEN"
  ],
  "FOXY_RAFFLE": [
    "CREATE_RAFFLE",
    "BUY_TICKETS",
    "UPDATE_RAFFLE"
  ],
  "FOXY_TOKEN_MARKET": [
    "ADD_ITEM"
  ],
  "FOXY_MISSIONS": [
    "UPGRADE_FOX"
  ],
  "FOXY_MARMALADE": [
    "CREATE_ESCROW"
  ],
  "FOXY_COINFLIP": [
    "CREATE_BET"
  ],
  "FOXY_AUCTION": [
    "NFT_BID",
    "NFT_AUCTION_CANCELLED",
    "NFT_AUCTION_CREATED",
    "NFT_SALE"
  ],
  "ALDRIN": [
    "SWAP"
  ],
  "HADESWAP": [
    "SWAP"
  ],
  "CARDINAL_RENT": [
    "NFT_RENT_LISTING",
    "NFT_RENT_ACTIVATE",
    "NFT_RENT_CANCEL_LISTING",
    "NFT_RENT_UPDATE_LISTING"
  ],
  "CARDINAL_STAKING": [
    "STAKE_TOKEN",
    "UNSTAKE_TOKEN"
  ],
  "SQUADS": [
    "EXECUTE_TRANSACTION",
    "CREATE_TRANSACTION",
    "APPROVE_TRANSACTION",
    "ACTIVATE_TRANSACTION",
    "REJECT_TRANSACTION",
    "CANCEL_TRANSACTION",
    "ADD_INSTRUCTION"
  ],
  "ELIXIR_LAUNCHPAD": [
    "NFT_MINT"
  ],
  "SHARKY_FI": [
    "OFFER_LOAN",
    "RESCIND_LOAN",
    "REPAY_LOAN",
    "TAKE_LOAN",
    "FORECLOSE_LOAN"
  ],
  "CITRUS": [
    "CANCEL_OFFER",
    "LEND_FOR_NFT",
    "REQUEST_LOAN",
    "CANCEL_LOAN_REQUEST",
    "BORROW_SOL_FOR_NFT",
    "REPAY_LOAN",
    "CLAIM_NFT",
    "REBORROW_SOL_FOR_NFT",
    "OFFER_LOAN",
    "UPDATE_OFFER"
  ],
  "SOLANA_PROGRAM_LIBRARY": [
    "BURN",
    "TOKEN_MINT",
    "NFT_MINT",
    "TRANSFER"
  ],
  "SYSTEM_PROGRAM": [
    "TRANSFER"
  ],
  "STAKE_PROGRAM": [
    "STAKE_SOL",
    "UNSTAKE_SOL",
    "INIT_STAKE",
    "MERGE_STAKE",
    "SPLIT_STAKE",
    "WITHDRAW"
  ],
  "BPF_UPGRADEABLE_LOADER": [
    "UPGRADE_PROGRAM_INSTRUCTION"
  ],
  "BPF_LOADER": [
    "FINALIZE_PROGRAM_INSTRUCTION"
  ],
  "RAYDIUM": [
    "WITHDRAW_LIQUIDITY",
    "ADD_LIQUIDITY",
    "CREATE_POOL",
    "SWAP"
  ],
  "PUMP_AMM": [
    "CREATE_POOL",
    "DEPOSIT",
    "WITHDRAW",
    "BUY",
    "SELL"
  ]
}
````

## Using Transaction Types in Your Code

When implementing webhook listeners, you can filter for specific transaction types of interest.

Here's a simple example of how to listen for NFT sale events:

```javascript
// Example webhook handler for NFT sales
app.post('/webhook', (req, res) => {
  const event = req.body;
  
  // Filter for NFT sale transactions
  if (event.type === 'NFT_SALE') {
    console.log('NFT Sale detected!');
    console.log('Seller:', event.seller);
    console.log('Buyer:', event.buyer);
    console.log('Price:', event.amount);
    console.log('NFT:', event.nft?.mint);
    
    // Process the sale event
    // ...
  }
  
  res.status(200).send('OK');
});
```

You can use the Type-to-Source and Source-to-Type mappings to anticipate which programs will generate specific transaction types.


# What is ZK Compression on Solana?
Source: https://www.helius.dev/docs/zk-compression/introduction

ZK Compression dramatically reduces Solana data storage costs by 95%+. Store compressed accounts, NFTs, and arbitrary data at a fraction of the cost.

[ZK Compression](https://www.zkcompression.com/) is a generalized compression framework that allows developers to store data on Solana at a fraction of the cost. After helping develop cNFT compression, Helius saw the need to build a generalized system. So, along with the [Light team](https://lightprotocol.com/), we built ZK Compression to allow developers to store arbitrary data in *compressed accounts*, akin to native Solana accounts.

## Photon: the ZK Compression Indexer

Helius built [Photon](https://github.com/helius-labs/photon), the ZK Compression indexer. In ZK Compression, programs log compressed account data in Solana transactions and store the fingerprint of that data in validator memory. Photon indexes Solana transactions to parse and store compressed account data. It then exposes an API similar to Solana's native API to help users access compression data. Though developers can directly host Photon, we expose a Photon API to streamline the developer experience.

<Note>
  Please visit the official [ZK Compression docs](https://www.zkcompression.com/) to learn more about ZK Compression and Photon.
</Note>



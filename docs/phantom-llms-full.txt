# Display apps within the Activity tab
Source: https://docs.phantom.com/best-practices/displaying-apps-within-the-activity-tab



When a user views their historical activity, Phantom will parse their dapp interactions and enrich them with known metadata. The following are two examples of how Phantom displays historical transactions on [Magic Eden](https://magiceden.io/) and [Jupiter](https://jup.ag/), respectively:

![An example activity row for Magic Eden](https://mintlify.s3.us-west-1.amazonaws.com/phantom-e50e2e68/best-practices/images/me-activity.png)

![An example activity row for Jupiter](https://mintlify.s3.us-west-1.amazonaws.com/phantom-e50e2e68/best-practices/images/jupiter-activity.png)

To display your app within the Activity tab, fill out this [form](https://docs.google.com/forms/d/e/1FAIpQLSeHWETFkEJbHQCF-lnl1AHmVQPuyfC0HbnxjDjIp6VYV1sBZQ/viewform) with the following information:

* URL of the website
* Display name of the dapp
* Program/Contract IDs
* Interaction names (corresponding to program IDs)


# Display apps within dialogs
Source: https://docs.phantom.com/best-practices/displaying-your-app



![An example app displayed within a dialog](https://mintlify.s3.us-west-1.amazonaws.com/phantom-e50e2e68/best-practices/images/displayingappswithindialogs.jpeg)

When an app is [establishing a connection](../solana/establishing-a-connection) or [sending a transaction](../solana/sending-a-transaction), Phantom will present the user with the above dialogs. In order to display the title and icon for these dialogs, Phantom will inspect the application's HTML for the following items:

| Value | Primary lookup                                                         | Secondary lookup                                                                          | Fallback       |
| ----- | ---------------------------------------------------------------------- | ----------------------------------------------------------------------------------------- | -------------- |
| Title | [Open Graph title](https://ogp.me/)                                    | [Document Title Element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/title) | None           |
| Icon  | [Apple touch icon](https://www.computerhope.com/jargon/a/appletou.htm) | [Favicon](https://developer.mozilla.org/en-US/docs/Glossary/Favicon)                      | A default icon |


# Launch an app
Source: https://docs.phantom.com/best-practices/launching-a-dapp



* Ensure your domain is clear of any warnings. For more information, see [Domain and transaction warnings](../developer-powertools/domain-and-transaction-warnings).
* Contact Phantom Developer Support using this [form](https://docs.google.com/forms/d/e/1FAIpQLSeHWETFkEJbHQCF-lnl1AHmVQPuyfC0HbnxjDjIp6VYV1sBZQ/viewform) to create a Phantom Portal Account.


# Display tokens on Solana
Source: https://docs.phantom.com/best-practices/tokens/README



If you've created a token on Solana using the [SPL Token Program](https://spl.solana.com/token) or [Token-2022 Program ("Token Extensions")](https://spl.solana.com/token-2022), then your token is compatible with Phantom. If Phantom users own a certain balance of a token made with these programs, that balance will always appear in their wallet. However, if Phantom cannot find more metadata about that token, it will display the token as "Unknown."

## Search for metadata

When searching for metadata, Phantom will first look to the [Token Metadata Program](https://developers.metaplex.com/token-metadata) established by [Metaplex](https://www.metaplex.com/). This program enhances ordinary SPL token [mints](https://docs.solana.com/integrations/exchange#token-mints) with a Metadata Account that describes additional fields such as the token's `symbol`, `image`, and `description`. Some of these fields exist on-chain in the Metadata Account itself, while others exist off-chain in a JSON file that follows a [standard format](https://developers.metaplex.com/token-metadata/token-standard). The link to this off-chain JSON file is found at the Metadata Account's `uri` field.

If a Metadata Account is found, Phantom will prioritize on-chain fields (such as `name`, `symbol`) before off-chain fields described in the `uri` JSON file.

## Categorize tokens

Phantom will categorize and display tokens based on their [Token Standard](https://developers.metaplex.com/token-metadata/token-standard). The `tokenStandard` field can be found in the token's on-chain Metadata Account and is used to describe a token's fungibility. The `tokenStandard` field has four options:

* `Fungible`: A token with simple metadata that can be freely mixed with others of the same mint. Common examples include [USDC](https://www.circle.com/en/usdc) and [SRM](https://www.projectserum.com/).
* `FungibleAsset`: A token with metadata that can also have NFT-like attributes. Commonly referred to as Semi-Fungible, these tokens are often used in gaming contexts to support stackable items like a piece of wood.
* `NonFungible`: A non-fungible token with a [Master Edition](https://docs.metaplex.com/programs/token-metadata/accounts#master-edition) account. This is the most popular type of NFT, encompassing well known collections like [Solana Monkey Business](https://solanamonkey.business/) and [DeGods](https://www.degods.com/).
* `NonFungibleEdition`: A non-fungible token with an [Edition](https://developers.metaplex.com/token-metadata/token-standard#the-token-standard-field) account (printed from a Master Edition). This is a helpful feature for creators who want to offer multiple copies of their 1/1 NFTs.
* `ProgrammableNonFungible`: A new non-fungible asset class that allows for flexible configuration of various lifecycle rules triggered by specific actions. For more information about Programmable NFTs or pNFTs, visit [Programmable NFTs](https://developers.metaplex.com/token-metadata/pnfts).

If no `tokenStandard` is set, Phantom will fallback to categorizing tokens based on the following logic:

1. If the total mint supply is 1, Phantom will consider the token to be `NonFungible`.
2. If the total mint supply is greater than 1 and the mint has 0 decimals, Phantom will consider the token to be a `FungibleAsset`.
3. Phantom will consider all other tokens to be `Fungible`.

## Display tokens

Phantom will display all `Fungible` tokens in the **Home** tab. For more details on `Fungible` token best practices, refer to our [Fungibles](/best-practices/tokens/home-tab-fungibles) documentation.

All other token standards (`FungibleAsset`, `NonFungible`, and `NonFungibleEdition`) will be displayed in the **Collectibles** tab. For more information on collectible best practices, see [Collectibles](/best-practices/tokens/collectibles-nfts-and-semi-fungibles).


# NFTs and semi-fungibles
Source: https://docs.phantom.com/best-practices/tokens/collectibles-nfts-and-semi-fungibles



On Solana, NFTs are often thought of as [SPL Tokens](https://spl.solana.com/token#example-create-a-non-fungible-token) with 0 decimals and a supply of 1. According to the [Token Metadata Standard](https://developers.metaplex.com/token-metadata/token-standard), however, it is possible for a range of different tokens to have NFT-like characteristics. Phantom refers to all NFT-like tokens as **collectibles** and will display them separately from `Fungible` tokens that appear on the **Home** tab. Specifically, Phantom will display all `FungibleAsset`, `NonFungible`, `NonFungibleEdition` and `ProgrammableNonFungible` tokens on their own **Collectibles** tab.

## Group collectibles

Phantom groups collectibles by their [Certified Collections](https://developers.metaplex.com/token-metadata/collections) introduced in [v1.1.0 of the Token Metadata Standard](https://developers.metaplex.com/token-metadata/token-standard). In order to be grouped together, individual NFTs should all reference the same verified collection mint address. This mint address is itself home to an NFT with metadata that describes the collection as in the [example](https://solscan.io/token/SMBH3wF6baUj6JWtzYvqcKuj2XCKWDqQxzspY12xPND#metadata). Creators must ensure that this collection is [verified on-chain](https://developers.metaplex.com/token-metadata/collections) (that is, that `verified` is set to `true`).

If no verified collection is found, Phantom will fallback to grouping NFTs by the first verified creator's address in the on-chain `creators` field. If two unverified items share the same creator address at the 0 index of their `creators` array, they will be grouped into the same collection.

## Name grouped collectibles

When a group is created, a best-effort process is used to determine that group’s name. Phantom will look to these fields in the following order of preference:

1. `name` of the verified on-chain collection NFT
2. `collection.name`
3. `collection.family`
4. `external_url` (parsed to remove url parts)
5. `name` (of a single collectible)
6. `symbol`
7. address of the first verified creator in the `creators` array (also used to group the collection)

## Display an individual collectible

When displaying the detail view of an individual collectible, Phantom will prioritize on-chain data in the Metadata Account over off-chain JSON linked via the `uri` field. This impacts both the `name` and `symbol` field which appears in both locations.

## Render collectible media

### **Supported media types**

Phantom supports a wide-range of media types. For a full list, refer to [Supported media types](/best-practices/tokens/supported-media-types).

### **Select media**

When determining what media to display for a given collectible, Phantom will search the off-chain JSON for data in the following order:

1. `animation_url`: Phantom will select the media source at the collectible's `animation_url` field.
2. `properties.files`: If no `animation_url` is found, Phantom will choose the first file where the `cdn` property is set to `true`. Otherwise, a file will be chosen based on the media type in the following order of preference:
   1. `image`
   2. `audio`
   3. `video`
   4. `vr` or `model`
3. `image`: Finally, if Phantom still cannot find media to display, it will fallback to the media source at the collectible's `image` field.

### **Determine media type**

If a media source is found in `properties.files`, and that source is defined as an object, Phantom will determine the media type based on that file's `type` property. Under the Token Metadata Standard, file objects are defined with the following structure:

| Field | Type               | Description                                                                                                                                                                                                                                                                                    |
| ----- | ------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| type  | string             | The media type of the file. If selected, Phantom will use this to determine the media type. For example, "image/png."                                                                                                                                                                          |
| uri   | string             | The URI source of the file. For example, [https://asfh3uxyeoyvtkfqc7jagy3mhtsszhyubnc3wfss5ismdgtw.arweave.net/BIp90vgjs\_VmosBfSA2NsPOUsnxQLRbsWUuo-kwZp2o?ext=png](https://asfh3uxyeoyvtkfqc7jagy3mhtsszhyubnc3wfss5ismdgtw.arweave.net/BIp90vgjs_VmosBfSA2NsPOUsnxQLRbsWUuo-kwZp2o?ext=png) |
| cdn   | boolean (optional) | An optional flag that dictates if the file is hosted on a cdn. If `true`, Phantom will select this file as the primary source file.                                                                                                                                                            |

In cases where Phantom cannot find a source from `properties.files`, it may fallback to a media source that is defined as a `string` (such as `animation_url` or `image`). In these cases, Phantom will look for data in the following order of preference:

1. The media source URI's `?ext=` query string parameter (`https://example.com/foo?ext=png`).
2. The media source URI's pathname extension (`https://example.com/foo.png`).
3. If the media source URI comes from the `animation_url`, Phantom will infer the media type based on the collectible's `properties.category` field.
4. If the media source URI comes from the `image` field, Phantom will default to assume it is a PNG.

If no supported media type can be determined, no media will be selected, and users may see a placeholder image instead.

### **Resize images**

Phantom will resize all collectible images to 256x256 pixels. For best results, we recommend images with a square aspect ratio and a power-of-2 dimension (for example, 256x256, 512x512, or 1024x1024).


# Fungibles
Source: https://docs.phantom.com/best-practices/tokens/home-tab-fungibles



## Display fungible tokens

Phantom prioritizes on-chain metadata that follows the [Token Metadata Standard](https://developers.metaplex.com/token-metadata/token-standard). For [fungible tokens](https://developers.metaplex.com/token-metadata/token-standard#the-fungible-standard) specifically, Phantom will show the following fields:

| Field  | Description                                |
| ------ | ------------------------------------------ |
| name   | The name of the token, such as “USD Coin.” |
| symbol | The symbol of the token, such as ”USDC.”   |
| image  | A URI pointing to the token's logo.        |

If a `Fungible` token has `name` and `symbol` fields present on both its on-chain Metadata Account and off-chain JSON file (linked via the on-chain `uri` field), Phantom will prioritize the on-chain fields.

If a `Fungible` token does not have an on-chain Metadata Account, Phantom will fallback to displaying data from the [Solana Labs Token List](https://github.com/solana-labs/token-list). This list is considered deprecated and should not be used to host new tokens. When reading from the token list, Phantom will display the following fields:

| Field                  | Description                                                                                      |
| ---------------------- | ------------------------------------------------------------------------------------------------ |
| name                   | The name of the token, such as “USD Coin.”                                                       |
| symbol                 | The symbol of the token, such as ”USDC.”                                                         |
| logoURI                | A URI pointing to the token's logo.                                                              |
| extensions.coingeckoID | The token ID as defined by the Coingecko API. Phantom uses this to fetch the price of the token. |

## Display prices

Phantom will display prices for any token that is verified on [Coingecko](https://www.coingecko.com/). When verifying with Coingecko, be sure to include the token's `contract`. For Solana tokens, this should be the mint address. For example, [Bonk](https://www.coingecko.com/en/coins/bonk) is verified with the contract [DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263](https://solscan.io/token/DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263). Once a token has verified its `contract` address with Coingecko, Phantom will automatically begin displaying its price.

If Coingecko is unable to return a price for a given token, Phantom will fallback to using [Birdeye](https://birdeye.so/) for token prices.


# Supported media types
Source: https://docs.phantom.com/best-practices/tokens/supported-media-types

Phantom supports a range of token media types, including images, audio files, video files, and 3D models.

Phantom supports a range of token media types, including images, audio files, video files, and 3D models. At this time, Phantom doesn't support HTML files. The following list includes all file types supported by Phantom:

| Media     | Format                         |
| --------- | ------------------------------ |
| Images    | JPEG, JPG, PNG, GIF, SVG, WEBP |
| Video     | MP4, MOV, WEBM, M4V, OGV, OGG  |
| Audio     | MP3, WAV, OGA, FLAC            |
| 3D models | GLB, GLTF, GLTF-BINARY         |


# Detect the provider
Source: https://docs.phantom.com/bitcoin/detecting-the-provider

To detect if a user has already installed Phantom, a web application should check for the existence of a phantom object.

Phantom's browser extension and mobile in-app browser will both inject a `phantom` object into the [window](https://developer.mozilla.org/en-US/docs/Web/API/Window) of any web application the user visits, provided that site is using `https://`, on `localhost`, or is `127.0.0.1.` Phantom will not inject the provider into [iframes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe) or sites using `http://`.

If a `phantom` object exists, Bitcoin and Ordinals dapps can interact with Phantom via the API found at `window.phantom.bitcoin`. To detect if Phantom is installed, an application should check for an additional `isPhantom` flag like so:

```typescript
const isPhantomInstalled = window?.phantom?.bitcoin?.isPhantom
```

If Phantom is not installed, we recommend you redirect your users to our website `https://phantom.com/`. Altogether, this may look like the following:

```typescript
const getProvider = () => {
  if ('phantom' in window) {
    const anyWindow: any = window;
    const provider = anyWindow.phantom?.bitcoin;
   
    if (provider && provider.isPhantom) {
      return provider;
    }
  }

  window.open('https://phantom.com/', '_blank');
};
```

When adding a Phantom button to your dapp’s wallet modal, we recommend using the name “Phantom” with an SVG/PNG icon, which you can find in [Logos and assets](/resources/assets).

![An example Phantom button in a wallet modal](https://mintlify.s3.us-west-1.amazonaws.com/phantom-e50e2e68/bitcoin/images/phantom-modal-button.png)


# Establish a connection
Source: https://docs.phantom.com/bitcoin/establishing-a-connection



## Connect

Once an application has [detected the provider](/bitcoin/detecting-the-provider), it can then request to connect to Phantom by invoking the `requestAccounts` method. This connection request will prompt the user for permission to share their Bitcoin addresses, indicating that they are willing to interact further. Users must approve a connection request before the app can make additional requests such as [signing a message](/bitcoin/signing-a-message) or [sending a transaction](/bitcoin/sending-a-transaction).

![Phantom popup triggered when user connects to an app for the first time](https://mintlify.s3.us-west-1.amazonaws.com/phantom-e50e2e68/bitcoin/images/establishing-a-connection.webp)

The `requestAccounts` method returns a [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) that resolves if the user approves the connection request. Once resolved, it contains an array of the user's `BtcAccount` objects. If the user declines the request or closes the pop-up, it will reject (throw when awaited).

The array of `BtcAccount` objects represent the possible addresses that can be used when a user connects with Phantom. This is defined as:

```typescript
type BtcAccount = {
  address: string;
  addressType: "p2tr" | "p2wpkh" | "p2sh" | "p2pkh";
  publicKey: string;
  purpose: "payment" | "ordinals";
};
```

Where:

* `address`: The Bitcoin address owned by the user.
* `addressType`: The address's format. For details, see [Bitcoin Design Glossary](https://bitcoin.design/guide/glossary/address/).
* `publicKey`: A hex string representing the bytes of the public key of the account.
* `purpose`: The general purpose of the address. If `ordinals`, the user prefers to store Ordinals on this address. If `payment`, the user prefers to store bitcoin on this address.

<Warning>
  The purpose fields represent user preferences and do not represent a guarantee that there will only be Bitcoin on `payment` addresses or only Ordinals on `ordinals` addresses. When submitting a transaction, make sure to carefully select UTXOs such that you do not cause the user to accidentally spend a rare or inscribed satoshi.
</Warning>

The following is an example of how to connect to Phantom:

```typescript

const phantomProvider = getProvider(); // see "Detecting the Provider"
const accounts = await phantomProvider.requestAccounts();
console.log(accounts);
/**
[
    {
        "address": "bc1phajtersv55fwud5xr0t70p5234swy396a6avqhuny0qf83zssvrsm7tl4q",
        "publicKey": "02435c68c1f20522946e46bcc39f8a19088095939db840e874e1ad2c18f0f2361c"
        "addressType": "p2tr"
        "purpose": "ordinals"
    },
    {
        "address": "bc1qqy4emmf7q623vlf2z4j3pvgfyjkaffx2u3fkpk",
        "publicKey": "0279f5b4123030accae6c4ca9a17263753a21df2142bbf0ced940d28ca613e87f9"
        "addressType": "p2wpkh"
        "purpose": "payment"
    }
]
**/
```

## Disconnect

There is no way for dapps to programmatically disconnect a user. Once a user has established a connection, Phantom will add the website they opened a connection with to a list of **Connected Apps**. When a user returns to one of these whitelisted sites, Phantom will attempt to reconnect the application automatically. At any time, the user can revoke access to the dapp through their UI by navigating to **Settings** > **Connected Apps**. If a user disconnects from a dapp, they will need to reconnect on the subsequent visit before signing a message or sending a transaction.

![Disconnecting a dApp in Connected Apps settings in Phantom extension](https://mintlify.s3.us-west-1.amazonaws.com/phantom-e50e2e68/bitcoin/images/disconnect.png)

## Change accounts

Phantom allows users to manage multiple accounts from within a single extension or mobile app. Whenever a user switches accounts, Phantom will emit an `accountsChanged` event.

```typescript
phantomProvider.on('accountsChanged', (accounts: BtcAccount[]) => {
  console.log('Accounts changed:', accounts);
});
```

If Phantom passes an empty array on `accountsChanged`, it implies that the user has switched to an account that has not connected to the dapp before (that is, not already in **Connected Apps**) or does not support Bitcoin (for example, a Solana private key account). In this case, the application can either do nothing or attempt to reconnect:

```typescript
phantomProvider.on('accountsChanged', (accounts: BtcAccount[]) => {
    if (accounts.length > 0) {
      // Set new address and continue as usual
    } else {
      // Attempt to reconnect to Phantom
      phantomProvider.requestAccounts().catch((error) => {
      // handle connection failure
      });
    }
});
```


# Get started with Bitcoin
Source: https://docs.phantom.com/bitcoin/integrating-phantom



The Phantom browser extension and mobile in-app browser both support interacting with Bitcoin and Ordinals dapps.

There are two main ways to integrate Phantom into your web application:

## Direct integration

The most direct way to interact with Phantom is via the provider that Phantom injects into your web application. This provider is globally available at `window.phantom` and its methods will always include Phantom's most up-to-date functionality. This documentation is dedicated to covering all aspects of the provider.

When adding a Phantom button to your dapp's wallet modal, we recommend using the name "Phantom" with an SVG/PNG icon, which you can find in [Logos and assets](/resources/assets).

![An example Phantom button in a wallet modal](https://mintlify.s3.us-west-1.amazonaws.com/phantom-e50e2e68/bitcoin/images/phantom-modal-button.png)

## Wallet Standard

Applications can also integrate Phantom by adding support for [Wallet Standard](https://github.com/wallet-standard/wallet-standard). You can find the Bitcoin-specific extensions for Wallet Standard on [GitHub](https://github.com/ExodusMovement/bitcoin-wallet-standard?tab=readme-ov-file).


# Provider API reference
Source: https://docs.phantom.com/bitcoin/provider-api-reference



## Methods

### requestAccounts

#### Description

Connects to the user's Phantom account.

#### Parameters

None

#### Response

<ResponseField name="Promise<BtcAccount[]>" type="array">
  Array of the connected user's `BtcAccount` objects.
</ResponseField>

#### BtcAccount response object properties

<ResponseField name="address" type="string">
  The Bitcoin address owned by the user.
</ResponseField>

<ResponseField name="addressType" type="p2tr, p2wpkh, p2sh, p2pkh">
  The address's format. For details, see [Bitcoin Design Glossary](https://bitcoin.design/guide/glossary/address/).
</ResponseField>

<ResponseField name="publicKey" type="string">
  A hex string representing the bytes of the public key of the account.
</ResponseField>

<ResponseField name="purpose" type="payment, ordinals">
  The general purpose of the address. If `ordinals`, the user prefers to store Ordinals on this address. If `payment`, the user prefers to store Bitcoin on this address.
</ResponseField>

### signMessage

#### Description

Signs a message with the user's Phantom account.

#### Parameters

<ParamField path="message" type="Uint8array">
  The message to be signed.
</ParamField>

<ParamField path="address" type="string">
  One of the user's addresses that should be used to sign the message.
</ParamField>

#### Response

<ResponseField name="Promise<{ signature: Uint8Array; }>" type="object">
  Object containing the signature.
</ResponseField>

### signPSBT

#### Description

Signs a Partially-Signed Bitcoin Transaction (PSBT).

#### Parameters

<ParamField path="psbtHex" type="Uint8Array">
  A serialized PSBT.
</ParamField>

<ParamField path="options" type="object">
  Configuration options for signing the PSBT.
</ParamField>

#### options parameters

An array containing the indexes of which transaction inputs to sign, and how to sign them.

#### Response

<ResponseField name="Promise<string>" type="string">
  A serialized PSBT where the inputs belonging to the user's account have been signed.
</ResponseField>

## Events

### accountsChanged

#### Description

The event that is emitted when a user changes their connected Phantom account.

```typescript
type AccountsChangedEvent = (accounts: BtcAccount[]) => void;
```

#### Properties

<ResponseField name="accounts" type="BtcAccount[]">
  The array of `BtcAccount` objects of the newly connect Phantom account.
</ResponseField>

#### BtcAccount response object properties

<ResponseField name="address" type="string">
  The Bitcoin address owned by the user.
</ResponseField>

<ResponseField name="addressType" type="p2tr, p2wpkh, p2sh, p2pkh">
  The address's format. For details, see [Bitcoin Design Glossary](https://bitcoin.design/guide/glossary/address/).
</ResponseField>

<ResponseField name="publicKey" type="string">
  A hex string representing the bytes of the public key of the account.
</ResponseField>

<ResponseField name="purpose" type="payment, ordinals">
  The general purpose of the address. If `ordinals`, the user prefers to store Ordinals on this address. If `payment`, the user prefers to store Bitcoin on this address.
</ResponseField>


# Send a transaction
Source: https://docs.phantom.com/bitcoin/sending-a-transaction



Phantom supports signing transactions using the [Partially Signed Bitcoin Transaction (PSBT)](https://github.com/bitcoin/bips/blob/master/bip-0174.mediawiki) format. The `signPSBT` method takes in a serialized PSBT, and returns a serialized PSBT where the user’s inputs have been signed.

```typescript
// function signature
signPSBT(
    psbt: Uint8Array,
    options: {inputsToSign: {sigHash?: number | undefined, address: string, signingIndexes: number[]}[]}
): Promise<Uint8Array>;
```

We recommend using [bitcoinjs-lib](https://github.com/bitcoinjs/bitcoinjs-lib) for constructing and serializing PSBTs.

```typescript
const fromHexString = (hexString) =>
  Uint8Array.from(hexString.match(/.{1,2}/g).map((byte) => parseInt(byte, 16)));

const signedPSBTBytes = await phantomProvider.signPSBT(
  fromHexString("70736274ff0100fd940102000000048a841e4104389e3b5b04c1522ed7bfc0e64c3760cb801a2ee2406d1c2373d81d0300000000ffffffff8a841e4104389e3b5b04c1522ed7bfc0e64c3760cb801a2ee2406d1c2373d81d0400000000ffffffffaf3341cffbd7ce8b4a51dec0f358a21809fad67be1a11bf70b86e83ec4567ace0100000000ffffffff8eceb072b7c47ebd9c1aa2e17c2541145835c70a8667eb21fa2ff3cac503170e0600000000ffffffff07b004000000000000160014b2c9b35e4b02e8b16236ae5c0540cf2d56605ed04a01000000000000225120b1a548f1672b6bc666e23943b0b138a4216e2ce5f9bc687469e0f52a917bbf274b0100000000000017a91433ab469b293fa7700f0954c96ec630895892f189874402000000000000160014c015c65276d5f38d599d445c4cb03aa7aa0dc3655802000000000000160014b2c9b35e4b02e8b16236ae5c0540cf2d56605ed05802000000000000160014b2c9b35e4b02e8b16236ae5c0540cf2d56605ed072fe050000000000160014b2c9b35e4b02e8b16236ae5c0540cf2d56605ed000000000000100fdf50102000000000101a1f8bb2bde4e13b2f397a82a8a101b378e90af13354710b93742be79b773e3840000000000ffffffff0b5802000000000000160014b2c9b35e4b02e8b16236ae5c0540cf2d56605ed05802000000000000160014b2c9b35e4b02e8b16236ae5c0540cf2d56605ed05802000000000000160014b2c9b35e4b02e8b16236ae5c0540cf2d56605ed05802000000000000160014b2c9b35e4b02e8b16236ae5c0540cf2d56605ed05802000000000000160014b2c9b35e4b02e8b16236ae5c0540cf2d56605ed05802000000000000160014b2c9b35e4b02e8b16236ae5c0540cf2d56605ed05802000000000000160014b2c9b35e4b02e8b16236ae5c0540cf2d56605ed05802000000000000160014b2c9b35e4b02e8b16236ae5c0540cf2d56605ed05802000000000000160014b2c9b35e4b02e8b16236ae5c0540cf2d56605ed05802000000000000160014b2c9b35e4b02e8b16236ae5c0540cf2d56605ed00d4c070000000000160014b2c9b35e4b02e8b16236ae5c0540cf2d56605ed00247304402204d2e9da8a14537a1c37b59e6a7eb828816249747dbec041315ade14a181c826a022044dcc381227cef6ab18431e692dccc7c27e2a10fed4d3131e0523094819d1dda0121028b8437ac47a4434d4b86d19ab7eeb255887f75cfa43ca135168bfc8281ae8bb90000000001011f5802000000000000160014b2c9b35e4b02e8b16236ae5c0540cf2d56605ed0000100fdf50102000000000101a1f8bb2bde4e13b2f397a82a8a101b378e90af13354710b93742be79b773e3840000000000ffffffff0b5802000000000000160014b2c9b35e4b02e8b16236ae5c0540cf2d56605ed05802000000000000160014b2c9b35e4b02e8b16236ae5c0540cf2d56605ed05802000000000000160014b2c9b35e4b02e8b16236ae5c0540cf2d56605ed05802000000000000160014b2c9b35e4b02e8b16236ae5c0540cf2d56605ed05802000000000000160014b2c9b35e4b02e8b16236ae5c0540cf2d56605ed05802000000000000160014b2c9b35e4b02e8b16236ae5c0540cf2d56605ed05802000000000000160014b2c9b35e4b02e8b16236ae5c0540cf2d56605ed05802000000000000160014b2c9b35e4b02e8b16236ae5c0540cf2d56605ed05802000000000000160014b2c9b35e4b02e8b16236ae5c0540cf2d56605ed05802000000000000160014b2c9b35e4b02e8b16236ae5c0540cf2d56605ed00d4c070000000000160014b2c9b35e4b02e8b16236ae5c0540cf2d56605ed00247304402204d2e9da8a14537a1c37b59e6a7eb828816249747dbec041315ade14a181c826a022044dcc381227cef6ab18431e692dccc7c27e2a10fed4d3131e0523094819d1dda0121028b8437ac47a4434d4b86d19ab7eeb255887f75cfa43ca135168bfc8281ae8bb90000000001011f5802000000000000160014b2c9b35e4b02e8b16236ae5c0540cf2d56605ed0000100fd6f0302000000000104a81c37519eca22bd78a4705230dcc471fb59f285bb2f22165c803de5bbe10b4c08000000171600147e3a872889766d0e3aebacf19f7936fd659b2605ffffffffa81c37519eca22bd78a4705230dcc471fb59f285bb2f22165c803de5bbe10b4c03000000171600147e3a872889766d0e3aebacf19f7936fd659b2605ffffffff33ec9dbdfa3ecb3654683b54855eac430d41b9b87b028f8cc84c6766bf7cc3870100000000ffffffff14e64f84c47029f5b8687519707c6e18080f675f37323746c695a681b0fdfece06000000171600147e3a872889766d0e3aebacf19f7936fd659b2605ffffffff07b00400000000000017a91433ab469b293fa7700f0954c96ec630895892f189874a01000000000000225120a9af1fae42dbe9b0604e0ed64ae6e26d56d1c9bbcc4e1e66326914bdb5149606591a000000000000225120cfb72754409e197bce4ea0670bd4f977104bcc86f7ea65d8981609dc66e984454402000000000000160014c015c65276d5f38d599d445c4cb03aa7aa0dc365580200000000000017a91433ab469b293fa7700f0954c96ec630895892f18987580200000000000017a91433ab469b293fa7700f0954c96ec630895892f18987d8c300000000000017a91433ab469b293fa7700f0954c96ec630895892f189870247304402204c291efdec8e7442aef45ad4751938ae21b847bedde8ce8c9eb208f7a29537880220247a6767215d12c0c5ebc751b6386c50c3a9d5ba0792e0396e2ae420b736a5ab0121032765788cbacba654f3cdf679026db3cdb5a5d0310f870f4da223926a2813259902483045022100bceed8f98e1fbed310cfc01e2bdd3dcbd146064c6fc9d423e787367602d8df7c02204e300e2c9e6c4be50f2c9db54c2f6aeb5eae1897db38bf6406f16ee2e3de4f5e0121032765788cbacba654f3cdf679026db3cdb5a5d0310f870f4da223926a2813259901414045d5e077660865bde16a0af320b426f636b49ea7674f1cc1a9d7c86643638cdbb21c9a281c79aeaa118d833840eca4ec0b3cc6a807f1900bb7395ab4eb72ff830247304402204fdc2e31b88b42081c42dc6c249297aeffe1147071fa6994f95ded6257d93d9602205bf9c30fc7cf0d2b78a1e0027e1cc4eae6e45aef7281017fac932058ee1674d70121032765788cbacba654f3cdf679026db3cdb5a5d0310f870f4da223926a281325990000000001012b4a01000000000000225120a9af1fae42dbe9b0604e0ed64ae6e26d56d1c9bbcc4e1e66326914bdb51496060117207f003df863d4c17579f7b22f7498e39525b81c947aef234859b0466d3dd8dfb3000100fd2603020000000001048a841e4104389e3b5b04c1522ed7bfc0e64c3760cb801a2ee2406d1c2373d81d0800000000ffffffff8a841e4104389e3b5b04c1522ed7bfc0e64c3760cb801a2ee2406d1c2373d81d0500000000ffffffff9584f0b205109f6790fbf08f782166892f22facb8e2598b705cd9136b25aabc30000000000ffffffff4f4b0bbc053b9e3cb6261cb83c063481eba8a8a32a448c63f1c1218d6fe330380600000000ffffffff07b004000000000000160014b2c9b35e4b02e8b16236ae5c0540cf2d56605ed02202000000000000225120b1a548f1672b6bc666e23943b0b138a4216e2ce5f9bc687469e0f52a917bbf2775120000000000002251208ef171ead3a8f91d9dca9ae4b645537aafada16559f9f714cbe524ef672ab4144402000000000000160014c015c65276d5f38d599d445c4cb03aa7aa0dc3655802000000000000160014b2c9b35e4b02e8b16236ae5c0540cf2d56605ed05802000000000000160014b2c9b35e4b02e8b16236ae5c0540cf2d56605ed04057060000000000160014b2c9b35e4b02e8b16236ae5c0540cf2d56605ed002483045022100a5cf71b0115db7980055fa9158c24fca9e3cc09cca0d1a0c54f17e8fa92d3e2402201b7dce27ff09e06c40a87b54aa2db693f49291e2f1a32f055155a3750607d01e0121028b8437ac47a4434d4b86d19ab7eeb255887f75cfa43ca135168bfc8281ae8bb902473044022049edbc2650ed737bad10d567c072da54c6b592fcfe2240fabcd49d8aa176422102206c8101ba6f8d6a155ed916ca7b25bf69395d76c020cb6ed9cf8293d65870346e0121028b8437ac47a4434d4b86d19ab7eeb255887f75cfa43ca135168bfc8281ae8bb901410a4a56764a5f9ed3fee4a869f6edee7b9b72f87bdba96d08310191a6df94bcf56f32152e63a836844cea71611886e3f96f74a2cc06d88ddf508184857f5fb4138302473044022075b779781668f4a487c2308aca9217125b897d089f617d831122612db02a672402200ef61ec6ddb6cac999e528e9e4fe27acb0a1cba4f8b33204b180ee458a8d82790121028b8437ac47a4434d4b86d19ab7eeb255887f75cfa43ca135168bfc8281ae8bb90000000001011f4057060000000000160014b2c9b35e4b02e8b16236ae5c0540cf2d56605ed00000000000000000"),
  {
    inputsToSign: [
      {
        address: "bc1qktymxhjtqt5tzc3k4ewq2sx094txqhksgy8hsw",
        signingIndexes: [0, 1, 3],
        sigHash: 0,
      },
    ],
  },
);
```


# Sign a message
Source: https://docs.phantom.com/bitcoin/signing-a-message



When a dapp is connected to Phantom, it can also request that the user signs a given message. Applications are free to write their own messages which will be displayed to users from within Phantom's signature prompt. Message signatures do not involve network fees and are a convenient way for apps to verify ownership of an address.

![Signing a message in the Phantom browser extension](https://mintlify.s3.us-west-1.amazonaws.com/phantom-e50e2e68/bitcoin/images/signing-a-message.webp)

Phantom’s `signMessage` function accepts two parameters: an encoded `message` and an `address` that should be used to sign the message. It returns a Promise that resolves if the user approves the signature request. Once resolved, it contains the resulting `signature`.

```typescript
// function signature
function signMessage(
    address: string,
    message: Uint8Array,
  ): Promise<{
    signature: Uint8Array;
  }>;
```

The following is an example of how to construct and sign a message with Phantom:

```typescript
const message = new TextEncoder().encode('hello world');
const address = "bc1phajtersv55fwud5xr0t70p5234swy396a6avqhuny0qf83zssvrsm7tl4q"; // see "Establishing a Connection"
const { signature } = await phantomProvider.signMessage(address, message);
```

To verify that a message was signed by a given address, we recommend using the [bip322-js](https://github.com/ACken2/bip322-js) library like so:

```typescript
import { Verifier } from "bip322-js";

// helper method
function bytesToBase64(bytes) {
  const binString = String.fromCodePoint(...bytes);
  return btoa(binString);
}

const isValidSignature = Verifier.verifySignature(
  address,
  new TextDecoder().decode(message),
  bytesToBase64(signature),
);
console.log(isValidSignature);
// true
```


# Auto-Confirm
Source: https://docs.phantom.com/developer-powertools/auto-confirm



<Tip>
  Watch [Auto-Confirm demo](https://youtu.be/WAfv06CPiRo) on YouTube.
</Tip>

[Auto-Confirm](https://phantom.app/learn/blog/auto-confirm) is a feature that lets users submit transactions and signed messages without triggering an approval dialog. When Auto-Confirm is enabled, Phantom will still analyze requests and their accompanying domains before signing.

To learn more about Auto-Confirm, fill out this [form](https://docs.google.com/forms/d/e/1FAIpQLSeHWETFkEJbHQCF-lnl1AHmVQPuyfC0HbnxjDjIp6VYV1sBZQ/viewform).


# Phantom blocklist
Source: https://docs.phantom.com/developer-powertools/blocklist



The Phantom blocklist is being deprecated. To address any warnings displayed in Phantom when interacting with your application, see [Domain and transaction warnings](/developer-powertools/domain-and-transaction-warnings).


# Domain and transaction warnings
Source: https://docs.phantom.com/developer-powertools/domain-and-transaction-warnings



If Phantom is displaying a warning when signing a transaction on your domain, send an email to [review@phantom.com](mailto:review@phantom.com) with the following information:

* Domain URL
* GitHub repo
* Any social accounts for the project


# Mobile web debugging
Source: https://docs.phantom.com/developer-powertools/mobile-web-debugging



<Tip>
  Watch [How to debug your dapp on iPhone using Phantom](https://www.loom.com/share/1b1817d84af649c9a38e5dbd8ed25ca9?t=1) on loom.
</Tip>

Developers can debug their mobile web dapps using PC browsers. To enable this in Phantom mobile, go to **Settings** > **Developer Settings**, and toggle **Web View Debugging** on. Then follow the steps for your platform.

## iOS

1. Tether your iPhone to your computer via USB.
2. On your iPhone go to **Settings** > **Safari** > **Advanced** and turn on **Web Inspector**.
3. On your computer open Safari. Then from the menu bar **Safari** > Settings -> Advanced tab -> turn on **Show features for web developers**.
4. Open your web dapp in Phantom on your tethered device.
5. Back on your computer from the Safari menu bar, go to **Develop** > \[Your device] > \[Your dapp].

## Android

1. Tether your Android phone to your computer via USB.
2. Open your web dapp in Phantom on your tethered device.
3. On your computer open `chrome://inspect/#devices` on Chrome.
4. Select your device on the left and select **Inspect** on the Phantom dapp contents you'd like to inspect.

![Developer Settings menu in the Phantom browser extension](https://mintlify.s3.us-west-1.amazonaws.com/phantom-e50e2e68/developer-powertools/images/developer-settings-web.avif)

For more information, see [React Native WebView debugging guide](https://github.com/react-native-webview/react-native-webview/blob/master/docs/Debugging.md#debugging-webview-contents).


# Shortcuts
Source: https://docs.phantom.com/developer-powertools/shortcuts



[Shortcuts](https://phantom.app/learn/blog/shortcuts) is a feature that enables NFT collections to surface a curated list of links to their holders.

<Info>
  Shortcuts are currently in beta. If you want to enable this in your project within Phantom, let us know by submitting this [form](https://docs.google.com/forms/d/e/1FAIpQLSeHWETFkEJbHQCF-lnl1AHmVQPuyfC0HbnxjDjIp6VYV1sBZQ/viewform).
</Info>

For details, see our [implementation guide](https://github.com/phantom/shortcuts) on GitHub.


# Sign-In-With (SIW) standards
Source: https://docs.phantom.com/developer-powertools/signing-a-message



Applications that rely on `signMessage` for authenticating users can choose to opt-in to one of the various Sign-In with (SIW) standards. If a message follows one of the supported standards, Phantom will verify required fields at the time of signing.

At the time of this writing, Phantom supports:

* **Sign-In with Solana** ([specification](https://github.com/phantom/sign-in-with-solana))
* **Sign-In with Ethereum** ([EIP-4361](https://eips.ethereum.org/EIPS/eip-4361))
* **Sign-In with X** ([CAIP-122](https://github.com/ChainAgnostic/CAIPs/blob/main/CAIPs/caip-122.md))

The serialized format of SIW messages is as follows:

```
${domain} wants you to sign in with your ${blockchain} account:
${address}

${statement}

URI: ${uri}
Version: ${version}
Chain ID: ${chain-id}
Nonce: ${nonce}
Issued At: ${issued-at}
Expiration Time: ${expiration-time}
Not Before: ${not-before}
Request ID: ${request-id}
Resources:
- ${resources[0]}
- ${resources[1]}
...
- ${resources[n]}
```

| Name              | Type       | Required? | Description                                                                                           |
| ----------------- | ---------- | --------- | ----------------------------------------------------------------------------------------------------- |
| `domain`          | `string`   | true      | The authority that is requesting the signing.                                                         |
| `address`         | `string`   | true      | The blockchain address that is performing the signing.                                                |
| `statement`       | `string`   | false     | A human-readable ASCII assertion that the user will sign. It MUST NOT contain `\\n`.                  |
| `uri`             | `string`   | true      | A URI referring to the resource that is the subject of the signing—that is, the subject of the claim. |
| `version`         | `string`   | true      | The current version of the message.                                                                   |
| `chain-id`        | `string`   | true      | The Chain ID to which the session is bound, and the network where Contract Accounts MUST be resolved. |
| `nonce`           | `string`   | true      | A randomized token to prevent signature replay attacks.                                               |
| `issued-at`       | `string`   | true      | The issuance time.                                                                                    |
| `expiration-time` | `string`   | false     | The time at which the signed authentication message is no longer valid.                               |
| `not-before`      | `string`   | false     | The time at which the signed authentication message starts being valid.                               |
| `request-id`      | `string`   | false     | A system-specific identifier used to uniquely refer to the authentication request.                    |
| `resources`       | `string[]` | false     | A list of URIs the user wishes to have resolved as part of the authentication by the relying party.   |

### Sign-In with Solana

See our [specification and integration guide](https://github.com/phantom/sign-in-with-solana) on GitHub.

### Sign-In with Ethereum

The Sign-In with Ethereum standard is defined by [EIP-4361](https://eips.ethereum.org/EIPS/eip-4361).

#### Examples

signMessage()

```javascript
const provider = getProvider(); // see "Detecting the Provider"
const message = `magiceden.io wants you to sign in with your Ethereum account:
0xb9c5714089478a327f09197987f16f9e5d936e8a

Click Sign or Approve only means you have proved this wallet is owned by you.

URI: https://magiceden.io
Version: 1
Chain ID: 1
Nonce: bZQJ0SL6gJ
Issued At: 2022-10-25T16:52:02.748Z
Resources:
- https://foo.com
- https://bar.com`;
const encodedMessage = new TextEncoder().encode(message);
const signedMessage = await provider.signMessage(encodedMessage, "utf8");
```

request()

```javascript
const provider = getProvider(); // see "Detecting the Provider"
const message = `magiceden.io wants you to sign in with your Ethereum account:
0xb9c5714089478a327f09197987f16f9e5d936e8a

Click Sign or Approve only means you have proved this wallet is owned by you.

URI: https://magiceden.io
Version: 1
Chain ID: 1
Nonce: bZQJ0SL6gJ
Issued At: 2022-10-25T16:52:02.748Z
Resources:
- https://foo.com
- https://bar.com`;
const encodedMessage = new TextEncoder().encode(message);
const signedMessage = await provider.request({
    method: "signMessage",
    params: {
         message: encodedMessage,
         display: "utf8",
    }
});
```

### Sign-In with X

The Sign-In with X standard is defined by [CAIP-122](https://github.com/ChainAgnostic/CAIPs/blob/master/CAIPs/caip-122.md). It uses [CAIP-10](https://github.com/ChainAgnostic/CAIPs/blob/master/CAIPs/caip-10) identifiers for the `address` field and [CAIP-2](https://github.com/ChainAgnostic/CAIPs/blob/master/CAIPs/caip-2) for `chain-id`.

<Info>
  While CAIP-122 is technically chain-agnostic, only Ethereum and Solana parsing are supported at this time.
</Info>

#### Ethereum example

signMessage()

```javascript
const provider = getProvider(); // see "Detecting the Provider"
const message = `magiceden.io wants you to sign in with your Ethereum account:
eip155:1:0xb9c5714089478a327f09197987f16f9e5d936e8a

Click Sign or Approve only means you have proved this wallet is owned by you.

URI: https://magiceden.io
Version: 1
Chain ID: eip155:1
Nonce: bZQJ0SL6gJ
Issued At: 2022-10-25T16:52:02.748Z
Resources:
- https://foo.com
- https://bar.com`;
const encodedMessage = new TextEncoder().encode(message);
const signedMessage = await provider.signMessage(encodedMessage, "utf8");
```

request()

```javascript
const provider = getProvider(); // see "Detecting the Provider"
const message = `magiceden.io wants you to sign in with your Ethereum account:
eip155:1:0xb9c5714089478a327f09197987f16f9e5d936e8a

Click Sign or Approve only means you have proved this wallet is owned by you.

URI: https://magiceden.io
Version: 1
Chain ID: eip155:1
Nonce: bZQJ0SL6gJ
Issued At: 2022-10-25T16:52:02.748Z
Resources:
- https://foo.com
- https://bar.com`;
const encodedMessage = new TextEncoder().encode(message);
const signedMessage = await provider.request({
    method: "signMessage",
    params: {
         message: encodedMessage,
         display: "utf8",
    }
});
```

#### Solana example

signMessage()

```javascript
const provider = getProvider(); // see "Detecting the Provider"
const message = `magiceden.io wants you to sign in with your Solana account:
solana:mainnet:FYpB58cLw5cwiN763ayB2sFT8HLF2MRUBbbyRgHYiRpK

Click Sign or Approve only means you have proved this wallet is owned by you.

URI: https://magiceden.io
Version: 1
Chain ID: solana:mainnet
Nonce: bZQJ0SL6gJ
Issued At: 2022-10-25T16:52:02.748Z
Resources:
- https://foo.com
- https://bar.com`;
const encodedMessage = new TextEncoder().encode(message);
const signedMessage = await provider.signMessage(encodedMessage, "utf8");
```

request()

```javascript
const provider = getProvider(); // see "Detecting the Provider"
const message = `magiceden.io wants you to sign in with your Solana account:
solana:mainnet:FYpB58cLw5cwiN763ayB2sFT8HLF2MRUBbbyRgHYiRpK

Click Sign or Approve only means you have proved this wallet is owned by you.

URI: https://magiceden.io
Version: 1
Chain ID: solana:mainnet
Nonce: bZQJ0SL6gJ
Issued At: 2022-10-25T16:52:02.748Z
Resources:
- https://foo.com
- https://bar.com`;
const encodedMessage = new TextEncoder().encode(message);
const signedMessage = await provider.request({
    method: "signMessage",
    params: {
         message: encodedMessage,
         display: "utf8",
    }
});
```

<Info>
  Phantom uses Ed25519 signatures for Solana message signatures. To verify a message signature, you can use the [tweetnacl](https://www.npmjs.com/package/tweetnacl) npm package.
</Info>


# Solana Actions and Blinks
Source: https://docs.phantom.com/developer-powertools/solana-actions-and-blinks



<Tip>
  Watch [Solana Actions and Blinks](https://youtu.be/TU87JjHxQQo) demo on YouTube.
</Tip>

[Solana Actions](https://solana.com/docs/advanced/actions) are APIs to deliver signable transactions from a variety of web contexts. Blockchain links, or [Blinks](https://solana.com/docs/advanced/actions#blinks), are client applications that introspect Action APIs and construct user interfaces to interact with Actions.

As of July 2025, the Phantom Extension supports rendering Blinks on Twitter/X.com. If an Action URL is posted to Twitter/X.com, the Phantom extension is can construct a UI to interact with the transaction from directly within the user's timeline.

This feature is disabled by default. Users can opt-in to enabling this feature via by goint to **Settings** > **Experimental Features** and turning on **Blinks**. Phantom will only render Actions that are registered under the Dialect-maintained [Actions Registry](https://solana.com/docs/advanced/actions#dialect's-actions-registry).


# Solana priority fees
Source: https://docs.phantom.com/developer-powertools/solana-priority-fees



Phantom automatically calculates and applies [Priority fees](https://docs.solana.com/proposals/fee_transaction_priority) to all Phantom-generated transactions and dapp-generated transactions that meet [our requirements](#how-phantom-applies-priority-fees-to-dapp-transactions).

## How transaction fees work on Solana

Solana transactions fees are calculated based on two main parts:

* A statically set base fee per signature, and
* The computational resources used during the transaction, measured in **Compute Units** **(CU)**

Since each transaction requires different computational resources, they are allotted a maximum number of compute units, known as the Compute Budget. After the Compute Budget is exhausted, the runtime halts the transaction and returns an error, resulting in a failed transaction.

The maximum budget for a transaction is 1.4 million CU, while the total blockspace limit is 48 million CU. Only a few computationally heavy TXs, like a mint or a swap, could fill the entire block, halting other TXs—hence the need for **Priority Fees**.

The fee priority of a transaction `T` can be defined as `F(T)`, where `F(T)` is the *"fee-per compute-unit"*, calculated by:

$$
(additional\_fee + base\_fee)\  /\  requested\_compute\_units
$$

This means that the more compute units a transaction requests, the more additional fee it will have to pay to maintain the priority in the transaction queue. This prevents computationally heavy transactions from being easily spammed or from filling blocks.

## Priority fee calculation

Priority fees are calculated as,

$$
priority\_fees\ =\ compute\_budget\ *\ compute\_unit\_price
$$

where,

$$
compute\_budget\ =\ \#\ of\ instructions\ *\ compute\_unit\_limit
$$

## How Phantom applies priority fees to app transactions

Although dapps can set their own [priority fees on transactions](https://solanacookbook.com/references/basic-transactions.html#how-to-change-compute-budget-fee-priority-for-a-transaction) they generate, we highly discourage doing so as it often surfaces unnecessary complexity to end-users. Instead, we recommend that dapp developers let Phantom apply priority fees on the user's behalf.

Phantom will calculate and apply Priority Fees to all dapp-generated transactions, provided:

* The transaction(s) do not already have signature(s) present.
* The transaction(s) do not have existing priority fee instructions (`computeUnitBudget` or `computeUnitLimit`).
* After enhancing transaction(s) with Priority Fees, the size of each transaction will still be less than the byte size limit (1232 bytes).

If all of the above conditions are met, Phantom will automatically calculate and apply priority fees at the time of signing. This pattern applies to all Phantom provider methods (`signAndSendTransaction`, `signTransaction` , `signAllTransactions`) across all environments (extension, mobile in-app browser, deeplinks, mobile wallet adapter).

## Further reading

* [Fee Transaction Priority - Solana Proposals](https://docs.solana.com/proposals/fee_transaction_priority)
* [How to change compute budget fee priority for a transaction - Solana Cookbook](https://solanacookbook.com/references/basic-transactions.html#how-to-change-compute-budget-fee-priority-for-a-transaction)
* [Prioritization Fees - Solana Programming Model](https://docs.solana.com/developing/programming-model/runtime#prioritization-fees)
* [Transaction Fees - Prioritization Fee](https://docs.solana.com/transaction_fees#prioritization-fee)


# Solana Token Extensions (Token22)
Source: https://docs.phantom.com/developer-powertools/solana-token-extensions-token22



Phantom supports [fungible](../best-practices/tokens/home-tab-fungibles) and [non-fungible](../best-practices/tokens/collectibles-nfts-and-semi-fungibles) tokens created with the [Token-2022 Program](https://spl.solana.com/token-2022). At the time of this writing, Phantom supports the following Token Extensions:

## Group and Group Pointer

The [Group](https://spl.solana.com/token-2022/extensions#group) and [Group Pointer](https://spl.solana.com/token-2022/extensions#group-pointer) extensions allow token creators to create configurations for grouping tokens together. Phantom currently supports both extensions for non-fungible tokens in the **Collectibles** tab.

If a particular mint has a `memberAddress` listed under a `groupMemberPointer`, Phantom will look for the `mint` and `group` fields stored at this `memberAddress`. If the mint address matches the `mint` value, Phantom will use the `group` as the new group identifier.

Example (mainnet): [8eDYWjDKmCR5B3UJm95gaG8zCdT5anWakTZG1PyWpBm9](https://solana.fm/address/8eDYWjDKmCR5B3UJm95gaG8zCdT5anWakTZG1PyWpBm9/extensions)

## Interest-Bearing Tokens

The [Interest-Bearing Tokens](https://spl.solana.com/token-2022/extensions#interest-bearing-tokens) extension allows creators to set an interest rate on their tokens. This interest rate is for cosmetic purposes only, no new tokens are created as a result of the interest. If this extension is enabled, Phantom will display the current interest rate on the token's detail screen.

Example (mainnet): [aNMXxywEHAH3VfWnaVwedLJWPT9NsxagsGTEQqS5WKK](https://solana.fm/address/aNMXxywEHAH3VfWnaVwedLJWPT9NsxagsGTEQqS5WKK?cluster=mainnet-alpha)

## Memo on Transfer

The [Memo on Transfer](https://spl.solana.com/token-2022/extensions#required-memo-on-transfer) extension enforces that all incoming transfers must have an accompanying memo instruction right before the transfer instruction. If this extension is enabled, an account owner may choose to flip the required memo on or off. Phantom will allow a user to input a memo on transfers, even if it is optional.

Example on mainnet: BonkEarn [CKfatsPMUf8SkiURsDXs7eK6GWb4Jsd6UDbs7twMCWxo](https://solana.fm/address/CKfatsPMUf8SkiURsDXs7eK6GWb4Jsd6UDbs7twMCWxo?cluster=mainnet-alpha)

## Metadata

The [Metadata](https://spl.solana.com/token-2022/extensions#metadata) extension allows a token creator to include their metadata directly in the token's mint account. Phantom will display the `name` and `symbol` that is stored in the mint account, and look to the `uri` field for additional information such as the token's `image`.

Example on devnet: [EGKdqrXxFeTpRTskrH81xmefuTAU9MJGCDLoNss28a2](https://solana.fm/address/EGKdqrXxFeTpRTskrH81xmefuTAU9MJGCDLoNss28a2?cluster=devnet-solana)

## Metadata Pointer

The [Metadata Pointer](https://spl.solana.com/token-2022/extensions#metadata-pointer) extension allows a token creator to designate an address that describes the canonical metadata. Phantom supports the Metadata Pointer Extension. At the time of this writing, Phantom will assume all metadata schemas follow the [Metaplex Standard](https://developers.metaplex.com/token-metadata/token-standard).

## Permanent Delegate

The [Permanent Delegate](https://spl.solana.com/token-2022/extensions#permanent-delegate) extension allows token creators to grant unlimited delegation privileges over any account for that mint. If enabled, a delegate can can burn or transfer any amount of tokens. Phantom will display a warning for any token that has this extension enabled.

Example on mainnet: [aNMXxywEHAH3VfWnaVwedLJWPT9NsxagsGTEQqS5WKK](https://solana.fm/address/aNMXxywEHAH3VfWnaVwedLJWPT9NsxagsGTEQqS5WKK?cluster=mainnet-alpha)

## Transfer Fees

The [Transfer Fees](https://spl.solana.com/token-2022/extensions#transfer-fees) extension allows a token creator to assess fees on every token transfer. If this extension is enabled, Phantom will display the fee on the confirmation screen of every send.

Example on mainnet: BonkEarn [CKfatsPMUf8SkiURsDXs7eK6GWb4Jsd6UDbs7twMCWxo](https://solana.fm/address/CKfatsPMUf8SkiURsDXs7eK6GWb4Jsd6UDbs7twMCWxo?cluster=mainnet-alpha)

## Transfer Hooks

The [Transfer Hooks](https://spl.solana.com/token-2022/extensions#transfer-hook) extension allows a token to invoke a custom program at the time of transfer. This program can be used to add custom logic on transfers, such as assessing royalties or determining if the transfer is allowed based on a range of on-chain data sources.


# Solana Versioned Transactions
Source: https://docs.phantom.com/developer-powertools/solana-versioned-transactions



Phantom supports [Versioned Transactions](https://docs.solana.com/developing/versioned-transactions) and [Legacy Transactions](../solana/sending-a-transaction). Versioned Transactions and Address Lookup Tables (LUTs) were introduced by Solana in an effort to improve the developer and end-user experience. The proposed changes are as follows:

* Introduce a program which manages on-chain address lookup tables
* Add a new transaction format which can make use of the above on-chain address lookup tables

Why do we need the above?

Legacy transactions have a major issue: Maximum allowed size of 1232 bytes, and hence the number of accounts that can fit in an atomic transaction: 35 addresses.

![Legacy Transaction Avi](https://mintlify.s3.us-west-1.amazonaws.com/phantom-e50e2e68/developer-powertools/images/legacy-transaction.avif)

This is problematic as developers are limited with this threshold and are unable to include >35 signature-free account / program addresses in a single transaction. This is where Address LUTs come into the picture.

## Address LUTs

The idea behind Address LUTs is to store account addresses in array-like data structures on-chain. Once accounts are stored in this table, the address of the table can be referenced in a transaction message using 1-byte u8 indices.

![Address Lookup Tables Avi](https://mintlify.s3.us-west-1.amazonaws.com/phantom-e50e2e68/developer-powertools/images/address-lookup-tables.avif)

This opens up space as addresses need not be stored inside transaction messages, but only be referenced. This allows 2^8=256 accounts to be included in 1 tx, as accounts are referenced using u8 indices.

## RPC changes

Transaction responses will require a new version field: `maxSupportedTransactionVersion` to indicate to clients which transaction structure needs to be followed for deserialisation.

The following methods need to be updated to avoid errors:

* `getTransaction`
* `getBlock`

The following parameter needs to be added to the requests:

`maxSupportedTransactionVersion: 0`

If `maxSupportedTransactionVersion` is not explicitly added to the request, the transaction version will fallback to `legacy`. Any block that contains a versioned transaction will return with an error by the client in the case of a legacy transaction.

You can set this via JSON formatted requests to the RPC endpoint like below:

```bash
curl http://localhost:8899 -X POST -H "Content-Type: application/json" -d \
'{"jsonrpc": "2.0", "id":1, "method": "getBlock", "params": [430, {
  "encoding":"json",
  "maxSupportedTransactionVersion":0,
  "transactionDetails":"full",
  "rewards":false
}]}'
```

You can also do the same using the [@solana/web3.js](https://github.com/solana-foundation/solana-web3.js) library.

```javascript
// connect to the `devnet` cluster and get the current `slot`
const connection = new web3.Connection(web3.clusterApiUrl("devnet"));
const slot = await connection.getSlot();

// get the latest block (allowing for v0 transactions)
const block = await connection.getBlock(slot, {
  maxSupportedTransactionVersion: 0,
});

// get a specific transaction (allowing for v0 transactions)
const getTx = await connection.getTransaction(
  "3jpoANiFeVGisWRY5UP648xRXs3iQasCHABPWRWnoEjeA93nc79WrnGgpgazjq4K9m8g2NJoyKoWBV1Kx5VmtwHQ",
  {
    maxSupportedTransactionVersion: 0,
  },
);
```

For details on how to build and send Versioned Transactions and LUTs, see [Send a versioned transaction](../solana/sending-a-transaction-1).

## Further reading

* [How to create a versioned transaction - Solana Docs](https://beta.docs.solana.com/developing/versioned-transactions#how-create-a-versioned-transaction)
* [How to create an address lookup table - Solana Docs](https://beta.docs.solana.com/developing/lookup-tables#how-to-create-an-address-lookup-table)
* [Versioned Transactions - Anvit Hashnode](https://anvit.hashnode.dev/versioned-transactions)


# Testnet mode
Source: https://docs.phantom.com/developer-powertools/testnet-mode



To access test networks in Phantom, go to **Settings** > **Developer Settings** > **Testnet Mode**.

![Testnet mode toggle in Developer Settings](https://mintlify.s3.us-west-1.amazonaws.com/phantom-e50e2e68/developer-powertools/images/developer-settings-testnet.png)


# Token pages
Source: https://docs.phantom.com/developer-powertools/token-pages



Phantom provides shareable, web-accessible **token pages** that display detailed token information. These pages provide a seamless experience whether accessed through the Phantom wallet app or via web browsers.

## Generate a token page URL

To create a shareable token page URL:

1. Open the desired token page in Phantom.
2. Tap the share button.
3. Copy or share the generated URL.

The URL follows this format:

```
https://phantom.com/tokens/<chain>/<token_address>
```

For example, the WIF token on Solana can be accessed at:

```
https://phantom.com/tokens/solana/EKpQGSJtjMFqKZ9KQanSqYXRcF8fBopzLHYxdM65zcjm
```

## Key features

### Universal and deep linking

When accessed on mobile devices with Phantom installed, token page URLs automatically open the corresponding details page within the Phantom app. For users without Phantom installed, the links gracefully fallback to the web view.

### Quick access to swapper

The web view includes a QR code that, when scanned, deep links directly to the token's swap screen within the Phantom app. This enables quick and convenient token swaps for mobile users.

![An example token page on the web](https://mintlify.s3.us-west-1.amazonaws.com/phantom-e50e2e68/developer-powertools/images/token-page-web.png)

![An example token page in the Phantom mobile app](https://mintlify.s3.us-west-1.amazonaws.com/phantom-e50e2e68/developer-powertools/images/token-page-mobile.png)

### Enhanced social sharing

Each token page generates dynamic OpenGraph images that display essential token information and price charts. When shared on social media platforms, these rich previews provide immediate context about the token's performance and status.

![An example token page from X.com](https://mintlify.s3.us-west-1.amazonaws.com/phantom-e50e2e68/developer-powertools/images/token-twitter.png)


# Wallet Standard
Source: https://docs.phantom.com/developer-powertools/wallet-standard



[Wallet Standard](https://github.com/wallet-standard/wallet-standard) is a chain-agnostic set of interfaces and conventions that aim to improve how applications interact with injected wallets such as Phantom. The standard was pioneered on Solana and is used as the foundation for the [Solana Wallet Adapter](https://github.com/solana-labs/wallet-adapter). Phantom supports the Wallet Standard and is open to working with others to bring this innovation to other ecosystems.

Wallet Standard introduces an event-based model that:

1. Standardizes the way wallets attach themselves to the window.
2. Defines a set of standard APIs that dapps can rely upon.

At a high-level, Wallet Standard defines the following [Window interface](https://github.com/wallet-standard/wallet-standard/blob/ce280f05f6eb16d0e77939827e0b7fa294460e1f/packages/core/base/src/window.ts#L16-L25) for events:

```typescript
export interface WalletEventsWindow extends Omit<Window, 'addEventListener' | 'dispatchEvent'> {
    /** Add a listener for {@link WindowAppReadyEvent}. */
    addEventListener(type: WindowAppReadyEventType, listener: (event: WindowAppReadyEvent) => void): void;
    /** Add a listener for {@link WindowRegisterWalletEvent}. */
    addEventListener(type: WindowRegisterWalletEventType, listener: (event: WindowRegisterWalletEvent) => void): void;
    /** Dispatch a {@link WindowAppReadyEvent}. */
    dispatchEvent(event: WindowAppReadyEvent): void;
    /** Dispatch a {@link WindowRegisterWalletEvent}. */
    dispatchEvent(event: WindowRegisterWalletEvent): void;
}
```

When a wallet is ready to inject into a website, it will [dispatch](https://github.com/wallet-standard/wallet-standard/blob/ce280f05f6eb16d0e77939827e0b7fa294460e1f/packages/core/wallet/src/register.ts#L27-L38) a `register-wallet` event and listen for an `app-ready` event. Conversely, an app will [dispatch](https://github.com/wallet-standard/wallet-standard/blob/master/packages/core/app/src/wallets.ts#L39-L50) an `app-ready` event and listen for `register-wallet` events.

## For app developers

Phantom comes with built-in support for Wallet Standard on **Solana**. To get started, simply update the [Solana Wallet Adapter](https://github.com/solana-labs/wallet-adapter) to the latest release. For a demo, check out the [Wallet Adapter](https://anza-xyz.github.io/wallet-adapter/example/) example.

<Warning>
  If you are migrating an existing Solana dapp to use Wallet Standard, please ensure that you are not mutating transactions in place. Failure to do will result in a breaking change.
</Warning>

## Further reading

[Wallet Standard design document](https://github.com/wallet-standard/wallet-standard/blob/master/DESIGN.md)


# Detect the provider
Source: https://docs.phantom.com/ethereum-monad-testnet-base-and-polygon/detecting-the-provider



To detect if a user has already installed Phantom, a web application should check for the existence of a `phantom` object. Phantom's browser extension and mobile in-app browser will both inject a `phantom` object into the [window](https://developer.mozilla.org/en-US/docs/Web/API/Window) of any web application the user visits, provided that site is using `https://`, on `localhost`, or is `127.0.0.1.` Phantom will not inject the provider into [iframes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe) or sites using `http://`.

If a `phantom` object exists, EVM dApps can interact with Phantom via the API found at `window.phantom.ethereum`. This `ethereum` provider is also made available at `window.ethereum` but is prone to namespace collisions from other injected wallets.

To detect if Phantom is installed, an application should check for an additional `isPhantom` flag.

```typescript
const isPhantomInstalled = window?.phantom?.ethereum?.isPhantom
```

If Phantom is not installed, we recommend you redirect your users to our website `https://phantom.com/`. Altogether, this may look like the following:

## window\.phantom

```typescript
const getProvider = () => {
  if ('phantom' in window) {
    const anyWindow: any = window;
    const provider = anyWindow.phantom?.ethereum;
   
    if (provider) {
      return provider;
    }
  }

  window.open('https://phantom.com/', '_blank');
};
```

## window\.ethereum

```typescript
const getProvider = () => {
  if ('ethereum' in window) {
    const anyWindow: any = window;
    const provider = anyWindow.ethereum;
   
    if (provider?.isPhantom) {
      return provider;
    }
  }

  window.open('https://phantom.com/', '_blank');
};
```

For an example of how a React application can detect Phantom, refer to [getProvider](https://github.com/phantom-labs/eth_sandbox/blob/main/src/utils/getProvider.ts) in our sandbox.


# Establish a connection
Source: https://docs.phantom.com/ethereum-monad-testnet-base-and-polygon/establishing-a-connection



Once an application has [detected the provider](../solana/detecting-the-provider), it can then request to connect to Phantom. This connection request will prompt the user for permission to share their public key, indicating that they are willing to interact further. Users must approve a connection request before the app can make additional requests such as [signing a message](signing-a-message) or [sending a transaction](sending-a-transaction).

Once permission is established for the first time, the web application's domain will be whitelisted for future connection requests. After a connection is established, it is possible to terminate the connection from both the application and the user side.

## Connect

The default way to connect to Phantom is by calling `window.ethereum.request()` function.

```javascript
const provider = getProvider(); // see "Detecting the Provider"
try {
    const accounts = await provider.request({ method: "eth_requestAccounts" });
    console.log(accounts[0]);
    // 0x534583cd8cE0ac1af4Ce01Ae4f294d52b4Cd305F
} catch (err) {
    // { code: 4001, message: 'User rejected the request.' }
}
```

The `eth_requestAccounts` method will return a [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise). If it resolves, it is an array where the connected address is in the 0th index, and rejects (throw when awaited) when the user declines the request or closes the pop-up. See [Errors](../solana/errors) for a breakdown of error messages Phantom may emit.

When the user accepts the request to connect, the provider will also emit a `connect` event that contains the `chainId` of the network the user is connected to.

```typescript
provider.on("connect", (connectionInfo: { chainId: string }) => console.log(`Connected to chain: ${connectionInfo.chainId}`));
```

Once the web application is connected to Phantom, it will be able to read the connected account's address and prompt the user for additional transactions. It also exposes a convenience `isConnected` boolean.

```javascript
console.log(provider.selectedAddress);
// 0x534583cd8cE0ac1af4Ce01Ae4f294d52b4Cd305F 
console.log(provider.isConnected());
// true
```

## Disconnect

There is no way to programmatically disconnect a user from their connection once they have established one.\
\
Once a user has established a connection, Phantom will add the website they opened a connection with to a list of "trusted apps." The user can then revoke access through the UI at any time, and will then need to reconnect. Phantom will attempt to reconnect to any application that is added to the users' "trusted apps" automatically.

## Change accounts

Phantom allows users to seamlessly manage multiple accounts (addresses) from within a single extension or mobile app. Whenever a user switches accounts, Phantom will emit an `accountsChanged` event.

If a user changes accounts while already connected to an application, and the new account had already whitelisted that application, then the user will stay connected and Phantom will pass the public key of the new account:

```typescript
provider.on('accountsChanged', (publicKeys: String[]) => {
    if (publicKeys) {
        // Set new public key and continue as usual
        console.log(`Switched to account ${publicKeys[0]}`);
    } 
});
```

If Phantom does not pass the public key of the new account, an application can either do nothing or attempt to reconnect:

```typescript
provider.on('accountsChanged', (publicKeys: String[]) => {
    if (publicKeys) {
      // Set new public key and continue as usual
      console.log(`Switched to account ${publicKeys[0].toBase58()}`);
    } else {
      // Attempt to reconnect to Phantom
      provider.request({ method: "eth_requestAccounts" }).catch((error) => {
        // handle connection failure
      });
    }
});
```


# Get started with EVM networks
Source: https://docs.phantom.com/ethereum-monad-testnet-base-and-polygon/getting-started



The Phantom browser extension and mobile in-app browser are both designed to interact with web applications. EVM web apps can interact with Phantom via the provider that is injected at `window.phantom.ethereum`. This provider conforms to the [EIP-1193](https://eips.ethereum.org/EIPS/eip-1193) standard and is also injected at `window.ethereum` to support legacy integrations. Phantom also supports [EIP-6963](https://eip6963.org/) for ease of integration.

Additionally, Phantom has enabled support for the Monad Testnet, allowing developers and users to interact with the Monad network before its mainnet launch.

Developers can integrate Monad Testnet support using Phantom’s existing EVM provider by adding the relevant [network parameters](https://docs.monad.xyz/getting-started/network-information) and referring to the Monad documentation for any [special considerations](https://docs.monad.xyz/getting-started/differences).

<Note>
  Users must enable the Monad Testnet in Phantom’s settings before interacting with it. Once Monad mainnet support is enabled by default, this step will no longer be necessary.
</Note>

This documentation is dedicated to covering all aspects of the provider.


# Provider API reference
Source: https://docs.phantom.com/ethereum-monad-testnet-base-and-polygon/provider-api-reference/README



Phantom's provider API is exposed to the user through the `window.ethereum` object that is injected into the browser. This same provider is made available at `window.phantom.ethereum` to prevent namespace collisions.

This API is how a dapp will make requests to the user; reading account data, connecting to the website, signing messages, and sending transactions will all be done through this provider object.

This provider API is specified in greater detail in [EIP-1193](https://eips.ethereum.org/EIPS/eip-1193).

This area of the documentation will contain information about the API's properties, events, and methods.


# Error messages and codes
Source: https://docs.phantom.com/ethereum-monad-testnet-base-and-polygon/provider-api-reference/errors



When making requests to Phantom in [establishing a connection](../establishing-a-connection), [sending a transaction](../sending-a-transaction), or [signing a message](../signing-a-message), Phantom may respond with an error. The following is a list of all possible error codes and their meanings. These error messages follow [EIP-1474](https://eips.ethereum.org/EIPS/eip-1474#error-codes) and [EIP-1193](https://eips.ethereum.org/EIPS/eip-1193#provider-errors).

| Code   | Title                            | Description                                                                                                                                                                                                                                                                          |
| ------ | -------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| 4900   | Disconnected                     | Phantom could not connect to the network.                                                                                                                                                                                                                                            |
| 4100   | Unauthorized                     | The requested method and/or account has not been authorized by the user.                                                                                                                                                                                                             |
| 4001   | User Rejected Request            | The user rejected the request through Phantom.                                                                                                                                                                                                                                       |
| -32000 | Invalid Input                    | Missing or invalid parameters.                                                                                                                                                                                                                                                       |
| -32002 | Requested resource not available | This error occurs when a dapp attempts to submit a new transaction while Phantom's approval dialog is already open for a previous transaction. Only one approve window can be open at a time. Users should  approve or reject their transaction before initiating a new transaction. |
| -32003 | Transaction Rejected             | Phantom does not recognize a valid transaction.                                                                                                                                                                                                                                      |
| -32601 | Method Not Found                 | Phantom does not recognize the method.                                                                                                                                                                                                                                               |
| -32603 | Internal Error                   | Something went wrong within Phantom.                                                                                                                                                                                                                                                 |


# Events
Source: https://docs.phantom.com/ethereum-monad-testnet-base-and-polygon/provider-api-reference/events/README



Phantom's provider API available at `window.ethereum` implements a Node.js style [EventEmitter](https://nodejs.org/api/events.html) API, that allows you to hook into different events that are emitted upon certain actions that take place in either the dapp, or the wallet. Each page in this section will be an isolated piece of information that informs you of all the technical details you need to know about each event Phantom supports.


# Accounts changed
Source: https://docs.phantom.com/ethereum-monad-testnet-base-and-polygon/provider-api-reference/events/accounts-changed



Event emitted upon changing accounts within your Phantom wallet.

````typescript
window.ethereum.on('accountsChanged', (newAccounts: String[]) => {
      // "newAccounts" will always be an array, but it can be empty.      
      if (newAccounts) {
        console.log(`switched to new account: ${newAccounts}`);
        accounts = newAccounts;
      } else {
        /**
         * In this case dApps could...
         *
         * 1. Not do anything
         * 2. Only re-connect to the new account if it is trusted
         *
         * ```
         * provider.send('eth_requestAccounts', []).catch((err) => {
         *  // fail silently
         * });
         * ```
         *
         * 3. Always attempt to reconnect
         */
  }
})
````

You can see an example of [hooking into this event](https://github.com/phantom-labs/eth_sandbox/blob/main/src/App.tsx#L114-L152) in our sandbox.


# Chain changed
Source: https://docs.phantom.com/ethereum-monad-testnet-base-and-polygon/provider-api-reference/events/chain-changed



Event emitted upon the dapp or wallet changing the network/chain you are connected to.

Phantom abstracts the concept of networks, and network switching. So there is no action required on your end as a dapp developer.

```typescript
ethereum.on('chainChanged', (chainId: string) => {
  console.log(chainId);
  // "0x1" on Ethereum
  /* Phantom will handle all of the internal changes needed to handle the new chain.
   * As the dapp developer, 
   * you just need to make sure all of your transaction requests
   * populate the correct chainId
   */
});
```


# Connect
Source: https://docs.phantom.com/ethereum-monad-testnet-base-and-polygon/provider-api-reference/events/connect



Event emitted upon connecting to a dapp.

```typescript
interface connectionInfo {
  chainId: string;
}

window.ethereum.on('connect', (connectionInfo: connectionInfo) => {
      console.log(connectionInfo.chainId);
      // "0x1" On Ethereum
});
```

You can see an example of [hooking into this event](https://github.com/phantom-labs/eth_sandbox/blob/main/src/App.tsx#L98-L104) in our sandbox.


# Disconnect
Source: https://docs.phantom.com/ethereum-monad-testnet-base-and-polygon/provider-api-reference/events/disconnect



Event emitted upon the wallet losing connection to the RPC provider.

This is **not** a user "disconnecting" from a dapp, or otherwise revoking access between the dapp and the wallet.

```typescript
 window.ethereum.on('disconnect', () => {
      console.log('lost connection to the rpc)
});
```

You can see an example of [hooking into this event ](https://github.com/phantom-labs/eth_sandbox/blob/main/src/App.tsx#L106-L112)in our sandbox.


# Methods
Source: https://docs.phantom.com/ethereum-monad-testnet-base-and-polygon/provider-api-reference/methods/README



In the following pages you will find information about the individual methods that are available to you through Phantom's `window.phantom.ethereum` object. As a dapp developer, you will use these methods to programmatically interact with the wallet. From sending requests to/from the blockchain, to connecting to your website—these methods will help you interact with your users.


# isConnected
Source: https://docs.phantom.com/ethereum-monad-testnet-base-and-polygon/provider-api-reference/methods/isconnected



Checks if the wallet is connected to the dapp.

## Parameters

None

## Response

Boolean

```typescript
window.phantom.ethereum.isConnected()
// true if connected
// false if not
```


# request
Source: https://docs.phantom.com/ethereum-monad-testnet-base-and-polygon/provider-api-reference/methods/request



Sends a JSON RPC request to the wallet.

## Params

`method: string;` `params?: unknown[] | object;`

## Returns

`Promise<unknown>`

## Example

```javascript
const accounts = await window.phantom.ethereum.request({ 
    method: "eth_requestAccounts", params: [] 
})
console.log(accounts)
// ["0xDAFEA492D9c6733ae3d56b7Ed1ADB60692c98Bc5"]
```

The code above demonstrates how you can use the `request` method to ask the user to connect to your dapp.\
\
The `request` method is the go to way for you to interface with the wallet in your dapp. It accepts most [JSON RPC requests](https://ethereum.org/en/developers/docs/apis/json-rpc/#json-rpc-methods) that would need to interact with the wallet. \
\
However it **will not** work for methods that don't make sense for a wallet. For example, you can't use the provider object Phantom injects to call something like `eth_getTransactionByHash`. If you send a method that the provider object does not support, it will throw an error. For a full list of errors, see [Error messages and codes](../errors).


# Properties
Source: https://docs.phantom.com/ethereum-monad-testnet-base-and-polygon/provider-api-reference/properties/README



Here you will find a list of all of the properties available to you once the `window.phantom.ethereum` object has been injected.\
\
These are all exactly the same as the `window.ethereum` object. However, we recommend using the `window.phantom.ethereum` object to prevent namespace collisions.

```json
{
    chainId: HexString
    networkVersion: String
    selectedAddress: HexString
    _events: Object
    _eventsCount: Number
}
```


#  events
Source: https://docs.phantom.com/ethereum-monad-testnet-base-and-polygon/provider-api-reference/properties/_events



## window\.phantom.ethereum.\_events

An object containing all of the events that the provider has emitted or logged.

```javascript
const events = window.phantom.ethereum._events;
console.log(events);
// Events {chainChanged: Array(2), accountsChanged: EE}
```

This is **not** a recommended way to keep track of different events. The provider implements a Node.js `EventEmitter` API to emit different events happening within the wallet and/or dapp. For more details, see [Events](../events/README).


#  eventsCount
Source: https://docs.phantom.com/ethereum-monad-testnet-base-and-polygon/provider-api-reference/properties/_eventscount



## window\.phantom.ethereum.\_eventsCount

An object containing the number of events that have happened

```javascript
const eventsCount = window.phantom.ethereum._eventsCount;
console.log(eventsCount);
// 2
```

This is **not** a recommended way to keep track of different events. The provider implements a Node.js `EventEmitter` API to emit different events happening within the wallet and/or dapp.


# chainId
Source: https://docs.phantom.com/ethereum-monad-testnet-base-and-polygon/provider-api-reference/properties/chainid



## window\.phantom.ethereum.chainId

The `chainId` of the network you are currently connected to, returned as a hexadecimal string.

```javascript
const chainId = window.phantom.ethereum.chainId;
console.log(chainId);
// "0x1"
// hexidecimal representation of Ethereum Mainnet
```


# isPhantom
Source: https://docs.phantom.com/ethereum-monad-testnet-base-and-polygon/provider-api-reference/properties/isphantom



## window\.phantom.ethereum.isPhantom

A boolean that identifies if Phantom is installed.

```javascript
const isPhantomInstalled = window.phantom?.ethereum?.isPhantom;
console.log(isPhantomInstalled);
// true
```


# networkVersion
Source: https://docs.phantom.com/ethereum-monad-testnet-base-and-polygon/provider-api-reference/properties/networkversion



## window\.ethereum.networkVersion

The network number of the blockchain that you are connected to. This property is available for legacy purposes. It is recommended that modern dapps refer to the `chainId` property to determine what chain a user is connected to currently.

```javascript
const networkVersion = window.phantom.ethereum.networkVersion;
console.log(networkVersion);
// "1"
// Ethereum Mainnet's Network Version
```


# selectedAddress
Source: https://docs.phantom.com/ethereum-monad-testnet-base-and-polygon/provider-api-reference/properties/selectedaddress



## window\.phantom.ethereum.selectedAddress

The address of the wallet that is currently connected to the dapp. This value will update upon [accountsChanged ](../events/accounts-changed) and [connect](../events/connect) events.

Returns a hexadecimal string.

```javascript
const address = window.phantom.ethereum.selectedAddress;
console.log(address);
// "0xDAFEA492D9c6733ae3d56b7Ed1ADB60692c98Bc5"
```


# Send a transaction
Source: https://docs.phantom.com/ethereum-monad-testnet-base-and-polygon/sending-a-transaction



Once a web application is connected to Phantom, it can prompt the user for permission to send transactions on their behalf.

To send a transaction, you will need to have a valid transaction object. It should look a little like this:

```json
{
  from: "0xEA674fdDe714fd979de3EdF0F56AA9716B898ec8",
  to: "0xac03bb73b6a9e108530aff4df5077c2b3d481e5a",
  gasLimit: "21000",
  maxFeePerGas: "300",
  maxPriorityFeePerGas: "10",
  nonce: "0",
  value: "10000000000"
}
```

However, this transaction object needs to be signed using the sender's private key. This ensures that only the person that holds the private key can send transactions from the public address.

To prompt Phantom to send a transaction to the network, refer to the following code snippet:

```javascript
const result = await provider.request({
  method: 'eth_sendTransaction',
  params: [        
            {
            from: accounts[0],
            to: '0x0c54FcCd2e384b4BB6f2E405Bf5Cbc15a017AaFb',
            value: '0x0',
            gasLimit: '0x5028',
            gasPrice: '0x2540be400',
            type: '0x0',
          },
        ],
});
```

This is the building blocks of what you will need to send a transaction. However, if you were to copy/paste this, it would likely fail. There are several pieces of a transaction that are best provided in a dynamic manner. For details, refer to the [sendTransaction](https://github.com/phantom-labs/eth_sandbox/blob/main/src/utils/sendTransaction.ts) function in our sandbox.


# Sign a message
Source: https://docs.phantom.com/ethereum-monad-testnet-base-and-polygon/signing-a-message



When a web application is connected to Phantom, it can also request that the user signs a given message. Applications are free to write their own messages which will be displayed to users from within Phantom's signature prompt. Message signatures do not involve network fees and are a convenient way for apps to verify ownership of an address. To learn how you can use libraries such as [ethers.js](https://docs.ethers.org/v5/) to abstract away some of these intricacies, see [handleSignMessage](https://github.com/phantom-labs/eth_sandbox/blob/main/src/App.tsx#L193-L211) in our sandbox.

```javascript
const message = 'To avoid digital dognappers, sign below to authenticate with CryptoCorgis.';
const from = accounts[0];
const msg = `0x${Buffer.from(message, 'utf8').toString('hex')}`;
const sign = await provider.request({
        method: 'personal_sign',
        params: [msg, from, 'Example password'],
    });
```

## Support for "Sign-In with" standards

Applications that rely on signing messages to authenticate users can choose to opt-in to one of the various "Sign-In with" (SIW) standards. For more details, see [Sign-In with (SIW) standards](../developer-powertools/signing-a-message).


# Introduction
Source: https://docs.phantom.com/introduction



**Phantom** is a crypto wallet that can be used to manage digital assets and access decentralized applications on [Solana](https://solana.com/), [Bitcoin](https://bitcoin.org/), [Ethereum](https://ethereum.org/en/), [Base](https://www.base.org/), [Sui](https://sui.io), [Monad](https://www.monad.xyz), and [Polygon](https://polygon.technology/).

Phantom is currently available as:

* A [browser extension](https://phantom.app/download)
* An [iOS app](https://apps.apple.com/us/app/phantom-solana-wallet/id1598432977)
* An [Android app](https://play.google.com/store/apps/details?id=app.phantom)

At its core, Phantom works by creating and managing private keys on behalf of its users. These keys can then be used within Phantom to store funds and sign transactions.

Developers can interact with Phantom via both **web** applications as well as **iOS and Android** applications.

To interact with web applications, the Phantom extension and mobile in-app browser injects a `phantom` object into the JavaScript context of every site the user visits. A given web app may then interact with Phantom, and ask for the user's permission to perform transactions, through this injected provider.

It's also possible to interact with the Phantom mobile app through [universal links and deeplinks](/phantom-deeplinks/deeplinks-ios-and-android) (Solana only). With deeplinks, mobile apps can prompt their users to connect, sign, and send with Phantom directly. Once complete, Phantom will redirect users back to their referring applications.

This documentation is intended for developers who are building applications with Phantom. If you are a developer looking for help with an integration, check out our [developer forums on GitHub](https://github.com/orgs/phantom/discussions) or submit a request using this [form](https://docs.google.com/forms/d/e/1FAIpQLSeHWETFkEJbHQCF-lnl1AHmVQPuyfC0HbnxjDjIp6VYV1sBZQ/viewform). For all other support requests, visit our [Help Center](https://help.phantom.app/).


# Phantom deep links
Source: https://docs.phantom.com/phantom-deeplinks/deeplinks-ios-and-android



As of Phantom `v22.04.11`, iOS and Android apps can now natively interact with Phantom through either [universal links](https://developer.apple.com/ios/universal-links/) (recommended) or [deeplinks](https://en.wikipedia.org/wiki/Mobile_deep_linking). We refer to both of these workflows collectively as "deeplinks".

Currently only Solana is supported for deeplinks.

All [provider methods](/phantom-deeplinks/provider-methods/README) follow a protocol format of:

```
https://phantom.app/ul/<version>/<method>
```

It is also possible (but not recommended) to call these methods using Phantom's custom protocol handler:

```
phantom://<version>/<method>
```

In addition to these provider methods, Phantom also supports [other methods](/phantom-deeplinks/other-methods/README) that are accessible via deeplinks. Specifically, users can open web apps within Phantom's in-app browser via the [Browse](/phantom-deeplinks/other-methods/browse) deeplink.


# Encryption
Source: https://docs.phantom.com/phantom-deeplinks/encryption



Deeplinks are encrypted using symmetric key encryption generated from a [Diffie-Hellman key exchange](https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange). While deeplink sessions will be created in plaintext, an encrypted channel will be created to prevent session tokens from getting hijacked.

## Encryption and decryption workflow

Phantom deeplinks are encrypted with the following workflows:

### Connect

1. **\[dapp]:** On the initial [connect deeplink](/phantom-deeplinks/provider-methods/connect), dapps should include a `dapp_encryption_public_key` query parameter. It's recommended to create a new x25519 keypair for every session started with `connect`. In all methods, the public key for this keypair is referred to as `dapp_encryption_public_key`.
2. **\[phantom]:** Upon handling a `connect` deeplink, Phantom will also generate a new x25519 keypair.
   * Phantom will return this public key as `phantom_encryption_public_key` in the `connect` response.
   * Phantom will create a secret key using Diffie-Hellman with `dapp_encryption_public_key` and the ***private key*** associated with `phantom_encryption_public_key`.
   * Phantom will locally store a mapping of `dapp_encryption_public_key` to shared secrets for use with decryption in subsequent deeplinks.
3. **\[dapp]:** Upon receiving the `connect` response, the dapp should create a shared secret by using Diffie-Hellman with `phantom_encryption_public_key` and the ***private key*** associated with `dapp_encryption_public_key`. This shared secret should then be used to decrypt the `data` field in the response. If done correctly, the user's public key will be available to share with the dapp inside the `data` JSON object.

### Subsequent deeplinks

1. **\[dapp]:** For any subsequent methods (such as [SignTransaction](/phantom-deeplinks/provider-methods/signtransaction) and [SignMessage](/phantom-deeplinks/provider-methods/signmessage)), dapps should send a `dapp_encryption_public_key` (the public key side of the shared secret) used with Phantom along with an encrypted `payload` object.
2. **\[phantom]:** Upon approval, Phantom will encrypt the signed response as a JSON object with the encryption sent as a `data=` query param.
3. **\[dapp]:** Upon receiving the deeplink response, dapps should decrypt the object in the `data=` query param to view the signature.

## Encryption resources

To learn more about encryption and decryption, please refer to the following libraries:

### JavaScript

[TweetNaCl.js](https://github.com/dchest/tweetnacl-js)

### iOS

[TweetNaCl SwiftWrap](https://github.com/bitmark-inc/tweetnacl-swiftwrap)

### Android

* [Tink](https://github.com/google/tink)
* [TweetNaCl Java](https://github.com/InstantWebP2P/tweetnacl-java)


# Handle sessions
Source: https://docs.phantom.com/phantom-deeplinks/handling-sessions



When a user [connects to Phantom](/phantom-deeplinks/provider-methods/connect) for the first time, Phantom will return a `session` param that represents the user's connection. The app should pass this `session` param back to Phantom on all subsequent [provider methods](provider-methods/). It is the app's responsibility to store this `session`.

Sessions do not expire. Once a user has connected with Phantom, the corresponding app can indefinitely make requests such as [SignTransaction](/phantom-deeplinks/provider-methods/signtransaction) and [SignMessage](/phantom-deeplinks/provider-methods/signmessage) without prompting the user to re-connect with Phantom. Apps will still need to re-connect to Phantom after a [disconnect](/phantom-deeplinks/provider-methods/disconnect) event or an [invalid session](/phantom-deeplinks/handling-sessions).

## Session structure

The entire `session` param is encoded in base58. A `session` should contain the following data:

* **JSON Data Signature**: A base58 signature of the JSON data that is 64 bytes. Phantom will check the signature against the actual message that was signed.
* **JSON Data**: A JSON object with the following fields:
  * `app_url` (string): A URL used to fetch app metadata (such as title and icon) using the same properties found in [Display your app](/best-practices/displaying-your-app).
  * `timestamp` (number): The timestamp at which the user approved the connection. At the time of this writing, sessions do not expire.
  * `chain` (string): The chain that the user connected to at the start of the session. Sessions can't be used across two different chains with the same keypair (for example, the user can't connect to Solana and then sign on Ethereum). At the time of this writing, Phantom only supports `solana`.
  * `cluster` (string) (optional): The approved cluster that the app and user initially connected to. Solana-only. Can be either: `mainnet-beta`, `testnet`, or `devnet`. Defaults to `mainnet-beta`.

## Decode sessions

Phantom will decode and validate the `session` param on every request. To decode the session, we decode it with `bs58`, slice off the first 64 bytes of the signature, and the treat the rest as JSON data. We then sign the JSON data again with the same keypair and compare that signature against the signature in the session. If the signatures are the same, the session is valid. Otherwise, we conclude that the session has been faked, as the signature does not belong to the keypair it claims it does.

<Info>
  Calling `nacl.sign.open` conveniently verifies and returns the original object. For more information, please review [Encryption resources](/phantom-deeplinks/encryption).
</Info>

After we determine that the session is valid, we still need to ensure that the JSON fields line up with what we expect. An app could give a session for `pubkey A` when the user is currently using `pubkey B` in Phantom. In such a scenario, that session should not allow an app to request signatures. Instead, the app must issue a new connect request or use the correct session.

```javascript
// Encoding a session
const privateKey = ...;
const sessionData = JSON.stringify({
  "app_id": "APP_ID",
  "chain": "CHAIN",
  "cluster": "CLUSTER",
  "timestamp": 1644954984,
});
const bytes = Buffer.from(sessionData, "utf-8");

// tweetnacl-js formats signature in format <signature><sessionData>
const signature = bs58.encode(nacl.sign(bytes, privateKey));

// Decoding ja session
const publicKey = ...;
const verifiedSessionData = nacl.sign.open(bs58.decode(signature), publicKey.toBytes());
if (!verifiedSessionData) throw new Error(`This session was not signed by ${publicKey}`);
```

## Invalid sessions

While sessions do not expire, there are a number of reasons why a sessions could still be deemed invalid:

1. It was not signed by the current wallet keypair. This could mean that the session is entirely fake, or that it was signed by another keypair in the user's wallet.
2. It was signed by the current wallet keypair, but the session's JSON `data` does not pass muster. There are a few reasons why this might occur:
   1. The user switched chains (or possibly networks).
   2. The `app_url` could be blocked if malicious. For more information, see [Blocklist](/developer-powertools/blocklist).

<Info>
  You must pass the session token for all requests or Phantom will redirect the user back to your app and a new session will be created.
</Info>


# Limitations
Source: https://docs.phantom.com/phantom-deeplinks/limitations



## Android

Android has a 500kb transaction limit when passing data between services and apps. The requesting app may crash with a `TransactionTooLarge` exception when requesting a string over 500kb (over 31k characters). This tends to happen with significantly large intents.

## iOS

iOS is not known to have a 500kb transaction and allows [transmissions up to 1 MB](https://github.com/zoul/ios-url-scheme-length-limit/blob/master/Transmitter/ViewController.swift).


# Other methods
Source: https://docs.phantom.com/phantom-deeplinks/other-methods/README



In addition to its [provider methods](/phantom-deeplinks/provider-methods/README), Phantom also supports other methods that are accessible via deeplinks. Specifically, users can open web apps within Phantom's in-app browser via the [Browse](/phantom-deeplinks/other-methods/browse) deeplink.


# Browse
Source: https://docs.phantom.com/phantom-deeplinks/other-methods/browse



Deeplinks provide a convenient way for users to open web apps within Phantom. Using their phone's camera, users can scan a QR code to open a page directly within Phantom's in-app browser. If a web app detects that a user is on mobile, it can also prompt the user to open a specific page within Phantom's in-app browser.

The `browse` deeplink can be used before a [Connect](/phantom-deeplinks/provider-methods/connect) event takes places, as it does not require a `session` param.

<Info>
  The `browse` deeplinks are not intended to be pasted into mobile web browsers. These deeplinks must either be handled by an app or clicked on by an end user.
</Info>

## URL structure

```
https://phantom.app/ul/browse/<url>?ref=<ref>
```

## Parameters

* `url` (required): The URL that should open within Phantom's in-app browser, URL-encoded.
* `ref` (required): The URL of the requesting app, URL-encoded.

## Example

The following is an example request to open an [NFT listed on Magic Eden](https://magiceden.io/item-details/8yjN8iRuoiYiKW487cnW9vn6mLBR5E8aCNKsBRmTP9vN):

```
https://phantom.app/ul/browse/https%3A%2F%2Fmagiceden.io%2Fitem-details%2F8yjN8iRuoiYiKW487cnW9vn6mLBR5E8aCNKsBRmTP9vN?ref=https%3A%2F%2Fmagiceden.io
```


# Fungible
Source: https://docs.phantom.com/phantom-deeplinks/other-methods/fungible



Phantom supports deeplinking directly to a fungible token detail page. Developers can specify which chain and token detail page to navigate to. The `fungible` deeplink can be used at anytime. It does not need to be proceeded by a [Connect](/phantom-deeplinks/provider-methods/connect) event, as it does not require a `session` param.

## URL structure

```
https://phantom.app/ul/v1/fungible?token=<fungible>
```

## Parameters

`fungible` (required): The [CAIP-19](https://github.com/ChainAgnostic/CAIPs/blob/main/CAIPs/caip-19) address of the token page to be viewed, URL-encoded. Defaults to `SOL` if omitted.

## Example

```
https://phantom.app/ul/v1/fungible?token=solana%3A101%2Faddress%3AFoXyMu5xwXre7zEoSvzViRk3nGawHUp9kUh97y2NDhcq
```

![Fungible Example Gi](https://mintlify.s3.us-west-1.amazonaws.com/phantom-e50e2e68/phantom-deeplinks/images/fungible-example.gif)


# Swap
Source: https://docs.phantom.com/phantom-deeplinks/other-methods/swap



<Tip>
  Watch [Swap demo](https://youtu.be/qJNv7lpYmtw) on YouTube.
</Tip>

Phantom supports deeplinking directly to the in-app swapper. Developers can specify which tokens should be prefilled in the `buy` and `sell` fields. In addition to swapping tokens on a single chain, the swapper can also be used to bridge stablecoins across chains, such as USDT on Ethereum to USDC on Solana.

The `swap` deeplink can be used at anytime. It does not need to be proceeded by a [Connect](/phantom-deeplinks/provider-methods/connect) event, as it does not require a `session` param.

<Info>
  The `swap` deeplinks are not intended to be pasted into mobile web browsers. These deeplinks must either be handled by an app or tapped on by an end user.
</Info>

## URL structure

```
https://phantom.app/ul/v1/swap?buy=<buy>&sell=<sell>
```

## Parameters

* `buy`: The [CAIP-19](https://github.com/ChainAgnostic/CAIPs/blob/main/CAIPs/caip-19.md) address of the token that should be bought, URL-encoded. Defaults to SOL if omitted.
* `sell`: The [CAIP-19](https://github.com/ChainAgnostic/CAIPs/blob/main/CAIPs/caip-19.md) address of the token that should be sold, URL-encoded. Defaults to SOL if omitted.

## Examples

Using a mobile device, tap the following links to try out the `swap` deeplink:

### Swap SOL to WIF

```
https://phantom.app/ul/v1/swap/?buy=solana%3A101%2Faddress%3AEKpQGSJtjMFqKZ9KQanSqYXRcF8fBopzLHYxdM65zcjm&sell=
```

### Bridge USDC on Solana to USDT on Ethereum

```
https://phantom.app/ul/v1/swap/?buy=eip155%3A1%2Faddress%3A0xdAC17F958D2ee523a2206206994597C13D831ec7&sell=solana%3A101%2Faddress%3AEPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v
```


# Provider methods
Source: https://docs.phantom.com/phantom-deeplinks/provider-methods/README



All provider methods follow a protocol format of:

```
https://phantom.app/ul/<version>/<method>
```

The following provider methods are accessible via deeplinks:

* [Connect](/phantom-deeplinks/provider-methods/connect)
* [Disconnect](/phantom-deeplinks/provider-methods/disconnect)
* [SignAndSendTransaction](/phantom-deeplinks/provider-methods/signandsendtransaction)
* [SignAllTransactions](/phantom-deeplinks/provider-methods/signalltransactions)
* [SignTransaction](/phantom-deeplinks/provider-methods/signtransaction)
* [SignMessage](/phantom-deeplinks/provider-methods/signmessage)


# Connect
Source: https://docs.phantom.com/phantom-deeplinks/provider-methods/connect



In order to start interacting with Phantom, an app must first establish a connection. This connection request will prompt the user for permission to share their public key, indicating that they are willing to interact further.

Once a user connects to Phantom, Phantom will return a `session` param that should be used on all subsequent methods. For more information on sessions, see [Handle sessions](../handling-sessions).

## Base URL

```
https://phantom.app/ul/v1/connect
```

## Query string parameters

* `app_url` (required): A URL used to fetch app metadata (such as title or icon) using the same properties found in [Display your app](../../best-practices/displaying-your-app). URL-encoded.
* `dapp_encryption_public_key` (required): A public key used for end-to-end encryption. This will be used to generate a shared secret. For more information on how Phantom handles shared secrets, see [Encryption](../encryption).
* `redirect_link` (required): The URI where Phantom should redirect the user upon connection. For more details, see [Specify redirects](../specifying-redirects). URL-encoded.
* `cluster` (optional): The network that should be used for subsequent interactions. Can be either: `mainnet-beta`, `testnet`, or `devnet`. Defaults to `mainnet-beta`.

## Returns

### Approve

* `phantom_encryption_public_key`: An encryption public key used by Phantom for the construction of a shared secret between the connecting app and Phantom, encoded in base58.
* `nonce`: A nonce used for encrypting the response, encoded in base58.
* `data`: An encrypted JSON string. Refer to [Encryption](../encryption) to learn how apps can decrypt `data` using a shared secret. Encrypted bytes are encoded in base58.

  ```json
  // content of decrypted `data`-parameter
  {
    // base58 encoding of user public key
    "public_key": "BSFtCudCd4pR4LSFqWPjbtXPKSNVbGkc35gRNdnqjMCU",

    // session token for subsequent signatures and messages
    // dapps should send this with any other deeplinks after connect
    "session": "..."
  }
  ```

  * `public_key`: The public key of the user, represented as a base58-encoded string.
  * `session`: A string encoded in base58. This should be treated as opaque by the connecting app, as it only needs to be passed alongside other parameters. Sessions do not expire. For more details, see [Handle sessions](../handling-sessions).

### Reject

An `errorCode` and `errorMessage` as query parameters. For a full list of possible error codes, see [Errors](../../solana/errors).

```
{
  "errorCode": "...",
  "errorMessage": "..."
}
```

## Example

Refer to the [connect](https://github.com/phantom-labs/deep-link-demo-app/blob/20f19f2154e98699f0d5a6b28bc4bb3d5acbcefd/App.tsx#L175) method implemented in our React Native demo application.


# Disconnect
Source: https://docs.phantom.com/phantom-deeplinks/provider-methods/disconnect



After an initial [Connect](/phantom-deeplinks/provider-methods/connect) event has taken place, an app may disconnect from Phantom at anytime. Once disconnected, Phantom will reject all signature requests until another connection is established.

## Base URL

```
https://phantom.app/ul/v1/disconnect
```

## Query string parameters

* `dapp_encryption_public_key` (required): The original encryption public key used from the app side for an existing [Connect](/phantom-deeplinks/provider-methods/connect) session.
* `nonce` (required): A nonce used for encrypting the request, encoded in base58.
* `redirect_link` (required): The URI where Phantom should redirect the user upon completion. For more details, see [Specify redirects](../specifying-redirects). URL-encoded.
* `payload` (required): An encrypted JSON string with the following fields:

  ```json
  {
      "session": "...", // token received from the connect method
  }
  ```

  * `session` (required): The session token received from the [Connect](/phantom-deeplinks/provider-methods/connect) method. For more details, see [Handle sessions](../handling-sessions).

## Returns

### Approve

No query params returned.

### Reject

An `errorCode` and `errorMessage` as query parameters. For a full list of possible error codes, see [Errors](../../solana/errors).

```
{
  "errorCode": "...",
  "errorMessage": "..."
}
```

## Example

Refer to the [disconnect](https://github.com/phantom-labs/deep-link-demo-app/blob/20f19f2154e98699f0d5a6b28bc4bb3d5acbcefd/App.tsx#L187) method implemented in our React Native demo application.


# SignAllTransactions
Source: https://docs.phantom.com/phantom-deeplinks/provider-methods/signalltransactions



Once an app is connected, it is also possible to sign multiple transactions at once. Phantom will not submit these transactions to the network. Applications can submit signed transactions using [sendRawTransaction](https://solana-foundation.github.io/solana-web3.js/classes/Connection.html#sendrawtransaction) in web3.js.

## Base URL

```[expandable]
https://phantom.app/ul/v1/signAllTransactions
```

## Query string parameters

* `dapp_encryption_public_key` (required): The original encryption public key used from the app side for an existing [Connect](/phantom-deeplinks/provider-methods/connect) session.
* `nonce` (required): A nonce used for encrypting the request, encoded in base58.
* `redirect_link` (required): The URI where Phantom should redirect the user upon completion. For more details, see [Specify redirects](../specifying-redirects). URL-encoded.
* `payload` (required): An encrypted JSON string with the following fields:

  ```json
  {
    "transactions": [
      "...", // serialized transaction, bs58-encoded
      "...", // serialized transaction, bs58-encoded
    ],
    "session": "...", // token received from connect-method
  }
  ```

  * `transactions` (required): An array of [transactions](https://solana-foundation.github.io/solana-web3.js/classes/Transaction.html) that Phantom will sign, serialized and encoded in base58.
  * `session` (required): The session token received from the [Connect](/phantom-deeplinks/provider-methods/connect) method. For more details, see [Handle sessions](../handling-sessions).

## Returns

### Approve

* `nonce`: A nonce used for encrypting the response, encoded in base58.
* `data`: An encrypted JSON string. Refer to [Encryption](../encryption) to learn how apps can decrypt `data` using a shared secret. Encrypted bytes are encoded in base58.

  ```json
  // content of decrypted `data`-parameter
  {
      transactions: [
          "...", // signed serialized transaction, bs58-encoded
          "...", // signed serialized transaction, bs58-encoded
      ] 
  }
  ```

  * `transactions`: An array of signed, serialized transactions that are base58 encoded. Phantom will not submit these transactions. Applications can submit these transactions themselves using [sendRawTransaction](https://solana-foundation.github.io/solana-web3.js/classes/Connection.html#sendRawTransaction) in web3.js.

### Reject

An `errorCode` and `errorMessage` as query parameters. For a full list of possible error codes, see [Errors](../../solana/errors).

```
{
  "errorCode": "...",
  "errorMessage": "..."
}
```

## Example

Refer to the [signAllTransactions](https://github.com/phantom-labs/deep-link-demo-app/blob/20f19f2154e98699f0d5a6b28bc4bb3d5acbcefd/App.tsx#L229) method implemented in our React Native demo application.


# SignAndSendTransaction (deprecated)
Source: https://docs.phantom.com/phantom-deeplinks/provider-methods/signandsendtransaction



The `signAndSendTransaction` deeplink has been deprecated. Use the [signAllTransactions](/phantom-deeplinks/provider-methods/signalltransactions) or [signTransaction](/phantom-deeplinks/provider-methods/signtransaction) deeplink instead.


# SignMessage
Source: https://docs.phantom.com/phantom-deeplinks/provider-methods/signmessage



Once it's connected to Phantom, an app can request that the user signs a given message. Applications are free to write their own messages which will be displayed to users from within Phantom's signature prompt. Message signatures do not involve network fees and are a convenient way for apps to verify ownership of an address.

In order to send a message for the user to sign, an application must:

1. Provide a **hex** or **UTF-8** encoded string as a Uint8Array and then **base58-encoded it**.
2. Request that the encoded message is signed via the user's Phantom wallet.

The [deeplinking demo app](/resources/sandbox) provides an example of signing a message.

<Info>
  The message to be signed must be passed as a base58-encoded string. For more information on how to verify the signature of a message, please refer to [Encryption resources](/phantom-deeplinks/encryption).
</Info>

## Base URL

```
https://phantom.app/ul/v1/signMessage
```

## Query string parameters

* `dapp_encryption_public_key` (required): The original encryption public key used from the app side for an existing [Connect](/phantom-deeplinks/provider-methods/connect) session.
* `nonce` (required): A nonce used for encrypting the request, encoded in base58.
* `redirect_link` (required): The URI where Phantom should redirect the user upon completion. For more details, see [Specify redirects](/phantom-deeplinks/specifying-redirects). URL-encoded.
* `payload` (required): An encrypted JSON string with the following fields:

  ```json
  {
    "message": "...", // the message, base58 encoded
    "session": "...", // token received from connect-method
    "display": "utf8" | "hex", // the encoding to use when displaying the message 
  }
  ```

  * `message` (required): The message that should be signed by the user, encoded in base58. Phantom will display this message to the user when they are prompted to sign.
  * `session` (required): The session token received from the [Connect](/phantom-deeplinks/provider-methods/connect) method. For more details, see [Handle sessions](../handling-sessions).
  * `display` (optional): How you want us to display the string to the user. Defaults to `utf8`.

## Returns

### Approve

* `nonce`: A nonce used for encrypting the response, encoded in base58.
* `data`: An encrypted JSON string. Refer to [Encryption](/phantom-deeplinks/encryption) to learn how apps can decrypt `data` using a shared secret. Encrypted bytes are encoded in base58.

  ```json
  // content of decrypted `data`-parameter
  {
      signature: "...", // message-signature
  }
  ```

  * `signature`: The message signature, encoded in base58. For more information on how to verify the signature of a message, see [Encryption resources](/phantom-deeplinks/encryption).

### Reject

An `errorCode` and `errorMessage` as query parameters. For a full list of possible error codes, see [Errors](/solana/errors).

```
{
  "errorCode": "...",
  "errorMessage": "..."
}
```

## Example

Refer to the [signMessage](https://github.com/phantom-labs/deep-link-demo-app/blob/20f19f2154e98699f0d5a6b28bc4bb3d5acbcefd/App.tsx#L290) method implemented in our React Native demo application.


# SignTransaction
Source: https://docs.phantom.com/phantom-deeplinks/provider-methods/signtransaction



Request Phantom to sign the prepared transaction and return the signature. After receiving the signature, your app can broadcast the transaction itself with [sendRawTransaction](https://solana-foundation.github.io/solana-web3.js/classes/Connection.html#sendRawTransaction) in web3.js, giving you full control over timing, batching, or custom error handling.

## Base URL

```
https://phantom.app/ul/v1/signTransaction
```

## Query string parameters

* `dapp_encryption_public_key` (required): The original encryption public key used from the app side for an existing [Connect](/phantom-deeplinks/provider-methods/connect) session.
* `nonce` (required): A nonce used for encrypting the request, encoded in base58.
* `redirect_link` (required): The URI where Phantom should redirect the user upon completion. For more details, see [Specify redirects](/phantom-deeplinks/specifying-redirects). URL-encoded.
* `payload` (required): An encrypted JSON string with the following fields:

  ```json
  {
    "transaction": "...", // serialized transaction, base58 encoded
    "session": "...", // token received from connect-method
  }
  ```

  * `transaction` (required): The [transaction](https://solana-foundation.github.io/solana-web3.js/classes/Transaction.html) that Phantom will sign, serialized and encoded in base58.
  * `session` (required): The session token received from the [Connect](/phantom-deeplinks/provider-methods/connect) method. For more details, see [Handle sessions](/phantom-deeplinks/handling-sessions).

## Returns

### Approve

* `nonce`: A nonce used for encrypting the response, encoded in base58.
* `data`: An encrypted JSON string. Refer to [Encryption](/phantom-deeplinks/encryption) to learn how apps can decrypt `data` using a shared secret. Encrypted bytes are encoded in base58.

  ```json
  // content of decrypted `data`-parameter
  {
      transaction: "...", // signed serialized transaction, base58 encoded
  }
  ```

  * `transaction`: The signed, serialized transaction that is base58 encoded. Phantom will not submit this transactions. An application can submit this transactions itself using `sendRawTransaction` in [web3.js](https://solana-foundation.github.io/solana-web3.js/classes/Connection.html#sendRawTransaction).

### Reject

An `errorCode` and `errorMessage` as query parameters. For a full list of possible error codes, see [Errors](/solana/errors).

```
{
  "errorCode": "...",
  "errorMessage": "..."
}
```

## Example

Refer to the [signTransaction](https://github.com/phantom-labs/deep-link-demo-app/blob/20f19f2154e98699f0d5a6b28bc4bb3d5acbcefd/App.tsx#L262) method implemented in our React Native demo application.


# Specifying redirects
Source: https://docs.phantom.com/phantom-deeplinks/specifying-redirects



All [methods](/phantom-deeplinks/provider-methods/README) support a `redirect_link=` param that lets Phantom know how to get back to the original app. The URI specified by this param should be URL encoded. The following is an example for a `mydapp://onPhantomConnected` redirect URI:

```
redirect_link%3Dmydapp%3A%2F%2FonPhantomConnected
```

If the deeplink request to Phantom comes with a response, Phantom will append the results as query parameters in the `redirect_link=` upon redirecting.

```
redirect_link=mydapp://onPhantomConnected?data=...
```


# Logos and assets
Source: https://docs.phantom.com/resources/assets



A variety of Phantom logos and assets for your integration can be found here: [Phantom integration assets](https://187760183-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2F-MVOiF6Zqit57q_hxJYp%2Fuploads%2F76nE5VTUa3iCCzwlkEbC%2FPhantom-Integration-Assets.zip?alt=media\&token=b91a3de7-3f28-4b78-a17c-5d36f4f6ee01).

When integrating Phantom, please refer to our attachphaed style guide. For most dapp integrations, we recommend using the following icon in SVG or PNG format:

![Phantom SVG Icon Sv](https://mintlify.s3.us-west-1.amazonaws.com/phantom-e50e2e68/resources/images/Phantom_SVG_Icon.svg)


# FAQ
Source: https://docs.phantom.com/resources/faq



## Why can't I access Phantom on my website?

Phantom will only [inject its provider](/solana/detecting-the-provider) into websites that begin with `https://`, or if the host is `localhost` or `127.0.0.1`. If your website only uses `http://`, Phantom will not inject its provider and you will not be able to access the methods found at `window.phantom`. Encrypting your web traffic and upgrading to `https://` will restore functionality.

Phantom will also not inject its provider into any [iframe](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe).

## Why isn't my token displaying properly?

Phantom supports the [Token Metadata Standard](https://developers.metaplex.com/token-metadata/token-standard) established by [Metaplex](https://www.metaplex.com/). When displaying tokens, Phantom will first [categorize](/best-practices/tokens/README) them according to their [TokenStandard](https://developers.metaplex.com/token-metadata/token-standard). If a token is considered `Fungible`, Phantom will display it on the [Home tab](/best-practices/tokens/home-tab-fungibles). Otherwise, Phantom will display it as a [Collectible](/best-practices/tokens/collectibles-nfts-and-semi-fungibles). For more details, see [Token Display documentation](/best-practices/tokens/README).

## What types of NFTs are supported?

Phantom supports a range of NFT media types including images, audio files, video files, and 3D models. At this time, Phantom does not support HTML files. For a full list of the types of NFTs that Phantom can display, see [Supported media types](/best-practices/tokens/supported-media-types).

## Are hardware wallets supported?

Yes, Phantom currently supports [Ledger](https://www.ledger.com/) and requires no special treatment on the application side.

## How does Phantom import wallet addresses?

When importing addresses from an existing seed phrase, Phantom will scan for 20 addresses in each of our three supported derivation paths (`bip44change`, `bip44`, and a deprecated path), for a total of 60 addresses. For the convenience of the user, Phantom will filter this list of addresses down to wallets that have ever had signatures (have ever been used). Phantom will then sort this filtered list based on how many signatures each wallet has had plus the amount of [lamports](https://docs.solana.com/terminology#lamport) it currently owns.

## Why does Phantom prepend an additional instruction on standard SPL token transfers?

When transferring SPL tokens, Phantom will first double check if a token account exists for the recipient you are sending to. If one does not exist, Phantom will help you create an Associated Token Account on the recipient's behalf. To do this check, Phantom calls a deployment of the [Serum Assert Owner](https://github.com/project-serum/serum-dex/tree/6138ca98280f6433deecde560f3d23cc4a749bae/assert-owner) program. The program address of this deployment is `DeJBGdMFa1uynnnKiwrVioatTuHmNLpyFKnmB5kaFdzQ` and is available on Solana's Devnet, Testnet, and Mainnet. This program has been in use since 2021. It was deployed by the Phantom team to keep this program address consistent across networks.


# Demo applications
Source: https://docs.phantom.com/resources/sandbox



## Multi-chain sandbox

For a live example of how a multichain dApp can integrate with Phantom, check out our Multichain Sandbox on [CodeSandbox](https://472igc.csb.app/) and [GitHub](https://github.com/phantom-labs/multi-chain-sandbox).

## Solana-only sandbox

For a live example of a Solana-only integration, check out our [Solana Sandbox](https://github.com/phantom-labs/sandbox) on GitHub.

## Deeplinking demo app

For a live demonstration of Phantom's deeplinking API, see our [React Native demo application](https://github.com/phantom-labs/deep-link-demo-app). This application can be run locally and interacted with on iOS and Android devices via [Expo CLI](https://docs.expo.dev/workflow/expo-cli/).


# Detect the provider
Source: https://docs.phantom.com/solana/detecting-the-provider

To detect if a user has already installed Phantom, a web application should check for the existence of a phantom object.

To detect if a user has already installed Phantom, a web application should check for the existence of a `phantom` object. Phantom's browser extension and mobile in-app browser will both inject a `phantom` object into the [window](https://developer.mozilla.org/en-US/docs/Web/API/Window) of any web application the user visits, provided that site is using `https://`, on `localhost`, or is `127.0.0.1.` Phantom will not inject the provider into [iframes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe) or sites that use `http://`.

If a `phantom` object exists, Solana apps can interact with Phantom via the API found at `window.phantom.solana`. This `solana` object is also available at `window.solana` to support legacy integrations.

To detect if Phantom is installed, an application should check for an additional `isPhantom` flag.

```typescript
const isPhantomInstalled = window.phantom?.solana?.isPhantom
```

If Phantom is not installed, we recommend you redirect your users to `https://phantom.com/`. Altogether, this may look like the following:

```typescript
const getProvider = () => {
  if ('phantom' in window) {
    const provider = window.phantom?.solana;

    if (provider?.isPhantom) {
      return provider;
    }
  }

  window.open('https://phantom.app/', '_blank');
};
```

For an example of how a React application can detect Phantom, refer to [getProvider](https://github.com/phantom-labs/sandbox/blob/b57fdd0e65ce4f01290141a01e33d17fd2f539b9/src/App.tsx#L43) in our sandbox.


# Error messages and codes
Source: https://docs.phantom.com/solana/errors



When making requests to Phantom in [establishing a connection](/solana/establishing-a-connection), [sending a transaction](/solana/sending-a-transaction), or [signing a message](/solana/signing-a-message), Phantom may respond with an error. The following is a list of all possible error codes and their meanings. These error messages are inspired by Ethereum's [EIP-1474](https://eips.ethereum.org/EIPS/eip-1474#error-codes) and [EIP-1193](https://eips.ethereum.org/EIPS/eip-1193#provider-errors).

| Code   | Title                            | Description                                                                                                                                                                                                                                                                          |
| ------ | -------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| 4900   | Disconnected                     | Phantom could not connect to the network.                                                                                                                                                                                                                                            |
| 4100   | Unauthorized                     | The requested method and/or account has not been authorized by the user.                                                                                                                                                                                                             |
| 4001   | User Rejected Request            | The user rejected the request through Phantom.                                                                                                                                                                                                                                       |
| -32000 | Invalid Input                    | Missing or invalid parameters.                                                                                                                                                                                                                                                       |
| -32002 | Requested resource not available | This error occurs when a dapp attempts to submit a new transaction while Phantom's approval dialog is already open for a previous transaction. Only one approve window can be open at a time. Users should  approve or reject their transaction before initiating a new transaction. |
| -32003 | Transaction Rejected             | Phantom does not recognize a valid transaction.                                                                                                                                                                                                                                      |
| -32601 | Method Not Found                 | Phantom does not recognize the method.                                                                                                                                                                                                                                               |
| -32603 | Internal Error                   | Something went wrong within Phantom.                                                                                                                                                                                                                                                 |

Typically, these errors will be easily parseable and have both a code and an explanation. For example:

```javascript
try {
  await window.solana.signMessage();
} catch (err) {
  //  {code: 4100, message: 'The requested method and/or account has not been authorized by the user.'}
}
```


# Establish a connection
Source: https://docs.phantom.com/solana/establishing-a-connection



Once an application has [detected the provider](/solana/detecting-the-provider), it can then request to connect to Phantom. This connection request will prompt the user for permission to share their public key, indicating that they are willing to interact further. Users must approve a connection request before the app can make additional requests such as [signing a message](/solana/signing-a-message) or [sending a transaction](/solana/sending-a-transaction).

Once permission is established for the first time, the web application's domain will be whitelisted for future connection requests. After a connection is established, it is possible to terminate the connection from both the application and the user side.

## Connect

The **recommended** and **easiest** way to connect to Phantom is by calling `window.phantom.solana.connect()`. However, the provider also exposes a `request` JSON RPC interface.

### connect()

```javascript
const provider = getProvider(); // see "Detecting the Provider"
try {
    const resp = await provider.connect();
    console.log(resp.publicKey.toString());
    // 26qv4GCcx98RihuK3c4T6ozB3J7L6VwCuFVc7Ta2A3Uo 
} catch (err) {
    // { code: 4001, message: 'User rejected the request.' }
}
```

### request()

```javascript
const provider = getProvider(); // see "Detecting the Provider"
try {
    const resp = await provider.request({ method: "connect" });
    console.log(resp.publicKey.toString());
    // 26qv4GCcx98RihuK3c4T6ozB3J7L6VwCuFVc7Ta2A3Uo 
} catch (err) {
    // { code: 4001, message: 'User rejected the request.' }
}
```

The `connect()` call will return a [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) that resolves when the user accepts the connection request, and reject (throw when awaited) when the user declines the request or closes the pop-up. See [Errors](errors) for a breakdown of error messages Phantom may emit.

When the user accepts the request to connect, the provider will also emit a `connect` event.

```javascript
provider.on("connect", () => console.log("connected!"));
```

Once the web application is connected to Phantom, it will be able to read the connected account's public key and prompt the user for additional transactions. It also exposes a convenience `isConnected` boolean.

```javascript
console.log(provider.publicKey.toString());
// 26qv4GCcx98RihuK3c4T6ozB3J7L6VwCuFVc7Ta2A3Uo 
console.log(provider.isConnected);
// true
```

## Eagerly connecting

After a web application connects to Phantom for the first time, it becomes trusted. Once trusted, it's possible for the application to automatically connect to Phantom on subsequent visits or page refreshes, without prompting the user for permission. This is referred to as "eagerly connecting".

To implement this, applications should pass an `onlyIfTrusted` option into the `connect()` call.

### connect()

```javascript
provider.connect({ onlyIfTrusted: true });
```

### request()

```javascript
window.solana.request({ method: "connect", params: { onlyIfTrusted: true }});
```

If this flag is present, Phantom will only eagerly connect and emit a `connect` event if the application is trusted. If the application is not trusted, Phantom will throw a [4001 error](/solana/errors) and remain disconnected until the user is prompted to connect without an `onlyIfTrusted` flag. In either case, Phantom will not open a pop-up window, making this convenient to use on all page loads.

The following is an example of how a React application can eagerly connect to Phantom.

```javascript
import { useEffect } from "react";

useEffect(() => {
    // Will either automatically connect to Phantom, or do nothing.
    provider.connect({ onlyIfTrusted: true })
        .then(({ publicKey }) => {
            // Handle successful eager connection
        })
        .catch(() => {
            // Handle connection failure as usual
        })
}, []);
```

For a live demo, refer to the [handleConnect](https://github.com/phantom/sandbox/blob/b57fdd0e65ce4f01290141a01e33d17fd2f539b9/src/App.tsx#L263) function in our sandbox.

If a wallet disconnects from a trusted app and then attempts to reconnect at a later time, Phantom will still eagerly connect. Once an app is trusted, Phantom will only require the user to approve a connection request if the user revokes the app from within their **Trusted Apps** settings.

## Disconnect

Disconnecting mirrors the same process as connecting. However, it is also possible for the wallet to initiate the disconnection, rather than the application itself.

### disconnect()

```javascript
provider.disconnect();
```

### request()

```javascript
provider.request({ method: "disconnect" });
```

The following is an example of how a React application can [gracefully handle](https://github.com/phantom-labs/sandbox/blob/b57fdd0e65ce4f01290141a01e33d17fd2f539b9/src/App.tsx#L107) a `disconnect` event.

```javascript
import { useState, useEffect } from "react";

const [pubKey, setPubKey] = useState(null);

useEffect(() => {
  // Store user's public key once they connect
  provider.on("connect", (publicKey) => {
    setPubKey(publicKey);
  });

  // Forget user's public key once they disconnect
  provider.on("disconnect", () => {
    setPubKey(null);
  });
}, [provider]);
```

## Change accounts

Phantom allows users to seamlessly manage multiple accounts (such as [keypairs](https://solana-foundation.github.io/solana-web3.js/classes/Keypair.html)) from within a single extension or mobile app. Whenever a user switches accounts, Phantom will emit an `accountChanged` event.

If a user changes accounts while already connected to an application, and the new account had already whitelisted that application, then the user will stay connected and Phantom will pass the [PublicKey](https://solana-foundation.github.io/solana-web3.js/classes/PublicKey.html) of the new account:

```javascript
provider.on('accountChanged', (publicKey) => {
    if (publicKey) {
        // Set new public key and continue as usual
        console.log(`Switched to account ${publicKey.toBase58()}`);
    } 
});
```

If Phantom does not pass the public key of the new account, an application can either do nothing or attempt to reconnect:

```javascript
provider.on('accountChanged', (publicKey) => {
    if (publicKey) {
      // Set new public key and continue as usual
      console.log(`Switched to account ${publicKey.toBase58()}`);
    } else {
      // Attempt to reconnect to Phantom
      provider.connect().catch((error) => {
        // Handle connection failure
      });
    }
});
```


# Get started with Solana
Source: https://docs.phantom.com/solana/integrating-phantom

Learn how to integrate Phantom wallet with your Solana web application using direct integration or the Solana Wallet Adapter.

The Phantom browser extension and mobile in-app browser are both designed to interact with web applications. For mobile apps, we recommend integrating via [universal links or deeplinks](../phantom-deeplinks/deeplinks-ios-and-android).

There are two main ways to integrate Phantom into your web application:

## Direct integration

The most direct way to interact with Phantom is via the provider that Phantom injects into your web application. This provider is globally available at `window.phantom` and its methods will always include Phantom's most up-to-date functionality. This documentation is dedicated to covering all aspects of the provider.

## Solana Wallet Adapter

Another quick and easy way to get up and running with Phantom is via the [Solana Wallet Adapter](https://github.com/anza-xyz/wallet-adapter) package. The wallet adapter is a set of modular TypeScript components that allow developers to easily integrate multiple Solana wallets into their applications. This package includes starter files, setup and usage instructions, and a live demo showcasing multiple UI frameworks.


# Send a legacy transaction
Source: https://docs.phantom.com/solana/sending-a-transaction



Once a web application is connected to Phantom, it can prompt the user for permission to send transactions on their behalf.

In order to send a transaction, a web application must:

1. Create an unsigned transaction.
2. Have the transaction be signed and submitted to the network by the user's Phantom wallet.
3. Optionally await network confirmation using a Solana JSON RPC connection.

<Info>
  For more information about the nature of Solana transactions, refer to the [solana-web3.js](https://solana-foundation.github.io/solana-web3.js/) documentation and the [Solana Cookbook](https://solanacookbook.com/core-concepts/transactions.html#transactions).
</Info>

For a sample Phantom transaction, check out our [sandbox](https://github.com/phantom-labs/sandbox/blob/b57fdd0e65ce4f01290141a01e33d17fd2f539b9/src/App.tsx#L160).

## Sign and send a transaction

Once a transaction is created, the web application may ask the user's Phantom wallet to sign and send the transaction. If accepted, Phantom will sign the transaction with the user's private key and submit it via a Solana JSON RPC connection. By far the **easiest** and most **recommended** way of doing this is by using the `signAndSendTransaction` method on the provider, but it is also possible to do with `request`. In both cases, the call will return a [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) for an object containing the `signature`.

### signAndSendTransaction()

```javascript
const provider = getProvider(); // see "Detecting the Provider"
const network = "<NETWORK_URL>";
const connection = new Connection(network);
const transaction = new Transaction();
const { signature } = await provider.signAndSendTransaction(transaction);
await connection.getSignatureStatus(signature);
```

### request()

```javascript
const provider = getProvider(); // see "Detecting the Provider"
const network = "<NETWORK_URL>";
const connection = new Connection(network);
const transaction = new Transaction();
const { signature } = await provider.request({
    method: "signAndSendTransaction",
    params: {
         message: bs58.encode(transaction.serializeMessage()),
    },
});
await connection.getSignatureStatus(signature);
```

You can also specify a `SendOptions` [object](https://solana-foundation.github.io/solana-web3.js/modules.html#SendOptions) as a second argument into `signAndSendTransaction` or as an `options` parameter when using `request`.

For a live demo of `signAndSendTransaction`, refer to [handleSignAndSendTransaction](https://github.com/phantom-labs/sandbox/blob/b57fdd0e65ce4f01290141a01e33d17fd2f539b9/src/App.tsx#L160) in our sandbox.

## Sign and send multiple transactions

It is also possible to sign and send multiple transactions at once. This is exposed through the `signAndSendAllTransactions` method on the provider. This method accepts an array of Solana transactions, and will optionally accept a [SendOptions](https://solana-foundation.github.io/solana-web3.js/types/SendOptions.html) object as a second parameter. If successful, it will return a [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) for an object containing the array of string `signatures` and the `publicKey` of the signer.

### signAndSendAllTransactions()

```typescript
const provider = getProvider(); // see "Detecting the Provider"
const network = "<NETWORK_URL>";
const connection = new Connection(network);
const transactions = [new Transaction(), new Transaction()];
const { signatures, publicKey } = await provider.signAndSendAllTransactions(transactions);
await connection.getSignatureStatuses(signatures);
```

## Other signing methods

The following methods are also supported, but are not recommended over `signAndSendTransaction`. It is safer for users, and a simpler API for developers, for Phantom to submit the transaction immediately after signing it instead of relying on the application to do so.

<Warning>
  The following methods are not supported in the [wallet standard](#) implementation and may be removed in a future release. These methods are only available via the [window.solana object](/solana/detecting-the-provider).
</Warning>

## Sign a transaction (without sending)

Once a transaction is created, a web application may ask the user's Phantom wallet to sign the transaction *without* also submitting it to the network. The easiest and most recommended way of doing this is via the `signTransaction` method on the provider, but it is also possible to do via `request`. In both cases, the call will return a [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) for the signed transaction. After the transaction has been signed, an application may submit the transaction itself using [sendRawTransaction](https://solana-foundation.github.io/solana-web3.js/classes/Connection.html#sendRawTransaction) in web3.js.

### signTransaction()

```javascript
const provider = getProvider();
const network = "<NETWORK_URL>";
const connection = new Connection(network);
const transaction = new Transaction();
const signedTransaction = await provider.signTransaction(transaction);
const signature = await connection.sendRawTransaction(signedTransaction.serialize());
```

### request()

```javascript
const provider = getProvider();
const network = "<NETWORK_URL>";
const connection = new Connection(network);
const transaction = new Transaction();
const signedTransaction = await provider.request({
    method: "signTransaction",
    params: {
         message: bs58.encode(transaction.serializeMessage()),
    },
});
const signature = await connection.sendRawTransaction(signedTransaction.serialize());
```

For an example of `signTransaction`, refer to [handleSignTransaction](https://github.com/phantom-labs/sandbox/blob/b57fdd0e65ce4f01290141a01e33d17fd2f539b9/src/App.tsx#L187) in our sandbox.

## Sign multiple transactions

For legacy integrations, Phantom supports signing multiple transactions at once without sending them. This is exposed through the `signAllTransactions` method on the provider. This method is **not recommended** for new integrations. Instead, developers should make use of `signAndSendAllTransactions`.

### signAllTransactions()

```javascript
const signedTransactions = await provider.signAllTransactions(transactions);
```

### request()

```javascript
const message = transactions.map(transaction => {
    return bs58.encode(transaction.serializeMessage());
});
const signedTransactions = await provider.request({
    method: "signAllTransactions",
    params: { message },
});
```

For an example of `signAllTransactions`, refer to [handleSignAllTransactions](https://github.com/phantom-labs/sandbox/blob/b57fdd0e65ce4f01290141a01e33d17fd2f539b9/src/App.tsx#L213) in our sandbox.


# Send a versioned transaction
Source: https://docs.phantom.com/solana/sending-a-transaction-1



The Solana runtime supports two types of transactions: `legacy` (see [Send a legacy transaction](/solana/sending-a-transaction)) and `v0` (transactions that can include Address Lookup Tables or LUTs).

The goal of `v0` is to increase the maximum size of a transaction, and hence the number of accounts that can fit in a single atomic transaction. With LUTs, developers can now build transactions with a maximum of 256 accounts, as compared to the limit of 35 accounts in legacy transactions that do not utilize LUTs.

<Info>
  For a dive deep on versioned transactions, LUTs, and how the above changes affect the anatomy of a transaction, see [Versioned Transactions - Anvit Mangal's Blog](https://anvit.hashnode.dev/versioned-transactions).
</Info>

On this page, we'll go over the following:

1. Building a versioned tansaction.
2. Signing and sending a versioned transaction.
3. Building an Address LUT.
4. Extending an Address LUT.
5. Signing and sending a versioned transaction using a LUT.

## Build a versioned transaction

Versioned transactions are built in a very similar fashion to [legacy transactions](sending-a-transaction). The only difference is that developers should use the `VersionedTransaction` class rather than the `Transaction` class.

The following example shows how to build a simple transfer instruction. Once the transfer instruction is made, a `MessageV0` formatted transaction message is constructed with the transfer instruction. Finally, a new `VersionedTransaction` is created, parsing in the `v0` compatible message.

### createTransactionV0()

```typescript
// create array of instructions
const instructions = [
  SystemProgram.transfer({
    fromPubkey: publicKey,
    toPubkey: publicKey,
    lamports: 10,
  }),
];

// create v0 compatible message
const messageV0 = new TransactionMessage({
  payerKey: publicKey,
  recentBlockhash: blockhash,
  instructions,
}).compileToV0Message();

// make a versioned transaction
const transactionV0 = new VersionedTransaction(messageV0);
```

For a live example of creating a versioned transaction, refer to [createTransferTransactionV0](https://github.com/phantom-labs/sandbox/blob/main/src/utils/createTransferTransactionV0.ts) in our sandbox.

## Sign and send a versioned transaction

Once a Versioned transaction is created, it can be signed and sent via Phantom using the `signAndSendTransaction` method on the provider. The call will return a [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) for an object containing the `signature`. This is the same way a legacy transaction is sent via the Phantom provider.

### signAndSendTransaction()

```javascript
const provider = getProvider(); // see "Detecting the Provider"
const network = "<NETWORK_URL>";
const connection = new Connection(network);
const versionedTransaction = new VersionedTransaction();
const { signature } = await provider.signAndSendTransaction(versionedTransaction);
await connection.getSignatureStatus(signature);
```

You can also specify a `SendOptions` [object](https://solana-foundation.github.io/solana-web3.js/modules.html#SendOptions) as a second argument into `signAndSendTransaction()` or as an `options` parameter when using `request`.

For a live demo of signing and sending a versioned transaction, refer to [handleSignAndSendTransactionV0](https://github.com/phantom-labs/sandbox/blob/78dc35fe140140a961345a6af30a058e1e19a7aa/src/App.tsx#L191) in our sandbox.

## Build an Address LUT

Address LUTs can be used to load accounts into table-like data structures. These structures can then be referenced to significantly increase the number of accounts that can be loaded in a single transaction.

This lookup method effectively "*compresses*" a 32-byte address into a 1-byte index value. This "*compression*" enables storing up to 256 address in a single LUT for use inside any given transaction.

With the `@solana/web3.js` [createLookupTable](https://solana-foundation.github.io/solana-web3.js/classes/AddressLookupTableProgram.html#createLookupTable) method, developers can construct the instruction needed to create a new LUT, as well as determine its address. Once we have the LUT instruction, we can construct a transaction, sign it, and send it to create a LUT on-chain. Address LUTs can be created with either a `v0` transaction or a `legacy` transaction. However, the Solana runtime can only retrieve and handle the additional addresses within a LUT while using `v0` transactions.

The following is a code snippet that creates a LUT.

### createAddressLookupTable()

```typescript
// create an Address Lookup Table
const [lookupTableInst, lookupTableAddress] = AddressLookupTableProgram.createLookupTable({
  authority: publicKey,
  payer: publicKey,
  recentSlot: slot,
});

// To create the Address Lookup Table on chain:
// send the `lookupTableInst` instruction in a transaction
const lookupMessage = new TransactionMessage({
  payerKey: publicKey,
  recentBlockhash: blockhash,
  instructions: [lookupTableInst],
}).compileToV0Message();

const lookupTransaction = new VersionedTransaction(lookupMessage);
const lookupSignature = await signAndSendTransaction(provider, lookupTransaction);
```

For a live demo of creating a LUT, refer to [handleSignAndSendTransactionV0WithLookupTable](https://github.com/phantom-labs/sandbox/blob/78dc35fe140140a961345a6af30a058e1e19a7aa/src/App.tsx#L218) in our sandbox.

## Extend an Address LUT

Once an Address LUT is created, it can then be extended, which means that accounts can be appended to the table. Using the `@solana/web3.js` library, you can create a new `extend` instruction using the [extendLookupTable](https://solana-labs.github.io/solana-web3.js/classes/AddressLookupTableProgram.html#extendLookupTable) method. Once the extend instruction is created, it can be sent in a transaction.

### extendAddressLookupTable()

```typescript
// add addresses to the `lookupTableAddress` table via an `extend` instruction
const extendInstruction = AddressLookupTableProgram.extendLookupTable({
  payer: publicKey,
  authority: publicKey,
  lookupTable: lookupTableAddress,
  addresses: [
    publicKey,
    SystemProgram.programId,
    // more `publicKey` addresses can be listed here
  ],
});

// Send this `extendInstruction` in a transaction to the cluster
// to insert the listing of `addresses` into your lookup table with address `lookupTableAddress`
const extensionMessageV0 = new TransactionMessage({
  payerKey: publicKey,
  recentBlockhash: blockhash,
  instructions: [extendInstruction],
}).compileToV0Message();

const extensionTransactionV0 = new VersionedTransaction(extensionMessageV0);
const extensionSignature = await signAndSendTransaction(provider, extensionTransactionV0);
```

For a live demo of extending a LUT, refer to the [handleSignAndSendTransactionV0WithLookupTable](https://github.com/phantom-labs/sandbox/blob/78dc35fe140140a961345a6af30a058e1e19a7aa/src/App.tsx#L218) function in our sandbox.

## Sign and send a versioned transaction using a LUT

Up until now, we have:

1. Learned how to create a `VersionedTransaction`.
2. Created an Address LUT.
3. Extended the Address LUT.

At this point, we are now ready to sign and send a `VersionedTransaction` using an Address LUT.

First, we need to fetch the account of the created Address LUT.

### getAddressLookupTable()

```typescript
// get the table from the cluster
const lookupTableAccount = await connection.getAddressLookupTable(lookupTableAddress).then((res) => res.value);
// `lookupTableAccount` will now be a `AddressLookupTableAccount` object
console.log('Table address from cluster:', lookupTableAccount.key.toBase58());
```

We can also parse and read all the addresses currently stores in the fetched Address LUT.

## Parse and read addresses

```typescript
// Loop through and parse all the address stored in the table
for (let i = 0; i < lookupTableAccount.state.addresses.length; i++) {
  const address = lookupTableAccount.state.addresses[i];
  console.log(i, address.toBase58());
}
```

We can now create the instructions array with an arbitrary transfer instruction, just the way we did while creating the `VersionedTransaction` earlier. This `VersionedTransaction` can then be sent using the `signAndSendTransaction()` provider function.

```typescript
// create an array with your desired `instructions`
// in this case, just a transfer instruction
const instructions = [
  SystemProgram.transfer({
    fromPubkey: publicKey,
    toPubkey: publicKey,
    lamports: minRent,
  }),
];

// create v0 compatible message
const messageV0 = new TransactionMessage({
  payerKey: publicKey,
  recentBlockhash: blockhash,
  instructions,
}).compileToV0Message([lookupTableAccount]);

// make a versioned transaction
const transactionV0 = new VersionedTransaction(messageV0);
const signature = await signAndSendTransaction(provider, transactionV0);
```

For a live demo of of signing and sending a versioned transaction using an Address LUT, refer to the [handleSignAndSendTransactionV0WithLookupTable](https://github.com/phantom-labs/sandbox/blob/78dc35fe140140a961345a6af30a058e1e19a7aa/src/App.tsx#L218) in our sandbox.


# Sign a message
Source: https://docs.phantom.com/solana/signing-a-message



When a web application is connected to Phantom, it can also request that the user signs a given message. Applications are free to write their own messages which will be displayed to users from within Phantom's signature prompt. Message signatures do not involve network fees and are a convenient way for apps to verify ownership of an address.

In order to send a message for the user to sign, a web application must:

1. Provide a **hex** or **UTF-8** encoded string as a Uint8Array.
2. Request that the encoded message is signed via the user's Phantom wallet.

For an example of signing a message, refer to [handleSignMessage](https://github.com/phantom-labs/sandbox/blob/b57fdd0e65ce4f01290141a01e33d17fd2f539b9/src/App.tsx#L242) in our sandbox.

<Info>
  Phantom uses Ed25519 signatures for Solana message signatures. To verify a message signature, you can use the [tweetnacl](https://www.npmjs.com/package/tweetnacl) npm package.
</Info>

## signMessage()

```javascript
const provider = getProvider(); // see "Detecting the Provider"
const message = `To avoid digital dognappers, sign below to authenticate with CryptoCorgis`;
const encodedMessage = new TextEncoder().encode(message);
const signedMessage = await provider.signMessage(encodedMessage, "utf8");
```

## request()

```javascript
const provider = getProvider(); // see "Detecting the Provider"
const message = `To avoid digital dognappers, sign below to authenticate with CryptoCorgis`;
const encodedMessage = new TextEncoder().encode(message);
const signedMessage = await provider.request({
    method: "signMessage",
    params: {
         message: encodedMessage,
         display: "hex",
    },
});
```

## Sign-In with Solana (SIWS)

Developers who use `signMessage` to authenticate users can now take advantage of Phantom's new [Sign-In with Solana](https://github.com/phantom/sign-in-with-solana) feature. For more information, refer to our [specification](https://github.com/phantom/sign-in-with-solana)  on GitHub.

## Support for other "Sign-In with" Standards

Phantom supports a range of "Sign-In with" (SIW) message standards. You can read more about them in [Sign a message](/developer-powertools/signing-a-message).


# Detect the provider
Source: https://docs.phantom.com/sui/detecting-the-provider



To detect if a user has already installed Phantom, a web application should check for the existence of a `phantom` object. Phantom's browser extension and mobile in-app browser will both inject a `phantom` object into the [window](https://developer.mozilla.org/en-US/docs/Web/API/Window) of any web application the user visits, provided that site is using `https://`, on `localhost`, or is `127.0.0.1`. Phantom will not inject the provider into sites using http\://.

If a `phantom` object exists, Sui apps can interact with Phantom via the API found at `window.phantom.sui`.

To detect if Phantom is installed, an application should check for an additional `isPhantom` flag.

```typescript
const isPhantomInstalled = window.phantom?.sui?.isPhantom
```

If Phantom is not installed, we recommend you redirect your users to our website `https://www.phantom.com/`. Altogether this may look like the following:

```typescript
const getProvider = () => {
  if ('phantom' in window) {
    const provider = window.phantom?.sui;

    if (provider?.isPhantom) {
      return provider;
    }
  }
  window.open('https://phantom.com/', '_blank');
};
```


# Establish a connection
Source: https://docs.phantom.com/sui/establishing-a-connection



Once an application has detected the provider, it can then request to connect to Phantom. This connection request will prompt the user for permission to share their public key, indicating that they are willing to interact further. Users must approve a connection request before the app can make additional requests such as [signing a message](/sui/signing-a-message) or [sending a transaction](/sui/sending-a-transaction).

Once permission is established for the first time, the web application's domain will be whitelisted for future connection requests. After a connection is established, it is possible for the user to terminate the connection from the Phantom settings UI.

## Connect

The recommended and easiest way to connect to Phantom is by calling `window.phantom.sui.requestAccount()`.

```typescript
const provider = getProvider(); // see "Detecting the Provider"
try {
    const resp = await provider.requestAccount();
    console.log(resp.publicKey.toString());
} catch (err) {
    // { code: 4001, message: 'User rejected the request.' }
}
```


# Get started with Sui
Source: https://docs.phantom.com/sui/getting-started-with-sui



The Phantom browser extension and mobile in-app browser now have full support for Sui dapps.


# Send a transaction
Source: https://docs.phantom.com/sui/sending-a-transaction



Once a dapp is connected to Phantom, it can request user permission to send transactions on their behalf. To initiate a transaction, ensure you have the necessary parameters. For details on constructing transactions, refer to [Sui developer documentation](https://sdk.mystenlabs.com/typescript/transaction-building/basics).

```typescript
const transactionParams = {
        transaction: await tx.toJSON(), // Replace with actual transaction
        address: address.toString(), // Sender address
        networkID: SupportedSuiChainIds.SuiMainnet, // or your network ID
};
```

To prompt Phantom to send a transaction to the network, refer to the following code snippet:

```typescript
try {
    const signature = await provider.signTransaction(params);
    return signature;
} catch (error) {
    throw new Error(error instanceof Error ? error.message : 'Failed to sign transaction');
}
```


# Sign a message
Source: https://docs.phantom.com/sui/signing-a-message



When a web application is [connected](/sui/establishing-a-connection) to Phantom, it can also request that the user signs a given message. Applications are free to write their own messages which will be displayed to users from within Phantom's signature prompt. Message signatures do not involve network fees and are a convenient way for apps to verify ownership of an address.

```typescript
try {
    const encodedMessage = new TextEncoder().encode(message);
    const signature = await provider.signMessage(encodedMessage, address);
    return signature;
} catch (error) {
    throw new Error(error instanceof Error ? error.message : 'Failed to sign message');
}
```


